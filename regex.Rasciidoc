= Regular Expressions in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

== Regular Expressions

- Ausdruck: etwas, das nicht buchst&auml;blich gemeint ist.

- POSIX 1003.2 standard
  http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html

- https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines

//begin.rcode, echo  = FALSE
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}

is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}

//end.rcode

== Email und Passwort

== Email
//begin.rcode
mails <- c("dominik.cullmann@forst.bwlde", 
           "@2.de", 
           "dominik.cullmann@forst.bwl.de")

print(cbind(mails, is_probably_valid_email(mails)))
//end.rcode

==  Passwort
//begin.rcode
passwords <- c("Aa$4567",
               "aa$45678",
               "AA$45678",
               "Aa345678",
               "Aa$45678"
               )
print(cbind(passwords, is_valid_password(passwords)))
//end.rcode

== is_valid_password
//begin.rcode, eval  = FALSE
# min. 8 Zeichen, Klein-, Grossbuchstabe, Zahl, Sonderzeichen
is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}

//end.rcode

== is_probably_valid_email
//begin.rcode, eval  = FALSE
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}
//end.rcode

== Wiederholungen
//begin.rcode
replacement  <- "##"
x <- "B BA BAA BAAA CA"
gsub(pattern = "BA", replacement, x)
gsub(pattern = "BA{2,3}", replacement, x)
gsub(pattern = "BA{1,}", replacement, x)
gsub(pattern = "BA+", replacement, x)
gsub(pattern = "BA{0,}", replacement, x)
gsub(pattern = "BA*", replacement, x)
gsub(pattern = "BA{0,1}", replacement, x)
gsub(pattern = "BA?", replacement, x)
//end.rcode

== Gruppen
//begin.rcode
replacement  <- "##"
x <- "BA BABA BABABA BABABABA"
gsub(pattern = "(BA)", replacement, x)
gsub(pattern = "(BA){2,3}", replacement, x)
//end.rcode
== Anker
//begin.rcode
replacement  <- "##"
x <- "Ha Ha HaHa Ha"
gsub(pattern = "^Ha", replacement, x)
gsub(pattern = "Ha$", replacement, x)
gsub(pattern = "\\<Ha\\>", replacement, x)
//end.rcode

== Character Sets
//begin.rcode
replacement  <- ""
x <-  paste(c(letters, LETTERS," ", pi), collapse = "")
print(x)
gsub(pattern = "[ .]", replacement, x)
gsub(pattern = "[1-3]", replacement, x)
gsub(pattern = "[^1-3]", replacement, x) ## Negative Set

gsub(pattern = "[[:upper:]]", replacement, x)
gsub(pattern = "[[:digit:]]", replacement, x)
gsub(pattern = "[[:digit:][:space:]]", replacement, x)
//begin.rcode

Der Punkt
//end.rcode
replacement  <- "##"
gsub(pattern = "1.", replacement, x)
sub(pattern = "1.*", replacement, x)
sub(pattern = ".*", replacement, x)
//end.rcode


== A Simple String
//begin.rcode
string <- "This is a (character) string."
paste(is.vector(string), is.character(string), class(string), sep = " ## ")
paste(length(string), nchar(string), sep = " ## ")
//end.rcode

== Regular Expressions for a Simple String
//begin.rcode
pattern <- "is"
regexpr(pattern, string) # a vector giving start and length of the first match
regexec(pattern, string) # the same, as a list, better for groups.
grep(pattern, string) # indices of elements of "string" matching "pattern"
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
grepl(pattern, string) # Do elements of "string" contain "pattern"?
gregexpr(pattern, string) # a vector giving start and length of matches
sub(pattern, "##", string) # replace first match of pattern in string
gsub(pattern, "##", string) # replace all matches of pattern in string
//end.rcode

== A Character Vector
//begin.rcode
string <- c("This is a (not too) long sentence, stored in a (character) string.",
            "Well, it is (actually) stored in a vector of class character.", 
            "And this is not a single sentence.")

paste(is.vector(string), is.character(string), class(string), sep = " ## ")
paste(length(string), nchar(string), sep = " ## ")
//end.rcode

== Regular Expressions for a Character Vector
//begin.rcode
pattern <- "is"
regexpr(pattern, string) # a vector giving start and length of the first match
regexec(pattern, string) # the same, as a list, better for groups.
grep(pattern, string) # indices of elements of "string" matching "pattern"
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
grepl(pattern, string) # Do elements of "string" contain "pattern"?
gregexpr(pattern, string) # a vector giving start and length of matches
sub(pattern, "##", string) # replace first match of pattern in string
gsub(pattern, "##", string) # replace all matches of pattern in string
//end.rcode



== FIXME
//begin.rcode
pattern <- "\\(.*\\)"

regexpr(pattern, string) 
regexec(pattern, string) 

grep(pattern, string)
grepl(pattern, string)
grep(pattern, string, value = TRUE)

substition <- "[FOO]"
print(new_string <- sub(pattern, substition, string))
nchar(string)
nchar(new_string)

pattern <- "\\(.*?\\)" ## non-greedy quantifier
print(new_string <- sub(pattern, substition, string))
nchar(string)
nchar(new_string)

pattern <- "\\([^\\)]+\\)" ## lazy quantifier using negation
print(new_string <- sub(pattern, substition, string))
nchar(string)
nchar(new_string)

pattern <- "\\<[[:alnum:]]*\\>"
substition <- "[HERE WAS THE FIRST WORD]"
regexpr(pattern, string) 
sub(pattern, substition, string)

pattern <- "(\\<a\\>)"
substition <- "\\1[INJECTED TEXT]"
regexpr(pattern, string) 
sub(pattern, substition, string)
gregexpr(pattern, string) 
gsub(pattern, substition, string)

pattern <- "^([[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?)\\<[[:alnum:]_]*\\>"
substition <- "\\1[HERE WAS THE SECOND WORD]"
regexpr(pattern, string) 
sub(pattern, substition, string)


pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>"
substition <- "\\1[HERE WAS THE FOURTH WORD]"
regexpr(pattern, string) 
sub(pattern, substition, string)

pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>(.*)$"
substition <- "\\1[HERE WAS THE FOURTH WORD]\\2"
regexpr(pattern, string) 
sub(pattern, substition, string)

gsub("(?:\\(.*?\\)|long)[[:space:]]", "", string)
gsub("(?:\\(.*?\\)|long)\\  *", "", string)


# Anwendung mit Dateipfaden

## Dateien bereitstellen
rm(list= ls())
path <- file.path(tempdir(), "foo")
unlink(path, recursive = TRUE)
dir.create(path)
for (name in c("mtcars", "iris")) {
    file_name <- paste0(name, ".csv")
    write.csv(get(name), file = file.path(path, file_name))
}



## Dateien lesen und wieder schreiben als deutsches CSV
print(files <- list.files(path, full.names = TRUE))

for (file in files) {
    file_name <- basename(file)
    new_file <- sub("(.*)(\\.csv)", "\\1_german\\2", file)
    write.csv2(read.csv(file), file = new_file)
}
print(list.files(path, full.names = TRUE))

## Dateien in noch nicht existente Verzeichnisse verschieben
# Das hat aber nichts mit regex zu tun.
path <- file.path(tempdir(), "bar", "foobar")
unlink(path, recursive = TRUE)
file_rename <- function(from, to) {
    root <- dirname(to)
    if (! dir.exists(root)) dir.create(root, recursive = TRUE)
    return(file.rename(from, to))
}
file_rename(file, file.path(path, basename(file)))

# Anwendung camelCase -- mit Perl regex
code_file <- file.path(tempdir(), "code.R")
code <- "fileRename <- function(from, to) {
root <- dirname(to)
if (! dir.exists(root)) dir.create(root, recursive = TRUE)
return(file.rename(from, to))
}
"
cat(code, file = code_file)
print(readLines(code_file))

code <- readLines(code_file)
code <- gsub("([A-Z])[a-z]", "_\\L\\1", code, perl = TRUE)
writeLines(code, code_file)
print(readLines(code_file))


//end.rcode
== Sonst noch

- ?base::regex
- ?base::grep ## (grepl, sub, gsub, regexec, regexpr, gregexpr)
- ?base::regmatches
- install.packages(c("stringi")) ## (ICU regex engine)

== regmatches
Es gibt no base::regmatches(), aber das benutze ich nie, das ist mir zu kompliziert.
Beispiel aus der Hilfe:
//begin.rcode
 ## Consider
 x <- "John (fishing, hunting), Paul (hiking, biking)"
 ## Suppose we want to split at the comma (plus spaces) between the
 ## persons, but not at the commas in the parenthesized hobby lists.
 ## One idea is to "blank out" the parenthesized parts to match the
 ## parts to be used for splitting, and extract the persons as the
 ## non-matched parts.
 ## First, match the parenthesized hobby lists.
 m <- gregexpr("\\([^)]*\\)", x)
 ## Write a little utility for creating blank strings with given numbers
 ## of characters.
 blanks <- function(n) strrep(" ", n)
 ## Create a copy of x with the parenthesized parts blanked out.
 s <- x
 regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
 ## Compute the positions of the split matches (note that we cannot call
 ## strsplit() on x with match data from s).
 m <- gregexpr(", *", s)
 ## And finally extract the non-matched parts.
 regmatches(x, m, invert = TRUE)

//end.rcode
