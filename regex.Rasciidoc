= Regular Expressions in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

== Regular Expressions

- Ausdruck: etwas, das nicht buchst&auml;blich gemeint ist.

- https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines

-  R (?base::regex)

    *     The TRE documentation at <URL:
          http://laurikari.net/tre/documentation/regex-syntax/>).
    
    *     The POSIX 1003.2 standard at <URL:
          http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>
   
    *     The ‘pcrepattern’ ‘man’ page (found as part of <URL:
          http://www.pcre.org/original/pcre.txt>), and details of Perl’s own
          implementation at <URL: http://perldoc.perl.org/perlre.html>.


//begin.rcode, echo  = FALSE
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}

is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}

//end.rcode

== Email und Passwort

== Email
//begin.rcode
mails <- c("dominik.cullmann@forst.bwlde", 
           "@2.de", 
           "dominik.cullmann@forst.bwl.de")

print(cbind(mails, is_probably_valid_email(mails)))
//end.rcode

==  Passwort
//begin.rcode
passwords <- c("Aa$4567",
               "aa$45678",
               "AA$45678",
               "Aa345678",
               "Aa$45678"
               )
print(cbind(passwords, is_valid_password(passwords)))
//end.rcode

== is_valid_password
//begin.rcode, eval  = FALSE
# min. 8 Zeichen, Klein-, Grossbuchstabe, Zahl, Sonderzeichen
is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}

//end.rcode

== is_probably_valid_email
//begin.rcode, eval  = FALSE
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}
//end.rcode
 
== Wiederholungen 

. {m,n}
. +
. *
. ?

== Wiederholungen I 
//begin.rcode
replacement  <- "##"
x <- "B BA BAA BAAA CA"
gsub(pattern = "BA", replacement, x)
gsub(pattern = "BA{2,3}", replacement, x)
//end.rcode
== Wiederholungen II
//begin.rcode
gsub(pattern = "BA{0,1}", replacement, x)
gsub(pattern = "BA?", replacement, x)
//end.rcode
== Wiederholungen III
//begin.rcode
gsub(pattern = "BA{1,}", replacement, x)
gsub(pattern = "BA+", replacement, x)
//end.rcode
== Wiederholungen IV
//begin.rcode
gsub(pattern = "BA{0,}", replacement, x)
gsub(pattern = "BA*", replacement, x)
//end.rcode

== Gruppen
//begin.rcode
replacement  <- "##"
x <- "ABA ABABA ABABABA ABABABABA"
gsub(pattern = "(BA)", replacement, x)
gsub(pattern = "(BA){2,3}", replacement, x)
//end.rcode
== Anker
//begin.rcode
replacement  <- "##"
x <- "Ha Ha HaHa Ha"
gsub(pattern = "^Ha", replacement, x)
gsub(pattern = "Ha$", replacement, x)
gsub(pattern = "\\<Ha\\>", replacement, x)
//end.rcode

== Character Sets

. Eigene Definitionen
. Vorgefertigte Definitionen
. Der Punkt

//begin.rcode
x <-  paste(c(letters, LETTERS," ", pi), collapse = "")
print(x)
replacement  <- "#"
//end.rcode
== Character Sets I
//begin.rcode
gsub(pattern = "[ .]", replacement, x)
gsub(pattern = "[1-3]", replacement, x)
gsub(pattern = "[^1-3]", replacement, x) ## Negative Set
//end.rcode

== Character Sets II
//begin.rcode
gsub(pattern = "[[:upper:]]", replacement, x)
gsub(pattern = "[[:digit:]]", replacement, x)
gsub(pattern = "[[:digit:][:space:]]", replacement, x)
//end.rcode

== Character Sets III
//begin.rcode
replacement  <- "##"
gsub(pattern = "1.", replacement, x)
sub(pattern = "1.*", replacement, x)
sub(pattern = ".*", replacement, x)
//end.rcode

== OR
//begin.rcode
mail <- readLines(file.path(".", "src", "mail.txt"))
grep(pattern = "^From:", mail, value = TRUE)
grep(pattern = "^Subject:", mail, value = TRUE)
grep(pattern = "^[FS][[:alnum:]]*\\>:", mail, value = TRUE)
grep(pattern = "^(From|Subject):", mail, value = TRUE)
//end.rcode



== A Simple String
//begin.rcode
string <- "This is a (character) string."
paste(is.vector(string), is.character(string), class(string), sep = " ## ")
paste(length(string), nchar(string), sep = " ## ")
pattern <- "is"
//end.rcode

== Regular Expressions for a Simple String
//begin.rcode
regexpr(pattern, string) # a vector giving start and length of the first match
regexec(pattern, string) # a list giving start and length of first match and groupings
gregexpr(pattern, string) # a vector giving start and length of matches
grep(pattern, string) # indices of elements of "string" matching "pattern"
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
grepl(pattern, string) # Do elements of "string" contain "pattern"?
sub(pattern, "##", string) # replace first match of pattern in string
gsub(pattern, "##", string) # replace all matches of pattern in string
//end.rcode

== A Character Vector
//begin.rcode
string <- c("This is a (not too) long sentence, stored in a (character) string.",
            "Well, it is (actually) a vector of class character.", 
            "And this is not a single sentence.")

paste(is.vector(string), is.character(string), class(string), sep = " ## ")
paste(length(string), nchar(string), sep = " ## ")
pattern <- "[[:punct:]]?\\<[[:alnum:]]*\\>[[:punct:]]?\\s\\<(th|st)[[:alnum:]]*\\>" 
## \\s is the space class, see ?regex
//end.rcode

== Regular Expressions for a Character Vector
//begin.rcode
regexpr(pattern, string) # a vector giving start and length of the first match
regexec(pattern, string) # a list giving start and length of first match and groupings
gregexpr(pattern, string) # a vector giving start and length of matches
grep(pattern, string) # indices of elements of "string" matching "pattern"
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
grepl(pattern, string) # Do elements of "string" contain "pattern"?
sub(pattern, "##", string) # replace first match of pattern in string
gsub(pattern, "##", string) # replace all matches of pattern in string
//end.rcode



== Gefr&auml;&szlig;igkeit (greediness)
//begin.rcode
pattern <- " \\(.*\\)" 
substitution <- "" 
print(new_string <- gsub(pattern, substitution, string))

pattern <- " \\([^\\)]*\\)" ## lazy quantifier using negation
print(new_string <- gsub(pattern, substitution, string))

pattern <- " \\(.*?\\)" ## non-greedy quantifier -- wtf?
print(new_string <- gsub(pattern, substitution, string))

//end.rcode

== R&uuml;ckverweise

!FIXME
//begin.rcode
pattern <- "(\\<a\\>)"
substitution <- "\\1[INJECTED TEXT]"
gsub(pattern, substitution, string)

pattern <- "^([[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?)\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)


# inner grouping without backreference -- nth word, substitution stays constant
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)


# matching the rest of the line into a second group
pattern <- paste0(pattern, "(.*)$")
substitution <- paste0(substitution, "\\2")
sub(pattern, substitution, string)

//end.rcode

== Dateipfade

!FIXME
//begin.rcode

# Anwendung mit Dateipfaden

## Dateien bereitstellen
rm(list= ls())
path <- file.path(tempdir(), "foo")
unlink(path, recursive = TRUE)
dir.create(path)
for (name in c("mtcars", "iris")) {
    file_name <- paste0(name, ".csv")
    write.csv(get(name), file = file.path(path, file_name))
}



## Dateien lesen und wieder schreiben als deutsches CSV
print(files <- list.files(path, full.names = TRUE))

for (file in files) {
    file_name <- basename(file)
    new_file <- sub("(.*)(\\.csv)", "\\1_german\\2", file)
    write.csv2(read.csv(file), file = new_file)
}
print(list.files(path, full.names = TRUE))

## Dateien in noch nicht existente Verzeichnisse verschieben
# Das hat aber nichts mit regex zu tun.
path <- file.path(tempdir(), "bar", "foobar")
unlink(path, recursive = TRUE)
file_rename <- function(from, to) {
    root <- dirname(to)
    if (! dir.exists(root)) dir.create(root, recursive = TRUE)
    return(file.rename(from, to))
}
file_rename(file, file.path(path, basename(file)))

# Anwendung camelCase -- mit Perl regex
code_file <- file.path(tempdir(), "code.R")
code <- "fileRename <- function(from, to) {
root <- dirname(to)
if (! dir.exists(root)) dir.create(root, recursive = TRUE)
return(file.rename(from, to))
}
"
cat(code, file = code_file)
print(readLines(code_file))

code <- readLines(code_file)
code <- gsub("([A-Z])[a-z]", "_\\L\\1", code, perl = TRUE)
writeLines(code, code_file)
print(readLines(code_file))


//end.rcode
== Regex in R

Meine Lieblinge

- base::regex
- base::grep # (grepl, sub, gsub, regexec, regexpr, gregexpr)
- base::list.files
- base::ls 

Sonst noch:

- install.packages(c("stringi")) ## (ICU regex engine)
- utils::apropos # (find)
- utils::browseEnv
- utils::glob2rx
- utils::help.search
- base::strsplit
- base::regmatches

== regmatches
Es gibt no base::regmatches(), aber das benutze ich nie, das ist mir zu kompliziert.
Beispiel aus der Hilfe:
//begin.rcode
 ## Consider
 x <- "John (fishing, hunting), Paul (hiking, biking)"
 ## Suppose we want to split at the comma (plus spaces) between the
 ## persons, but not at the commas in the parenthesized hobby lists.
 ## One idea is to "blank out" the parenthesized parts to match the
 ## parts to be used for splitting, and extract the persons as the
 ## non-matched parts.
 ## First, match the parenthesized hobby lists.
 m <- gregexpr("\\([^)]*\\)", x)
 ## Write a little utility for creating blank strings with given numbers
 ## of characters.
 blanks <- function(n) strrep(" ", n)
 ## Create a copy of x with the parenthesized parts blanked out.
 s <- x
 regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
 ## Compute the positions of the split matches (note that we cannot call
 ## strsplit() on x with match data from s).
 m <- gregexpr(", *", s)
 ## And finally extract the non-matched parts.
 regmatches(x, m, invert = TRUE)

//end.rcode

== Ende

- regex sind toll
- (vor allem f&auml;lschlicherweise gefr&auml;&szlig;ige) regex sind _sehr_ fehleranf&auml;llig.
- Teste daher alle Deine regex sorgf&auml;ltig.

