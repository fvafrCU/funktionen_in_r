= Unit Testing in **R**
Anne-Sophie Stelzer, Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60


== Skript
https://fvafrcu.gitlab.io/funktionen_in_r/[https://fvafrcu.gitlab.io/funktionen_in_r/]

https://fvafrcu.gitlab.io/funktionen_in_r/unit_testing.html[https://fvafrcu.gitlab.io/funktionen_in_r/unit_testing.html]



== Worum geht es?

- Was soll meine Funktion tun?
- Tut sie es auch?
- Tut sie es auch noch, wenn ich sie ver&auml;ndert/verbessert habe?

**R** +
    (Python: Module _unittest_ und _coverage_, C: https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C[mehrere Dutzend] und _Gcov_, ...) 


== Zwei Funktionen

- Richtige Funktion

[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----

- Falsche Funktion

[source,r]
----
not_my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value - x_i 
    }
    return(value)
}
----


== Erwartungen 
Die kleinste Testeinheit ist immer ein Vergleich. 

In base **R**:


[source,r]
----
my_sum(c(2, 7)) == 9
----

----
## [1] TRUE
----

[source,r]
----
# better use identical(), see ?Comparison 
identical(not_my_sum(c(2, 7)), 9)
----

----
## [1] FALSE
----

 
== Pakete

- Wozu
  * Formalisieren
  * Berichten



- Pakete 
  * https://CRAN.R-project.org/package=RUnit[RUnit] gibt es schon seit 2004, es ist sehr formal
   und hat wenige Abhängigkeiten (daher bevorzuge ich es beim Testen von Paketen).
  * https://CRAN.R-project.org/package=testthat[testthat] finde ich interaktiv einfacher anzuwenden.



== Wieder Erwartungen

.https://CRAN.R-project.org/package=RUnit[RUnit]

[source,r]
----
RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
----

[source,r]
----
## Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9): FALSE 
## 

----


.https://CRAN.R-project.org/package=testthat[testthat]

[source,r]
----
testthat::expect_identical(not_my_sum(c(2, 7)), 9)
----


----
## not_my_sum(c(2, 7)) not identical to 9.
## 1/1 mismatches
## [1] -9 - 9 == -18
----


== Tests 

Zusammenfassung mehrer Erwartungen (gew&ouml;hnlich f&uuml;r eine Funktion).

Strukturierte Berichte bei mehreren Funktionen (z.B. in Paketen).


== Funktionen testen -- https://CRAN.R-project.org/package=testthat[testthat]

[source,r]
----
testthat::context("My first test.")
testthat::test_that("Simple test on summation.", {
                        testthat::expect_identical(not_my_sum(c(2, 7)), 9,
                                                   info = "Not my sum.")
                        testthat::expect_identical(my_sum(c(2, 7)), 9, 
                                                   info = "My sum.")
})
----

[source,r]
----
## Error: Test failed: 'Simple test on summation.'
## * not_my_sum(c(2, 7)) not identical to 9.
## 1/1 mismatches
## [1] -9 - 9 == -18
## Not my sum.

----


== Funktionen testen -- https://CRAN.R-project.org/package=RUnit[RUnit]

[source,r]
----
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9, msg = "Not my sum")
    RUnit::checkIdentical(my_sum(c(2, 7)), 9, msg = "My sum")
}
test_sum()
----

[source,r]
----
## Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9, msg = "Not my sum"): FALSE 
##  Not my sum

----


== Testdateien -- testthat

[source,r]
----
testthat::test_file(file.path("src", "test_my_sum.R"))
----

----
## ✔ | OK F W S | Context
## ⠏ |  0       | My first test.⠋ |  0 1     | My first test.⠙ |  1 1     | My first test.✖ |  1 1     | My first test.
## ───────────────────────────────────────────────────────────────────────────
## test_my_sum.R:3: failure: Simple test on summation.
## not_my_sum(c(2, 7)) not identical to 9.
## 1/1 mismatches
## [1] -9 - 9 == -18
## Not my sum.
## ───────────────────────────────────────────────────────────────────────────
## 
## ══ Results ════════════════════════════════════════════════════════════════
## OK:       1
## Failed:   1
## Warnings: 0
## Skipped:  0
----


== Testdateien -- RUnit

[source,r]
----
test_file <- normalizePath(file.path("src", "runit_my_sum.R"))
runit <- RUnit::runTestFile(test_file)
----

----
## 
## 
## Executing test function test_sum  ... Timing stopped at: 0 0 0.001 
##  done successfully.
----


== Testdateien -- RUnit II

[source,r]
----
RUnit::printTextProtocol(runit)
----

----
## RUNIT TEST PROTOCOL -- Fri Jul 20 08:33:58 2018 
## *********************************************** 
## Number of test functions: 1 
## Number of errors: 0 
## Number of failures: 1 
## 
##  
## 1 Test Suite : 
## runit_my_sum - 1 test function, 0 errors, 1 failure
## FAILURE in test_sum: Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9) : FALSE 
##  
## 
## 
## 
## Details 
## *************************** 
## Test Suite: runit_my_sum 
## Test function regexp: ^test.+ 
## Test file regexp: ^runit_my_sum.R$ 
## Involved directory: 
## /home/qwer/git/cyclops/fvafrcu/funktionen_in_r/src 
## --------------------------- 
## Test file: /home/qwer/git/cyclops/fvafrcu/funktionen_in_r/src/runit_my_sum.R 
## test_sum: FAILURE !! (check number 1)
## Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9) : FALSE 
## 
----


== Code Coverage

- https://en.wikipedia.org/wiki/Code_coverage[Überdeckung]
- Paket https://CRAN.R-project.org/package=covr[covr]  +
  (Ich glaube: https://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria[_branch coverage_])
- Prinzipiell: Hohe Überdeckung ist gut.

== Code Coverage -- Funktionen und Tests in Dateien


.src/my_sum_assertion.R

[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



.src/test_my_sum_assertion.R

[source,r]
----
testthat::context("Tests for summation with argument assertion.")
testthat::test_that("Testing summation", {
                    testthat::expect_identical(my_sum(c(2, 7)), 9)
                    testthat::expect_error(my_sum(c("2" + "7")))
})
----


== Code Coverage -- Dateien


[source,r]
----
cov <- covr::file_coverage(file.path("src", "my_sum_assertion.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/my_sum_assertion.R: 100.00%

----


== Code Coverage -- Ungetesteter Code

.src/my_sum_coverage.R

[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    if (! is.numeric(x)) message("You'll never get here!")
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



== Code Coverage -- Analyse


[source,r]
----
cov <- covr::file_coverage(file.path("src", "my_sum_coverage.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
----

[source,r]
----
## Coverage: 83.33%

----

[source,r]
----
## src/my_sum_coverage.R: 83.33%

----

[source,r]
----
print(covr::zero_coverage(cov))
----

----
##                filename functions line value
## 2 src/my_sum_coverage.R    my_sum    3     0
----


== Nebenwirkungen statt R&uuml;ckgabewerte testen


Fehlerhafte Löschfunktion (vergleiche  
https://fvafrcu.gitlab.io/funktionen_in_r/#_arbeiten_mit_g%C3%BCltigkeitsbereichen):

.src/wipe_clean_broken.R
[source,r]
include::src/wipe_clean_broken.R[]

Testdatei:

.src/test_wipe_clean_broken.R
[source,r]
include::src/test_wipe_clean_broken.R[]

== Code Coverage -- Analyse Nebenwirkungen


[source,r]
----
cov <- covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                           file.path("src", "test_wipe_clean_broken.R"))
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/wipe_clean_broken.R: 100.00%

----


Alles gut? +
Nein, die Funktion ist kaputt und die Testdatei, die dies zeigt müsste 
auf die Nebenwirkung testen!

== Code Coverage -- Test der Nebenwirkungen
.src/test_wipe_clean.R
[source,r]
include::src/test_wipe_clean.R[]


[source,r]
----
covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                    file.path("src", "test_wipe_clean.R"))
----

[source,r]
----
## Error: Test failed: 'Test return value and side effects.'
## * ls() not identical to character(0).
## Lengths differ: 1 is not 0

----


== Was soll die ganze Testerei?

_Ich teste fast alle meine Funktion nach genau dem Ablauf in diesem Beispiel spätestens, 
wenn ich sie in ein Paket verpacke._

== https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldener Schnitt] 




.src/golden_ratio.R
// WARNING: Do not use
//     [source,r]
//     include::src/golden_ratio.R[]
// here as does not evaluate _now_ whereas knitr does!

[source,r]
----
golden_ratio  <- function() {
    phi <- (1 + sqrt(5)) / 2
    return(phi)
}
----


== https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldener Schnitt] -- Trivialer Test

.src/test_golden_ratio.R

[source,r]
----
testthat::test_that("Test on Golden Ratio", {
                        expectation <- (1 + sqrt(5)) / 2
                        result <- golden_ratio()
                        testthat::expect_identical(result, expectation)
})
----

[source,r]

[source,r]
----
covr::file_coverage(file.path("src", "golden_ratio.R"), 
                    file.path("src", "test_golden_ratio.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_ratio.R: 100.00%

----


== https://de.wikipedia.org/wiki/Goldener_Schnitt#Goldenes_Rechteck_und_Goldenes_Dreieck[Goldenes Rechteck] 

.src/golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(b) {
    a <- b * golden_ratio()
    return(c("a" = a, "b" = b))
}
----


== https://de.wikipedia.org/wiki/Goldener_Schnitt#Goldenes_Rechteck_und_Goldenes_Dreieck[Goldenes Rechteck]  -- Test


.src/test_golden_rectangle.R

[source,r]
----
testthat::test_that("Test on golden rectangle", {
                        b <- 2
                        expectation <- c(a = b * golden_ratio(), b = b)
                        result <- golden_rectangle(b)
                        testthat::expect_identical(result, expectation)
})
----


[source,r]
----
covr::file_coverage(file.path("src", c("golden_ratio.R", "golden_rectangle.R")), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_ratio.R: 100.00%

----

[source,r]
----
## src/golden_rectangle.R: 100.00%

----


== Anwendung

[source,r]
----
source(file.path("src", "golden_ratio.R"))
width <- 2
png("p1.png", units = "cm", res = 200, width = width, height = golden_rectangle(width)[["a"]])
par(mar=c(1, 1, 1, 1))
plot(cars)
dev.off()
----

----
## pdf 
##   2
----


.Oh, wie schön!
image::p1.png[]
[caption=""]


== Querformat

.src/golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(value, landscape = TRUE) {
    phi <- golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


== Anwendung

[source,r]
----
width <- 4
png("p2.png", units = "cm", res = 200, width = width, height = golden_rectangle(width)[["b"]])
par(mar=c(1, 1, 1, 1))
plot(cars)
dev.off()
----

----
## pdf 
##   2
----


.Auch sehr schön!
image::p2.png[]
[caption=""]

== Herzlichen Glückwunsch!

[source,r]
----
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Error: Test failed: 'Test on golden rectangle'
## * `result` not identical to `expectation`.
## 2/2 mismatches (average diff: 1)
## [1] 2.00 - 3.24 == -1.236
## [2] 1.24 - 2.00 == -0.764

----


Was bedeutet das?  
Du hast die Schnittstelle zerschossen und musst entweder

- *alle* Aufrufe der Funktion, die Du vor der Veränderung ihrer Schnittstelle progammiert hast, 
  anpassen (indem Du +, landscape = FALSE+ einfügst) oder
- die Funktion so ändern, dass die Schnittstelle stabil bleibt (und der Test weiterhin funktioniert).

== Korrektur

.src/golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(value, landscape = FALSE) {
    phi <- golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


Querformat erstellen: 
+golden_rectangle(width, landscape = TRUE)+

== Coverage der Korrektur


[source,r]
----
cov <- covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
print(cov)
----

[source,r]
----
## Coverage: 71.43%

----

[source,r]
----
## src/golden_rectangle.R: 71.43%

----

[source,r]
----
print(covr::zero_coverage(cov))
----

----
##                 filename        functions line value
## 3 src/golden_rectangle.R golden_rectangle    4     0
## 4 src/golden_rectangle.R golden_rectangle    5     0
----


== Erweiterung des Tests:


.src/test_golden_rectangle.R

[source,r]
----
testthat::test_that("Test on golden rectangle", {
                        value <- 2
                        expectation <- c(a = value * golden_ratio(), b = value)
                        result <- golden_rectangle(value)
                        testthat::expect_identical(result, expectation)
                        result <- golden_rectangle(value * golden_ratio(), landscape = TRUE)
                        testthat::expect_identical(result, expectation)
})
----


[source,r]
----
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_rectangle.R: 100.00%

----



== Skript
https://fvafrcu.gitlab.io/funktionen_in_r/[https://fvafrcu.gitlab.io/funktionen_in_r/]

https://fvafrcu.gitlab.io/funktionen_in_r/unit_testing.html[https://fvafrcu.gitlab.io/funktionen_in_r/unit_testing.html]
