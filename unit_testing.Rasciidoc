= Unit Testing in **R**
Anne-Sophie Stelzer, Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60


== Skript
https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]

https://fvafrcu.github.io/funktionen_in_r/unit_testing.html[https://fvafrcu.github.io/funktionen_in_r/unit_testing.html]



== Worum geht es?

- Was soll meine Funktion tun?
- Tut sie es auch?
- Tut sie es auch noch, wenn ich sie ver&auml;ndert/verbessert habe?

== Zwei Funktionen

- Richtige Funktion
//begin.rcode, code = readLines(file.path("src", "my_sum.R"))
//end.rcode
- Falsche Funktion
//begin.rcode, code = readLines(file.path("src", "not_my_sum.R"))
//end.rcode

== Erwartungen 
Die kleinste Testeinheit ist immer ein Vergleich. 

In base **R**:

//begin.rcode
my_sum(c(2, 7)) == 9
# better use identical(), see ?Comparison 
identical(not_my_sum(c(2, 7)), 9)
//end.rcode
 
== Pakete

- Wozu
  * Formalisieren
  * Berichten



- Pakete 
  * https://CRAN.R-project.org/package=RUnit[RUnit] gibt es schon seit 2004, es ist sehr formal
   und hat wenige Abhängigkeiten (daher bevorzuge ich es beim Testen von Paketen).
  * https://CRAN.R-project.org/package=testthat[testthat] finde ich interaktiv einfacher anzuwenden.



== Wieder Erwartungen

.https://CRAN.R-project.org/package=RUnit[RUnit]
//begin.rcode
RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
//end.rcode

.https://CRAN.R-project.org/package=testthat[testthat]
//begin.rcode, eval  = FALSE
testthat::expect_identical(not_my_sum(c(2, 7)), 9)
//end.rcode
//begin.rcode, echo  = FALSE
# testthat stop()s R, need to tryCatch
tryCatch(testthat::expect_identical(not_my_sum(c(2, 7)), 9), expectation_failure= function(cond) cat(unlist(cond)))
//end.rcode

== Tests 

Zusammenfassung mehrer Erwartungen (gew&ouml;hnlich f&uuml;r eine Funktion).

Strukturierte Berichte bei mehreren Funktionen (z.B. in Paketen).
//begin.rcode, echo = FALSE
source(file.path("src", "my_sum.R"))
source(file.path("src", "not_my_sum.R"))
//end.rcode

== Funktionen testen -- https://CRAN.R-project.org/package=testthat[testthat]
//begin.rcode, code = readLines(file.path("src", "test_my_sum.R"))
//end.rcode

== Funktionen testen -- https://CRAN.R-project.org/package=RUnit[RUnit]
//begin.rcode
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9, msg = "Not my sum")
    RUnit::checkIdentical(my_sum(c(2, 7)), 9, msg = "My sum")
}
test_sum()
//end.rcode

== Testdateien -- testthat
//begin.rcode
testthat::test_file(file.path("src", "test_my_sum.R"))
//end.rcode

== Testdateien -- RUnit
//begin.rcode
test_file <- normalizePath(file.path("src", "runit_my_sum.R"))
runit <- RUnit::runTestFile(test_file)
//end.rcode

== Testdateien -- RUnit II
//begin.rcode
RUnit::printTextProtocol(runit)
//end.rcode

== Code Coverage

- https://en.wikipedia.org/wiki/Code_coverage[Überdeckung]
- Paket https://CRAN.R-project.org/package=covr[covr]  +
  (Ich glaube: https://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria[_branch coverage_])
- Prinzipiell: Hohe Überdeckung ist gut.

== Code Coverage -- Funktionen und Tests in Dateien


.src/my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "my_sum_assertion.R")), eval = FALSE
//end.rcode


.src/test_my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "test_my_sum_assertion.R")), eval = FALSE
//end.rcode

== Code Coverage -- Dateien

//begin.rcode
cov <- covr::file_coverage(file.path("src", "my_sum_assertion.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
//end.rcode

== Code Coverage -- Ungetesteter Code

.src/my_sum_coverage.R
//begin.rcode, code = readLines(file.path("src", "my_sum_coverage.R")), eval = FALSE
//end.rcode


== Code Coverage -- Analyse

//begin.rcode
cov <- covr::file_coverage(file.path("src", "my_sum_coverage.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
print(covr::zero_coverage(cov))
//end.rcode

== Nebenwirkungen statt R&uuml;ckgabewerte testen


Fehlerhafte Löschfunktion (vergleiche  
https://fvafrcu.github.io/funktionen_in_r/#_arbeiten_mit_g%C3%BCltigkeitsbereichen):

.src/wipe_clean_broken.R
[source,r]
include::src/wipe_clean_broken.R[]

Testdatei:

.src/test_wipe_clean_broken.R
[source,r]
include::src/test_wipe_clean_broken.R[]

== Code Coverage -- Analyse Nebenwirkungen

//begin.rcode
cov <- covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                           file.path("src", "test_wipe_clean_broken.R"))
print(cov)
//end.rcode

Alles gut? +
Nein, die Funktion ist kaputt und die Testdatei, die dies zeigt müsste 
auf die Nebenwirkung testen!

== Code Coverage -- Test der Nebenwirkungen
.src/test_wipe_clean.R
[source,r]
include::src/test_wipe_clean.R[]

//begin.rcode
covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                    file.path("src", "test_wipe_clean.R"))
//end.rcode

== Was soll die ganze Testerei?

_Ich teste fast alle meine Funktion nach genau dem Ablauf in diesem Beispiel spätestens, 
wenn ich sie in ein Paket verpacke._

== https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldener Schnitt] 
//begin.rcode, echo = FALSE, results = "hide"
source(file.path("src", "wipe_clean.R"))
wipe_clean()
//end.rcode


//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_ratio_bare.R"
withr::with_dir("src", file.copy(src, "golden_ratio.R", overwrite = TRUE))
src <- "test_golden_ratio_bare.R"
withr::with_dir("src", file.copy(src, "test_golden_ratio.R", overwrite = TRUE))
//end.rcode
.src/golden_ratio.R
// WARNING: Do not use
//     [source,r]
//     include::src/golden_ratio.R[]
// here as does not evaluate _now_ whereas knitr does!
//begin.rcode, code = readLines(file.path("src", "golden_ratio.R")), eval = FALSE
//end.rcode

== https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldener Schnitt] -- Trivialer Test

.src/test_golden_ratio.R
//begin.rcode, code = readLines(file.path("src", "test_golden_ratio.R")), eval = FALSE
//end.rcode
[source,r]
//begin.rcode
covr::file_coverage(file.path("src", "golden_ratio.R"), 
                    file.path("src", "test_golden_ratio.R"))
//end.rcode

== https://de.wikipedia.org/wiki/Goldener_Schnitt#Goldenes_Rechteck_und_Goldenes_Dreieck[Goldenes Rechteck] 
//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_a.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

== https://de.wikipedia.org/wiki/Goldener_Schnitt#Goldenes_Rechteck_und_Goldenes_Dreieck[Goldenes Rechteck]  -- Test

//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_rectangle_a.R"
withr::with_dir("src", file.copy(src, "test_golden_rectangle.R", overwrite = TRUE))
//end.rcode
.src/test_golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "test_golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
covr::file_coverage(file.path("src", c("golden_ratio.R", "golden_rectangle.R")), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

== Anwendung
//begin.rcode cars, fig.show = "hide"
source(file.path("src", "golden_ratio.R"))
width <- 2
png("p1.png", units = "cm", res = 200, width = width, height = golden_rectangle(width)[["a"]])
par(mar=c(1, 1, 1, 1))
plot(cars)
dev.off()
//end.rcode

.Oh, wie schön!
image::p1.png[]
[caption=""]


== Querformat
//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_ab.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

== Anwendung
//begin.rcode
width <- 4
png("p2.png", units = "cm", res = 200, width = width, height = golden_rectangle(width)[["b"]])
par(mar=c(1, 1, 1, 1))
plot(cars)
dev.off()
//end.rcode

.Auch sehr schön!
image::p2.png[]
[caption=""]

== Herzlichen Glückwunsch!
//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Was bedeutet das?  
Du hast die Schnittstelle zerschossen und musst entweder

- *alle* Aufrufe der Funktion, die Du vor der Veränderung ihrer Schnittstelle progammiert hast, 
  anpassen (indem Du +, landscape = FALSE+ einfügst) oder
- die Funktion so ändern, dass die Schnittstelle stabil bleibt (und der Test weiterhin funktioniert).

== Korrektur
//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_ba.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

Querformat erstellen: 
+golden_rectangle(width, landscape = TRUE)+

== Coverage der Korrektur

//begin.rcode
cov <- covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
print(cov)
print(covr::zero_coverage(cov))
//end.rcode

== Erweiterung des Tests:

//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_rectangle_ba.R"
withr::with_dir("src", file.copy(src, "test_golden_rectangle.R", overwrite = TRUE))
//end.rcode
.src/test_golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "test_golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode


== Skript
https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]

https://fvafrcu.github.io/funktionen_in_r/unit_testing.html[https://fvafrcu.github.io/funktionen_in_r/unit_testing.html]
