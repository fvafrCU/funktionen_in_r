= Unit Testing in **R**
Anne-Sophie Stelzer, Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

//begin_only_slide
== Skript
https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]
//end_only_slide


//end_no_slide

== Unit Testing
Beim Unit Testing wollen wir nicht die einer Funktion übergebenen Argumente, sondern die Funktion selbst testen.
Also im Zweifel ihren Rückgabewert.

== Zwei Funktionen

- Richtige Funktion
//begin.rcode, code = readLines(file.path("src", "my_sum.R"))
//end.rcode
- Falsche Funktion
//begin.rcode, code = readLines(file.path("src", "not_my_sum.R"))
//end.rcode

== Erwartungen 
Die kleinste Testeinheit ist immer ein Vergleich. 

In base **R**:

//begin.rcode
my_sum(c(2, 7)) == 9
# better use identical(), see ?Comparison 
identical(not_my_sum(c(2, 7)), 9)
//end.rcode
 
== Pakete

- Wozu
  * Formalisieren
  * Berichten



- Pakete 
  * https://CRAN.R-project.org/package=RUnit[RUnit] gibt es schon seit 2004, es ist sehr formal
   und hat wenige Abhängigkeiten (daher bevorzuge ich es beim Testen von Paketen).
  * https://CRAN.R-project.org/package=testthat[testthat] finde ich interaktiv einfacher anzuwenden.



== Wieder Erwartungen
.https://CRAN.R-project.org/package=RUnit[RUnit]
//begin.rcode
RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
//end.rcode

.https://CRAN.R-project.org/package=testthat[testthat]
//begin.rcode, eval  = FALSE
testthat::expect_identical(not_my_sum(c(2, 7)), 9)
//end.rcode
//begin.rcode, echo  = FALSE
# testthat stop()s R, need to tryCatch
tryCatch(testthat::expect_identical(not_my_sum(c(2, 7)), 9), expectation_failure= function(cond) cat(unlist(cond)))
//end.rcode

== Tests 
Um Erwartungen bei der Paketentwicklung oder in Bezug auf ihre <<_code_coverage, Coverage>> auszuwerten,
    werden in beiden Paketen Erwartungen zu Tests zusammenfasst 
(eigentlich sollten Tests immer nur Erwartungen zu einer Funktion enthalten, aber wir wollen ja auch Fehler sehen):

//begin.rcode, echo = FALSE
source(file.path("src", "my_sum.R"))
source(file.path("src", "not_my_sum.R"))
//end.rcode

== Funktionsobjekte testen -- https://CRAN.R-project.org/package=testthat[testthat]

//begin.rcode, code = readLines(file.path("src", "test_my_sum.R"))
//end.rcode
== Funktionsobjekte testen -- https://CRAN.R-project.org/package=RUnit[RUnit]

//begin.rcode
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
    RUnit::checkIdentical(my_sum(c(2, 7)), 9)
}
test_sum()
//end.rcode

== Funktionsdateien testen -- testthat


[small]
//begin.rcode
testthat::test_file(file.path("src", "test_my_sum.R"))
//end.rcode

== Funktionsdateien testen -- RUnit
//begin.rcode
test_file <- normalizePath(file.path("src", "runit_my_sum.R"))
runit <- RUnit::runTestFile(test_file)
RUnit::printTextProtocol(runit)
//end.rcode

== Code Coverage
Um zu sehen, ob Deine Unit Tests die Funktion gut testen, 
kannst Du ihre  https://en.wikipedia.org/wiki/Code_coverage[Überdeckung] berechnen.
https://CRAN.R-project.org/package=covr[covr] ist eines der Pakete, die Code Coverage implentieren und das einzige, das ich nutze. Ich weiß es nicht, glaube aber, dass https://CRAN.R-project.org/package=covr[covr] die https://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria[_branch coverage_]
berechnet. 
Prinzipiell ist eine hohe Überdeckung gut.

Wenn Du eine Datei mit einer Funktionsdefinition

.src/my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "my_sum_assertion.R")), eval = FALSE
//end.rcode

und eine mit dem Test

.src/test_my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "test_my_sum_assertion.R")), eval = FALSE
//end.rcode

hast, kannst Du die Überdeckung berechnen.

//begin.rcode
cov <- covr::file_coverage(file.path("src", "my_sum_assertion.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
//end.rcode

Wenn Du eine Funktion schreibst, in der eine Zeile eingebaut ist, die der Test nicht
erreicht, weist Dich https://CRAN.R-project.org/package=covr[covr] darauf hin:

.src/my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "my_sum_coverage.R")), eval = FALSE
//end.rcode

//begin.rcode
cov <- covr::file_coverage(file.path("src", "my_sum_coverage.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
//end.rcode

https://CRAN.R-project.org/package=covr[covr] sagt Dir sogar, dass es die dritte Zeile ist:
//begin.rcode
covr::zero_coverage(cov)
//end.rcode

== Nebenwirkungen testen

Funktionen sind relativ einfach zu testen, wenn ihr Rückgabewert ihr Zweck ist.
Wenn sie aber Nebenwirkungen bezwecken, finde ich Tests schwieriger zu schreiben.

Stell Dir vor, Du hättest die fehlerhafte Löschfunktion aus 
<<_arbeiten_mit_gültigkeitsbereichen, Arbeiten mit Gültigkeitsbereichen>> 
in eine Datei geschrieben:

.src/wipe_clean_broken.R
[source,r]
include::src/wipe_clean_broken.R[]

Nun schreibst Du eine Testdatei:

.src/test_wipe_clean_broken.R
[source,r]
include::src/test_wipe_clean_broken.R[]

Und erhälst vollständige Überdeckung:

//begin.rcode
cov <- covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                           file.path("src", "test_wipe_clean_broken.R"))
print(cov)
//end.rcode

Alles gut? Nein, die Funktion ist kaputt und die Testdatei, die dies zeigt müsste 
auf die Nebenwirkung testen:

.src/test_wipe_clean.R
[source,r]
include::src/test_wipe_clean.R[]

//begin.rcode
covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                    file.path("src", "test_wipe_clean.R"))
//end.rcode

== Was soll die ganze Testerei?
//begin.rcode, echo = FALSE, results = "hide"
source(file.path("src", "wipe_clean.R"))
wipe_clean()
//end.rcode

Stell Dir vor, Du erstelltest öfter Abbildungen. 
Jetzt bist Du ein Mensch mit einem Gefühl für Harmonien,
daher willst Du gerne, wenn möglich, den 
https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldenen Schnitt] bei der 
Wahl der Zuschnitte berücksichtigen.

Da Du Dir den Goldenen Schnitt nicht gut merken kannst, schreibst Du folgende Funktion:

//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_ratio_bare.R"
withr::with_dir("src", file.copy(src, "golden_ratio.R", overwrite = TRUE))
src <- "test_golden_ratio_bare.R"
withr::with_dir("src", file.copy(src, "test_golden_ratio.R", overwrite = TRUE))
//end.rcode
.src/golden_ratio.R
// WARNING: Do not use
//     [source,r]
//     include::src/golden_ratio.R[]
// here as does not evaluate _now_ whereas knitr does!
//begin.rcode, code = readLines(file.path("src", "golden_ratio.R")), eval = FALSE
//end.rcode

Das ginge auch als Einzeiler: 
//begin.rcode, eval = FALSE
golden_ratio  <- function() return((1 + sqrt(5)) / 2)  
//end.rcode
aber den findest Du auch nicht viel eleganter, dafür aber schlechter lesbar.

Du schreibst auch einen Test, obwohl der ziemlich trivial ist:

.src/test_golden_ratio.R
//begin.rcode, code = readLines(file.path("src", "test_golden_ratio.R")), eval = FALSE
//end.rcode
[source,r]
//begin.rcode
covr::file_coverage(file.path("src", "golden_ratio.R"), 
                    file.path("src", "test_golden_ratio.R"))
//end.rcode

Wenn Du Graphiken nach dem Goldenen Schnitt proportionieren willst, musst Du bei 
gegebener Länge der kurzen Seite diese mit dem Goldenen Schnitt multipizieren 
um die Länge der langen Seite zu erhalten. 

Das ist eigentlich nicht allzu kompliziert, dennoch kommst Du manchmal durcheinander, 
also schreibst Du die folgende Funktion:
//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_a.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

Auch für diese Funktion schreibst Du einen Test:

//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_rectangle_a.R"
withr::with_dir("src", file.copy(src, "test_golden_rectangle.R", overwrite = TRUE))
//end.rcode
.src/test_golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "test_golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
covr::file_coverage(file.path("src", c("golden_ratio.R", "golden_rectangle.R")), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Du benutzt die Funtktion ...

//begin.rcode cars, fig.show = "hide"
source(file.path("src", "golden_ratio.R"))
width <- 2
png("p1.png", units = "cm", res = 400,
    width = width, 
    height = golden_rectangle(width)[["a"]])
par(mar=c(1,1,1,1))
plot(cars)
dev.off()
//end.rcode

 und bist begeistert:

.Oh, wie schön!
image::p1.png[]
[caption=""]


Du benutzt die Funktion eine Weile weiter, merkst dann aber, dass Du ja auch querformatige
Abbildungen erstellen willst und daher 
bei gegebener Länge der 
langen Seite diese durch den Goldenen Schnitt dividieren musst, um die Länge 
der kurzen Seite zu erhalten.

Jetzt kannst Du entweder eine neue Funktion schreiben oder die alte erweitern.
Da die Funktionalitäten zum selben Thema passen und +golden_rectangle+ bislang
recht simpel ist, schreibst Du Deine Funktion also um:

//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_ab.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
width <- 4
png("p2.png", units = "cm", res = 400,
    width = width, 
    height = golden_rectangle(width)[["b"]])
par(mar=c(1,1,1,1))
plot(cars)
dev.off()
//end.rcode

.Auch sehr schön!
image::p2.png[]
[caption=""]

Herzlichen Glückwunsch, Du hast gerade die https://en.wikipedia.org/wiki/Application_programming_interface[Schnittstelle] Deiner Funktion zerschossen, indem Du ihr voreingestelltes Verhalten geändert hast. 
Glücklicherweise hast Du einen Test, der Dir jetzt um die Ohren fliegt:

//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Was bedeutet das? 
Du musst entweder

- *alle* Aufrufe der Funktion, die Du vor der Veränderung ihrer Schnittstelle progammiert hast, 
  anpassen (indem Du +, landscape = FALSE+ einfügst) oder
- die Funktion so ändern, dass der Test weiterhin funktioniert.

Du entscheidest Dich, die Funktion zu ändern 
(und erweiterst bei der Gelegenheit gleich den Rückgabewert):


//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_ba.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

Um Querformatige Proportionen zu erhalten musst Du nun aktiv Querformat einstellen:
+golden_rectangle(width, landscape = TRUE)+

Der Test funktioniert wieder, da Du aber die Funktion geändert hast, überdeckt
er sie nicht mehr vollständig:

//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Du erweiterst also Deine Testdatei an:

//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_rectangle_ba.R"
withr::with_dir("src", file.copy(src, "test_golden_rectangle.R", overwrite = TRUE))
//end.rcode
.src/test_golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

+golden_rectangle+ habe ich mir nur ausgedacht, um Dir mein Vorgehen zu verdeutlichen. Aber:

_Ich teste fast alle meine Funktion nach genau dem Ablauf in diesem Abschnitt spätestens, 
wenn ich sie in ein Paket verpacke._
