= Funktionen Schreiben in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:numbered:
:data-uri:
:duration: 120

// //begin_only_slide
// == Skript
// https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]
// //end_only_slide

== Worum geht es?

Naja, ums Schreiben von Funktionen in der Programmiersprache **R**.



=== Was sind Funktionen?

* Funktionen sind Programmkonstrukte, mit denen Du Teile des von Dir 
  geschriebenen Codes wiederverwenden kannst
  (siehe https://de.wikipedia.org/wiki/Funktion_(Programmierung)[Wikipedia]).
* Funktionen sind in den Standardbiliotheken jeder Programmiersprache vorhanden, 
  viele R-Funktionen kennst Du wahrscheinlich schon: `sum()`, `mean()` 
  oder `summary()`.

=== Warum Funktionen?

* Damit Du Teile des von Dir geschriebenen Codes wiederverwenden kannst.
* Damit Du, wenn Du Fehler im Code entdeckst, diese auch nur an einer 
  Stelle korrigieren musst.

=== Wann Funktionen?

Immer wenn Du merkst, dass Du (alten) Code mehrfach kopierst und an anderer
Stelle einfügst ohne ihn stark zu verändern, solltest Du darüber nachdenken, 
eine (oder mehrere) Funktion(en)  aus ihm  zu machen. 


== Eine Funktion schreiben
=== Eine neue Summenfunktion

.Warum wir diese Funktion nicht schreiben sollten

Eine Summenfunktion gibt es wahrscheinlich in jeder Programmiersprache, in **R**
heißt sie `sum()`. Diese Funktion ist besser, stabiler und schneller, als
alles, das wir selbst programmieren können.

.Warum wir es trotzdem tun

Nunja, irgendwelchen Code müssen wir ja nehmen.  
Ich habe die Summenberechnung ausführlich als Beispiel zur Schleifenprogrammierung in 
https://fvafrcu.github.io/programmieren_in_r/#gute-schleifen[Programmieren in R] benutzt, 
    und eine Wiederholung schadet sicher nicht.


=== Vom Code ... 
//begin.rcode, code = readLines("src/sum.R")
//end.rcode

Dabei siehst Du:

<1> Definition des zu summierenden Vektors
<2> Definition des zur Addition neutralen Elementes
<3> Schleife über die Elemente des Vektors
<4> Addition des aktuellen Vektorelementes zum Ergebnis
<5> Ausgabe des Ergebnisses

=== ... zur Funktion 

Für unsere Summenfunktion soll die Definition des zu summierenden Vektors
der Anwenderin überlassen werden, daher wird der Vektor zu einem Argument
der Funktion. Ich wähle als Namen für das Argument jetzt +x+, das könnte aber
auch +a+ bleiben, es ist eine Frage der Konvention, und unter +x+ verstehen wir
meist eine Unbekannte. Und als Ausgabe verwenden wir keine Druck- sondern eine
Rückgabefunktion (+return()+ statt +print()+). 
Das Ergebnis sieht dann so aus:




//begin.rcode, code = readLines("src/my_sum.R")
//end.rcode


=== Scoping 
Programmiersprachen kennen für Objekte unterschiedliche Gültigkeitsbereiche 
(englisch "scope"), wir sehen uns das am Beispiel an:
==== Schreibzugriffe
.Ausgangszustand
Im Augenblick hat das Objekte +value+ den Wert +r value+:

//begin.rcode
print(value)
//end.rcode

.Funktionsausführung
Jetzt wenden wir unsere Summenfunktion an und berechnen die Summe eines anderen Vektors: 
//begin.rcode
print(my_sum(1:3))
//end.rcode

Das Objekt `value` behält seinen Wert:
//begin.rcode
print(value)
//end.rcode
Und das, obwohl wir innerhalb der Funktion dem Objekt +value+ in der ersten
Zeile den Wert 0 zuweisen und diesen dann in der Schleife mit den Werten 1, 3
und 6 überschreiben:
**R** verwaltet automatisch die Gültigkeitsbereiche aller Objekte. 
Es gibt daher ein Objekt names  +value+ außerhalb der Funktion, das den Wert +r value+ enthält und unverändert bleibt.
Innerhalb der Funktion legt **R** ein neues lokales Objekt, ebenfalls mit dem Namen
+value+, an.
Du _kannst_ auch aus einer Funktion in einen <<_arbeiten_mit_gültigkeitsbereichen, anderen Gültigkeitsbereich>> schreiben, wenn Du das wirklich willst.


==== Lesezugriffe
.Lesen ist unsicher
Mit dem Namen eines Objektes wird dieses gelesen, innerhalb einer Funktion sucht
**R** zunächst nach einem lokalen Objekt des gesuchten Namens, dann in den der
Funktion übergeordneten Gültigkeitsbereichen, also außerhalb der Funktion.

Das kann zu unerwünschten Nebeneffekten führen. Stell Dir vor, Du kommentierst 
beim Schreiben der Summenfunktion die Definition des zur Addition neutralen
Elementes aus Versehen aus:
//begin.rcode, code = readLines("src/my_sum_scope_broken.R")
//end.rcode

Du führst die Funktion aus und erhälst:
//begin.rcode
print(my_sum_broken(1:3))
//end.rcode
Was ist passiert?
Im ersten Durchlauf der Schleife gibt es beim Lesen von
+value+ noch kein lokales Objekt dieses Namens. Daher sucht **R** außerhalb der
Funktion und findet ein Objekt mit dem Wert +r value+. 
Zu diesem Objekt addieren
wir +x_i+, das im ersten Schleifendurchlauf den Wert +1+ enthält und erschaffen
damit in der Funktion ein lokales Objekt names +value+, das dann im zweiten
Durchlauf der Schleife auch gelesen werden kann.

Wenn Du diese Funktion verwendest, ohne vorher das Objekt +value+ zu definieren,
oder das Objekt +value+ entfernst und dann die Funktion ausführst
//begin.rcode
rm(value)
print(my_sum_broken(1:3))
//end.rcode
erhälst Du einen Fehler, weil **R** auch außerhalb der Funktion kein Objekt
names +value+ finden kann. Und diesen Fehler erwarten wir ja eigentlich, wenn 
wir nur die Funktion betrachten: sie ist fehlerhaft.

.Sicherer Lesen
Wie wir eine Funktion dazu bringen können, außerhalb ihres Gültigkeitsbereiches
zu schreiben (nein, das _wie_ habe ich Dir noch nicht gezeigt... ), so können wir 
eine Funktion auch zwingen, beim Lesen nur nach lokalen Objekten zu
suchen:
//begin.rcode, code = readLines("src/my_sum_get_safe.R")
//end.rcode

Selbst wenn wir ein Objekt namens +value+ anlegen, gibt die Funktion nun einen
Fehler aus:
//begin.rcode
value <- 42
my_sum_safer(1:10)
//end.rcode
Ich finde es aber praktiabler, beim Schreiben einer Funktion darauf zu achten,
welche Objekte ich lese. + 
Und wenn Du Funktionen <<_funktionen_testen,testest>>, findest Du Fehler, die auf Scoping beruhen,
sehr schnell. 


==== Arbeiten mit Gültigkeitsbereichen 

Ein Befehl, mit dem Du alle Objekte Deines aktuellen Arbeitsbereiches löschen
kannst (entsprechend dem RStudio-Knopf mit dem Besensymbol footnote:[Im https://github.com/rstudio/rstudio/releases/tag/v1.1.426[Code von RStudio v1.1.426] findet sich die Funktion hinter dem Knopf  in der Datei src/cpp/session/modules/SessionEnvironment.R, sie besteht im wesentlichen aus der Zeile +
rm(list=ls(envir=env, all.names=includeHidden), envir=env) +
Sie wird in src/cpp/session/modules/environment/SessionEnvironment.cpp in der C++-Funktion  removeAllObjects aufgerufen.
]) lautet:

//begin.rcode, eval = FALSE
rm(list = ls(all.names = TRUE))
//end.rcode
Nun  bin ich
vergesslich, weshalb ich mir die Syntax schlecht merken kann und lieber eine
Funktion (aber keinen Knopf) hätte.
Da "der aktuelle Arbeitsbereich" ein Gültigkeitsbereich 
(in **R** heissen die Gültigkeitsbereiche "environments", in **S** hießen sie "frames") ist, und die 
Funktionen  `ls` und `rm` nur in _einem_ Gültigkeitsbereich arbeiten, funktioniert das naheliegende
//begin.rcode, eval = FALSE
wipe_clean <- function() {
    rm(list = ls(all.names = TRUE))
}
//end.rcode 
*nicht*.

Wenn ich den Gültigkeitsbereich explizit 
//begin.rcode
wipe_clean <- function() {
    rm(list = ls(name = parent.frame(), all.names = TRUE), envir = parent.frame())
}
//end.rcode 
angebe, tut die Funktion, was ich wollte:
//begin.rcode
ls()
wipe_clean()
ls()
//end.rcode 




=== Argumente

Funktionen kennen Argmumente, am besten nicht zu viele (siehe zum Beispiel <<cc>>). 
Unsere Summenfunktion kennt beispielsweise eines, nämlich den Vektor, den sie summieren soll. Der ist also ein obligatorisches Element, er sollte keine Voreinstellung haben (und hat auch keine).


Eine Funktion, die, wie `wipe_clean`, kein Argument kennt, ist Folgende:


//begin.rcode, code = readLines("src/memhogs.R")
//end.rcode

Diese Funktion gibt mir für jedes Objekt des Gültigkeitsbereiches, in dem ich sie aufrufe, den Speicherverbrauch aus.

//begin.rcode
va <- rep(mtcars, 1)
vb <- rep(mtcars, 1000)
vc <- rep(mtcars, 2000)
vd <- rep(mtcars, 100)
memory_hogs()
//end.rcode

Bei so wenigen Objekten erkenne ich leicht, dass `vc` der größte Speicherfresser ist, und ich, falls mir der Speicher platzt und ich `vc` nicht mehr unbedingt brauche, `vc` löschen sollte.

Aber wenn ich viele Objekte habe, wäre es doch schön, ein optionales Funktionsargument zu haben, dass in seiner Voreinstellung die Ausgabe nach Größe des Speicherbedarfs sortiert:

//begin.rcode, code = readLines("src/memhogs_arg.R")
//end.rcode

//begin.rcode
memory_hogs()
//end.rcode

Das ist ein klassisches (optionales) Steuerargument, das das Verhalten einer Funktion steuert.
Steuerargumente sollten eine sinnvolle Voreinstellung haben.

Da die `memory_hogs` intern nun die Funktion `order` aufruft, könnten wir ja auf die Idee kommen, dieser Funktion Argumente weiterreichen zu wollen. 
Das können wir entweder explizit tun, oder wir benutzen ein spezielles, _Ellipsis_ genanntes Argument, das durch drei Punkte (`...`) aufgerufen wird:

//begin.rcode, code = readLines("src/memhogs_ellipsis.R")
//end.rcode

//begin.rcode
memory_hogs()
memory_hogs(decreasing = TRUE)
//end.rcode

Jetzt können wir die Rückgabe unserer Funktion nutzen, um die beiden größten Speicherfresser zu löschen:

//begin.rcode
rm(list = names(memory_hogs(decreasing = TRUE)[1:2]))
memory_hogs()
//end.rcode

Wir können also, wenn wir wollen, drei Arten von Argumenten unterscheiden:

- Obligatorische. Sie sollten keine Voreinstellungen kennen und übergeben üblicherweise Objekte, die von der Funktion verarbeitet werden sollen.
- Optionale. Sie sollten Voreinstellungen kennen und dienen üblicherweise der Steuerung der Funktion.
- Die _Ellipsis_, um Argumente an andere Funktionen weiterzureichen.

=== Return Value und Side Effects
Jede Funktion in **R** gibt einen Wert zurück, falls sie nicht mit einem Fehler abbricht.
Wenn wir keinen Rückgabewert (return value) explizit angeben, ist er automatisch der Wert des letzten in der Funktion ausgewerteten Ausdrucks, also der letzte Wert, der wie auch immer berechnet oder zurückgegeben wurde.
Es ist daher sicher nicht schlecht, wenn Du versucht, den Rückgabewert explizit anzugeben.
Unsere Summenfunktion könnte auch so aussehen:

//begin.rcode
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
}
//end.rcode

Das ist zwar (um eine Zeile) kürzer und inhaltsgleich, aber weniger offentsichtlich. Und damit weniger gut lesbar.
Und damit mehr schlechter als eine Zeile kürzer mehr besser ist, capisce?

Komplexere Funktionen haben oft Nebenwirkungen (side effects)
Bei vielen dieser Funktionen sind die Nebenwirkungen der eigentliche Zweck der Funktion, manchmal ist Rückgabewert sogar belanglos. Die Funktion `rm` gibt beispielsweise unsichtbar `NULL` zurück (und das selbst dann, wenn es gar nichts zu löschen gibt), das erkennen wir, wenn wir ihren Röckgabewert explizit drucken:
//begin.rcode
a <- "This is a string"
print(rm(a))
print(rm())
//end.rcode

Das heißt also, dass unsere Funktion `wipe_clean` den Wert `invisible(NULL)`, zurückgibt, denn das war der Wert des letzten in ihr ausgewerteten Ausdrucks (der Aufruf der Funktion `rm`).

Das können wir ändern, indem wir einen expliziten Rückgabewert einbauen (bei der Gelegenheit wandeln wir gleich noch den Gütigkeitsbereich, indem die Funktion läscht, in ein Steuerargument mit Voreinstellung um):

//begin.rcode, code = grep("#'", readLines("src/wipe_clean.R"), value = TRUE, invert = TRUE)
//end.rcode
//begin.rcode
print(wipe_clean())
ls()
//end.rcode
Jetzt gibt die Funktion die Namen der von ihr gelöschten Objekte zurück. Wir wissen also, wie hieß, was wir gelöscht haben. Damit können wir zwar nichts mehr anfangen, aber die Funktion hat nun genau einen expliziten Endpunkt. Das ist immerhin schön übersichtlich.


=== Funktionen verwalten

==== Lokal
Mit source

====  Global 
Mit .Rprofile und einer Schleife

==== Als Package
Das ist am aufwendigsten, aber auch am elegantesten.


== Weniger schlecht programmieren

=== Argumententests
Wir haben verschiedene Möglichkeiten, die Objekte, die wir den Argumenten einer Funktion übergeben, zu testen.


==== Typentests

Wir können Objekte darauf testen, ob sie einem bestimmten Typ (einer Klasse) angehören; 
bei Objekten, die einer Funktion als Argument übergeben werden ist dies besonders ratsam.
Das geht mir reinen +base R+, ist aber eher umständlich,
die https://cran.r-project.org/web/packages/checkmate/vignettes/checkmate.html#intro[Vignette zu +checkmate+] 
bietet ein anschauliches Bespiel.

Ich kenne zwei Packages, die Typentest vereinfachen: +assertthat+ und +checkmate+.

- +checkmate+ ist hauptsächlich in C geschrieben, sehr schnell, 
sehr flexibel mit unterschiedlichen Testarten ("checks", "asserts" und "tests"), 
hat aber viele Abhängigkeiten und ist etwas sperrig: sein Manual ist über 100 Seiten lang. 
- +assertthat+ ist reines R ohne irgendwelche Abhängigkeiten und recht übersichtlich.

+assertthat+ ist sehr einfach:
//begin.rcode
x <- 6
assertthat::assert_that(is.numeric(x))
//end.rcode
//begin.rcode
x <- "This is a string."
assertthat::assert_that(is.numeric(x))
//end.rcode

.Was haben wir davon?
Wenn wir unserer Summenfunktion 

//begin.rcode, code = readLines("src/my_sum.R")
//end.rcode

ein nicht-numerisches Argument übergeben, erhalten wir eine recht kryptische Fehlermeldung:

//begin.rcode
my_sum(c("a", "b"))
//end.rcode


Durch den Einbau eines Typentests 

//begin.rcode, code = readLines("src/my_sum_assertion.R")
//end.rcode
wird die Meldung deutlich verständlicher:
//begin.rcode
my_sum(c("a", "b"))
//end.rcode

Mit +checkmate+ können wir sogar erzwingen, dass x nicht nur numerisch sein muss,
sondern auch mindestens zwei Elemente haben soll. Eine Summe einer Zahl ist ja etwas albern:
//begin.rcode, code = readLines("src/my_sum_checkmate.R")
//end.rcode

//begin.rcode
my_sum(42)
//end.rcode

_Ich nutze Typentests oft in Funktionen. Da +checkmate+ deutlich mehr Funktionalität bietet, nutzte ich +assert_that+ eher selten._

==== Auswahllisten
Mit Auswahllisten können wir Objekte darauf testen, ob sie eine von mehreren Möglichkeiten
enthalten. Das ist vor allem für Steuerargumente hilfreich.
+base R+ kennt +match.arg+, das mit alphanumerischen Vektoren arbeitet und einfach das Objekt zurückgibt, wenn
es in der Auswahlliste enthalten ist:
//begin.rcode
noten <-  c("sehr gut", "gut", "nicht soo gut", "das kann auf jeden Fall noch besser werden")
note  <- "gut"
match.arg(arg = note, choices = noten)
//end.rcode
Dabei bedient es sich dem "partial matching", das heißt, dass ein eindeutig einer Auswahlmöglichkeit zuzuordnender Anfang einer Zeichenkette ausreicht:
//begin.rcode
note  <- "das"
match.arg(arg = note, choices = noten)
//end.rcode

Wird kein Treffer in der Auswahlliste gefunden, erhalten wir einen Fehler:
//begin.rcode
note  <- "ausreichend"
match.arg(arg = note, choices = noten)
//end.rcode

+match.arg+ ist genau, was hinter Steuerargumenten vieler Funktionen (z.b.  +mgcv::gam(optimizer = ...)+) steckt, hier ein Beispiel aus der Hilfe zu +match.arg+:
//begin.rcode
center <- function(x, type = c("mean", "median", "trimmed")) {
    type <- match.arg(type)
    switch(type,
           mean = mean(x),
           median = median(x),
           trimmed = mean(x, trim = .1))
}
center(rnorm(100), "med")
center(rnorm(100), "m")
//end.rcode


+checkmate+ kennt auch Auswahllisten, macht aber kein +partial matching+ (was ich ganz gut finde):
//begin.rcode
note  <- "das"
checkmate::assertChoice(x = note, choices = noten)
//end.rcode

Außerdem gibt +checkmate+ die gefundene Rückgabe unsichtbar zurück, weshalb ich hier ein explizites +print+ benötige:
//begin.rcode
note  <- "gut"
checkmate::assertChoice(x = note, choices = noten)
print(checkmate::assertChoice(x = note, choices = noten))
//end.rcode

+checkmate+ kann nicht nur mit alphanumerischen Vektoren umgehen:
//begin.rcode
x <- 3
choices <- 1:7
print(checkmate::assertChoice(x = x, choices = choices))
//end.rcode


_Ich nutze Auswahllisten eher selten, da ich selten Steuerargumente mit mehreren Auswahlmöglichenkeiten in meinen Funktionen habe._

=== Funktionen testen
==== Unit Testing
Beim Unit Testing wollen wir nicht die einer Funktion übergebenen Argumente, sondern die Funktion selbst testen.
Also im Zweifel ihren Rückgabewert.

Ich kenne zwei Packages, die Unit Testing in R formalisieren 
(im Prinzip geht es auch ohne spezielle Packages, 
 aber seit ich die beiden Packages kenne, 
 habe ich nie mehr wie früher "von Hand" getestet):

- +RUnit+ gibt es schon seit 2004, es ist sehr formal
 und hat wenige Abhängigkeiten (daher bevorzuge ich es).
- +testthat+ finde ich interaktiv einfacher anzuwenden.

===== Erwartungen 
Die kleinste Testeinheit ist immer ein Vergleich. 

Wenn wir die Funktionen 

//begin.rcode, code = readLines("src/my_sum.R")
//end.rcode
 und 
//begin.rcode, code = readLines("src/not_my_sum.R")
//end.rcode
haben, k&ouml;nnen wir zum Beispiel mit +base R+ prüfen, ob sie tun, was wir erwarten:

//begin.rcode
my_sum(c(2, 7)) == 9
# better use identical(), see ?Comparison 
identical(not_my_sum(c(2, 7)), 9)
//end.rcode

Beide Packages formalisieren dies zu Erwartungsfunktionen die haupts&auml;chliche dazu dienen, 
Fehler zu beschreiben:

.+RUnit+
//begin.rcode
RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
//end.rcode

.+testthat+
//begin.rcode, eval  = FALSE
testthat::expect_identical(not_my_sum(c(2, 7)), 9)
//end.rcode
//begin.rcode, echo  = FALSE
# testthat stop()s R, need to tryCatch
tryCatch(testthat::expect_identical(not_my_sum(c(2, 7)), 9), expectation_failure= function(cond) cat(unlist(cond)))
//end.rcode

===== Tests 
Um Erwartungen bei der Paketentwicklung oder in Bezug auf ihre <<_code_coverage, Coverage>> auszuwerten,
    werden in beiden Packages Erwartungen zu Tests zusammenfasst 
(eigentlich sollten Tests immer nur Erwartungen zu einer Funktion enthalten, aber wir wollen ja auch Fehler sehen):

.+testthat+
//begin.rcode
testthat::test_that("Simple test on summation.", {
                        testthat::expect_identical(not_my_sum(c(2, 7)), 9)
                        testthat::expect_identical(my_sum(c(2, 7)), 9)}
)
//end.rcode

.+RUnit+
+RUnit+ wurde f&uuml;r das Testen von Packages entwickelt, es ist beim einfachen
//begin.rcode
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
    RUnit::checkIdentical(my_sum(c(2, 7)), 9)
}
test_sum()
//end.rcode
recht spr&ouml;de. Das Package erwartet eine Testdatei 


.src/runit_my_sum.R
[source,r]
include::src/runit_my_sum.R[]

und wird dann gespr&auml;chiger:

//begin.rcode
source(file.path("src", "my_sum.R"))
source(file.path("src", "not_my_sum.R"))
test_file <- normalizePath(file.path("src", "runit_my_sum.R"))
runit <- RUnit::runTestFile(test_file)
RUnit::printTextProtocol(runit)
//end.rcode

==== Code Coverage
Um zu sehen, ob Deine Unit Tests die Funktion gut testen, kannst Du ihre  (https://en.wikipedia.org/wiki/Code_coverage[&Uuml;berdeckung]) berechnen.
+covr+ ist eines der Packages, die Code Coverage implentieren und das einzige, das ich nutze. Ich wei&szlig; es nicht, glaube aber, dass +covr+ die https://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria[_branch coverage_]
berechnet. 
Prinzipiell ist eine hohe &Uuml;berdeckung gut.

Wenn Du eine Datei mit einer Funktionsdefinition

.src/my_sum_assertion.R
[source,r]
include::src/my_sum_assertion.R[]

und eine mit dem Test

.src/test_my_sum_assertion.R
[source,r]
include::src/test_my_sum_assertion.R[]

hast, kannst Du die &Uuml;berdeckung berechnen.

//begin.rcode
cov <- covr::file_coverage("src/my_sum_assertion.R", "src/test_my_sum_assertion.R")
print(cov)
//end.rcode

Wenn Du eine Funktion schreibst, in der eine Zeile eingebaut ist, die der Test nicht
erreicht, weist Dich +covr+ darauf hin:

.src/my_sum_assertion.R
[source,r]
include::src/my_sum_coverage.R[]

//begin.rcode
cov <- covr::file_coverage("src/my_sum_coverage.R", "src/test_my_sum_assertion.R")
print(cov)
//end.rcode

+covr+ sagt Dir sogar, dass es die dritte Zeile ist:
//begin.rcode
covr::zero_coverage(cov)
//end.rcode

===== Nebenwirkungen testen

Funktionen sind relativ einfach zu testen, wenn ihr R&uuml;ckgabewert ihr Zweck ist.
Wenn sie aber Nebenwirkungen bezwecken, finde ich Tests schwieriger zu schreiben.

Stell Dir vor, Du h&auml;ttest die fehlerhafte L&ouml;schfunktion aus 
<<_arbeiten_mit_gültigkeitsbereichen, Arbeiten mit Gültigkeitsbereichen>> 
in eine Datei geschrieben:

.src/wipe_clean_broken.R
[source,r]
include::src/wipe_clean_broken.R[]

Nun schreibst Du eine Testdatei:

.src/test_wipe_clean_broken.R
[source,r]
include::src/test_wipe_clean_broken.R[]

Und erh&auml;lst vollst&auml;ndige &Uuml;berdeckung:

//begin.rcode
cov <- covr::file_coverage("src/wipe_clean_broken.R", "src/test_wipe_clean_broken.R")
print(cov)
//end.rcode

Alles gut? Nein, die Funktion ist kaputt, und die Testdatei, die dies zeigt m&uuml;sste 
auf die Nebenwirkung testen:

.src/test_wipe_clean.R
[source,r]
include::src/test_wipe_clean.R[]

//begin.rcode
covr::file_coverage("src/wipe_clean_broken.R", "src/test_wipe_clean.R")
//end.rcode

==== Was soll die ganze Testerei?
//begin.rcode, echo = FALSE, results = "hide"
source("src/wipe_clean.R")
wipe_clean()
//end.rcode

Ich habe einmal die Funktion

//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_ratio2.R"
withr::with_dir("src", file.copy(src, "golden_ratio.R", overwrite = TRUE))
source("src/golden_ratio.R")
//end.rcode
.src/golden_ratio.R
[source,r]
include::src/golden_ratio.R[]


geschrieben, die mir den https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldenen Schnitt] anwendet:
//begin.rcode
golden_ratio(6)
golden_ratio(6, "b")
//end.rcode


Und ich habe auch einen Test geschrieben:
//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_ratio2.R"
withr::with_dir("src", file.copy(src, "test_golden_ratio.R", overwrite = TRUE))
//end.rcode
.src/test_golden_ratio2.R
[source,r]
include::src/test_golden_ratio2.R[]

//begin.rcode
covr::file_coverage(file.path("src", "golden_ratio.R"), 
                    file.path("src", "test_golden_ratio.R"))
//end.rcode

// //begin.rcode, echo = FALSE, results = "hide"
// withr::with_dir("src", file.copy("test_memhogs_ordered.R", "test_memory_hogs.R", overwrite = TRUE))
// //end.rcode
// 
// .src/tst_memory_hogs.R
// [source,r]
// include::src/test_memory_hogs.R[]
// 
// //begin.rcode
// source("src/memory_hogs.R")
// test_file <- normalizePath(file.path("src", "test_memhogs_ordered.R"))
// runit <- RUnit::runTestFile(test_file)
// RUnit::printTextProtocol(runit)
// covr::file_coverage("src/memory_hogs.R", "src/test_memhogs_ordered.R")
// //end.rcode
// 
// Dann merkte ich, dass ich bei vielen Objekten im Speicher nach oben scrollen muss, um die Namen der gro&szlig;en Objekte zu sehen:
// //begin.rcode
// for (i in 1:100) {
//     assign(paste0("what_a_long_name_cluttering_my_screen_", i), rep(mtcars, i))
// }
// memory_hogs()
// //end.rcode
// 
// 
// 
// 
// die Ausgabe gerne genau _umgekehrt_ sortiert h&auml;tte, dann m&uuml;sste ich nicht nach oben scrollen, um 
// 



_Ich teste fast alle meine Funktion spätestens, wenn ich sie in ein Package verpacke._

=== Schöner Programmieren
Ich möchte Dir gerne noch drei Funktionen aus drei verschiedenen Packages vorstellen, 
die Dir helfen können, gut lesbare Funktionen zu schreiben. _Ich nutze alle drei standardmäßig bei der Entwicklung von Packages._
Aber vorweg stelle ich Dir noch +codetools+ vor, es gehört zur Gruppe der _recommended_ Packages von **R** und kann Programmfehler finden, die drei anderen Packages gibt es nur, weil +codetools+ schon da war.

Stell Dir vor, Du hättest in der Datei "src/code.R" folgende unschöne 
und kaputte Funktion geschrieben:

//begin.rcode, code = readLines("src/code.R"), eval = FALSE
//end.rcode

==== Code prüfen mit Codetools 
In Deiner Funktion findet +codetools+ die nicht benutzten Funktionsargumente und das nicht definierte Objekt +this_is_not_defined+:

//begin.rcode
source("src/code.R")
codetools::checkUsage(foo, all = TRUE)
//end.rcode

==== Entflusen mit lintr 

Das Package `lintr` prüft Code auf Fussel, das sind Abweichungen des Codes von Richtlinien 
zur übersichtlichen Formatierung. 
Die Richtlinien (gegen die `lintr` prüft, und die sind gut, halte Dich an sie;
                 zu mehr über Progammierrichtlinien findest Du im https://fvafrcu.github.io/programmierleitfaden.ps[Programmierleitfaden an der Forstlichen Versuchs- und Forschungsanstalt Baden-Württemberg]) 
sehen unter anderem vor, 
dass auf Kommas immer ein Leerzeichen folgen sollte, 
dass auf öffnende geschweifte Klammern immer ein Zeilenumbruch folgen sollte und 
dass eine Datei keine Leerzeilen am Ende enthalten sollte:

//begin.rcode
lintr::lint("src/code.R")
//end.rcode

Das Package kennt viele Optionen, lies Dir die Hilfe durch!

==== Code säubern mit cleanr 
Das Package `cleanr` prüft die Länge und (Zeilen-) Breite von Funktionen und Codedateien und
die Verschachtelungstiefe von Funktionen, ihre Argumentenanzahl und ob sie einen expliziten
Rückgabewert haben.
//begin.rcode
print(suppressWarnings(cleanr::check_file("src/code.R")))
//end.rcode


Auch dieses Package kennt viele Optionen, lies Dir die Hilfe durch!

==== Cyclomatic Complexity prüfen mit cyclocomp 

McCabes "cyclomatic complexity" (<<cyc>>) mißt die 
Komplexität von Programmcode.
Mit ihr kannst Du prüfen, ob Deine Funktionen einfach genug sind.

Insbesondere gibt Dir die "cyclomatic complexity" eine Idee davon, wie viele Testfälle Du 
für eine Funktion schreiben solltest
(genau genommen ist sie eine obere Grenze für die Anzahl der für vollständige https://en.wikipedia.org/wiki/Code_coverage[branch coverage] benötigten Testfälle).
Für Deine häßliche Funktion bräuchtest Du also 
+r cyclocomp::cyclocomp(parse(text = readLines("src/code.R")))+ Testfälle:

//begin.rcode
cyclocomp::cyclocomp(parse(text = readLines("src/code.R")))
//end.rcode

Allgemein gilt: je höher die "cyclomatic complexity", desto unverständlicher der Code.
McCabe empfiehlt eine "cyclomatic complexity" von nicht mehr als 10 für eine Funktion. Und der war professioneller Programmierer des Departement of Defense der National Security Agency. Bei einer "cyclomatic complexity"  von 20 dürfte es selbst für professionelle Programmiererinnen langsam schwierig werden, die Absicht hinter Deinem Code zu verstehen. Wenn Du eine "cyclomatic complexity" von mehr als 40 schaffst, hast Du vielleicht eine Funktion geschrieben, die tut, was sie soll, aber ziemlich sicher eine, die kaum ein Mensch mehr versteht. 

Natürlich gibt es immer Ausnahmen von der Regel. Die Funktion `devtools::release` beispielsweise 
hat eine ganze Reihe von interaktiven Abfragen des Typs
//begin.rcode, eval = FALSE
  if (yesno("Were devtool's checks successful?"))
    return(invisible())
//end.rcode
Diese treiben die "cyclomatic complexity" in die Höhe (weil die `return`-Anweisungen 
                                                        viele verschiedene mögliche Endpunkte der Funktion definieren. Eine gut strukturierte Funktion hat _genau einen_ "exit node"):

//begin.rcode
source("src/release.R")
cyclocomp::cyclocomp(release)
//end.rcode
Dabei ist die Funktion nur schwer verdaulich und nicht völlig unlesbar.
Dennoch sollte Hadley Wickham die Funktion dringend entrümpeln:
//begin.rcode
linters <- lintr::default_linters[names(lintr::default_linters )!= "object_usage_linter"]
lintr::lint("src/release.R", linters = linters)
//end.rcode
//begin.rcode
suppressWarnings(cleanr::check_file("src/release.R"))
//end.rcode

=== Funktionen dokumentieren 
//begin.rcode, code = readLines("src/wipe_clean.R")
//end.rcode

== Bibliographie
[bibliography]
- [[[cc]]] R.C. Martin. 2008. 'Clean Code: A Handbook of Agile Software Craftsmanship'. 
    Pearson Education.
- [[[cyc]]]  T. J. McCabe, 1976. 'A Complexity Measure'
   IEEE Transactions on Software Engineering archive.
   Volume 2, Issue 4, Pages 308-320 

