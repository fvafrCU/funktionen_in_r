= Funktionen Schreiben in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:numbered:
:data-uri:
:duration: 120

// //begin_only_slide
// == Skript
// https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]
// //end_only_slide

== Worum geht es?

Naja, ums Schreiben von Funktionen in der Programmiersprache **R**.



=== Was sind Funktionen?

* Funktionen sind Programmkonstrukte, mit denen Du Teile des von Dir 
  geschriebenen Codes wiederverwenden kannst
  (siehe https://de.wikipedia.org/wiki/Funktion_(Programmierung)[Wikipedia]).
* Funktionen sind in den Standardbiliotheken jeder Programmiersprache vorhanden, 
  viele R-Funktionen kennst Du wahrscheinlich schon: `sum()`, `mean()` 
  oder `summary()`.

=== Warum Funktionen?

* Damit Du Teile des von Dir geschriebenen Codes wiederverwenden kannst.
* Damit Du, wenn Du Fehler im Code entdeckst, diese auch nur an einer 
  Stelle korrigieren musst.

=== Wann Funktionen?

Immer wenn Du merkst, dass Du (alten) Code mehrfach kopierst und an anderer
Stelle einfügst ohne ihn stark zu verändern, solltest Du darüber nachdenken, 
eine (oder mehrere) Funktion(en)  aus ihm  zu machen. 


== Eine Funktion schreiben
=== Eine neue Summenfunktion

.Warum wir diese Funktion nicht schreiben sollten

Eine Summenfunktion gibt es wahrscheinlich in jeder Programmiersprache, in **R**
heißt sie `sum()`. Diese Funktion ist besser, stabiler und schneller, als
alles, das wir selbst programmieren können.

.Warum wir es trotzdem tun

Nunja, irgendwelchen Code müssen wir ja nehmen.  
Ich habe die Summenberechnung ausführlich als Beispiel zur Schleifenprogrammierung in 
https://fvafrcu.github.io/programmieren_in_r/#gute-schleifen[Programmieren in R] benutzt, 
    und eine Wiederholung schadet sicher nicht.


==== Vom Code ... 
//begin.rcode, code = readLines(file.path("src", "sum.R"))
//end.rcode

Dabei siehst Du:

<1> Definition des zu summierenden Vektors
<2> Definition des zur Addition neutralen Elementes
<3> Schleife über die Elemente des Vektors
<4> Addition des aktuellen Vektorelementes zum Ergebnis
<5> Ausgabe des Ergebnisses

==== ... zur Funktion 

Für unsere Summenfunktion soll die Definition des zu summierenden Vektors
der Anwenderin überlassen werden, daher wird der Vektor zu einem Argument
der Funktion. Ich wähle als Namen für das Argument jetzt +x+, das könnte aber
auch +a+ bleiben, es ist eine Frage der Konvention, und unter +x+ verstehen wir
meist eine Unbekannte. Und als Ausgabe verwenden wir keine Druck- sondern eine
Rückgabefunktion (+return()+ statt +print()+). 
Das Ergebnis sieht dann so aus:




//begin.rcode, code = readLines(file.path("src", "my_sum.R"))
//end.rcode


=== Scoping 
Programmiersprachen kennen für Objekte unterschiedliche Gültigkeitsbereiche 
(englisch "scope"), wir sehen uns das am Beispiel an:

==== Schreibzugriffe

.Ausgangszustand
Im Augenblick hat das Objekte +value+ den Wert +r value+:

//begin.rcode
print(value)
//end.rcode

.Funktionsausführung
Jetzt wenden wir unsere Summenfunktion an und berechnen die Summe eines anderen Vektors: 
//begin.rcode
print(my_sum(1:3))
//end.rcode

Das Objekt `value` behält seinen Wert:
//begin.rcode
print(value)
//end.rcode
Und das, obwohl wir innerhalb der Funktion dem Objekt +value+ in der ersten
Zeile den Wert 0 zuweisen und diesen dann in der Schleife mit den Werten 1, 3
und 6 überschreiben:
**R** verwaltet automatisch die Gültigkeitsbereiche aller Objekte. 
Es gibt daher ein Objekt names  +value+ außerhalb der Funktion, das den Wert +r value+ enthält und unverändert bleibt.
Innerhalb der Funktion legt **R** ein neues lokales Objekt, ebenfalls mit dem Namen
+value+, an.
Du _kannst_ auch aus einer Funktion in einen <<_arbeiten_mit_gültigkeitsbereichen, anderen Gültigkeitsbereich>> schreiben, wenn Du das wirklich willst.


==== Lesezugriffe

.Lesen ist unsicher
Mit dem Namen eines Objektes wird dieses gelesen, innerhalb einer Funktion sucht
**R** zunächst nach einem lokalen Objekt des gesuchten Namens, dann in den der
Funktion übergeordneten Gültigkeitsbereichen, also außerhalb der Funktion.

Das kann zu unerwünschten Nebeneffekten führen. Stell Dir vor, Du kommentierst 
beim Schreiben der Summenfunktion die Definition des zur Addition neutralen
Elementes aus Versehen aus:
//begin.rcode, code = readLines(file.path("src", "my_sum_scope_broken.R"))
//end.rcode

Du führst die Funktion aus und erhälst:
//begin.rcode
print(my_sum_broken(1:3))
//end.rcode
Was ist passiert?
Im ersten Durchlauf der Schleife gibt es beim Lesen von
+value+ noch kein lokales Objekt dieses Namens. Daher sucht **R** außerhalb der
Funktion und findet ein Objekt mit dem Wert +r value+. 
Zu diesem Objekt addieren
wir +x_i+, das im ersten Schleifendurchlauf den Wert +1+ enthält und erschaffen
damit in der Funktion ein lokales Objekt names +value+, das dann im zweiten
Durchlauf der Schleife auch gelesen werden kann.

Wenn Du diese Funktion verwendest, ohne vorher das Objekt +value+ zu definieren,
oder das Objekt +value+ entfernst und dann die Funktion ausführst
//begin.rcode
rm(value)
print(my_sum_broken(1:3))
//end.rcode
erhälst Du einen Fehler, weil **R** auch außerhalb der Funktion kein Objekt
names +value+ finden kann. Und diesen Fehler erwarten wir ja eigentlich, wenn 
wir nur die Funktion betrachten: sie ist fehlerhaft.

.Sicherer Lesen
Wie wir eine Funktion dazu bringen können, außerhalb ihres Gültigkeitsbereiches
zu schreiben (nein, das _wie_ habe ich Dir noch nicht gezeigt), so können wir 
eine Funktion auch zwingen, beim Lesen nur nach lokalen Objekten zu
suchen:
//begin.rcode, code = readLines(file.path("src", "my_sum_get_safe.R"))
//end.rcode

Selbst wenn wir ein Objekt namens +value+ anlegen, gibt die Funktion nun einen
Fehler aus:
//begin.rcode
value <- 42
my_sum_safer(1:10)
//end.rcode
Ich finde es aber praktiabler, beim Schreiben einer Funktion darauf zu achten,
welche Objekte ich lese. + 
Und wenn Du Funktionen <<_funktionen_testen,testest>>, findest Du Fehler, die auf Scoping beruhen,
sehr schnell. 


==== Arbeiten mit Gültigkeitsbereichen 

Ein Befehl, mit dem Du alle Objekte Deines aktuellen Arbeitsbereiches löschen
kannst (entsprechend dem RStudio-Knopf mit dem Besensymbol footnote:[Im https://github.com/rstudio/rstudio/releases/tag/v1.1.426[Code von RStudio v1.1.426] findet sich die Funktion hinter dem Knopf  in der Datei src/cpp/session/modules/SessionEnvironment.R, sie besteht im wesentlichen aus der Zeile +
rm(list=ls(envir=env, all.names=includeHidden), envir=env) +
Sie wird in src/cpp/session/modules/environment/SessionEnvironment.cpp in der C++-Funktion  removeAllObjects aufgerufen.
]) lautet:

//begin.rcode, eval = FALSE
rm(list = ls(all.names = TRUE))
//end.rcode
Nun  bin ich
vergesslich, weshalb ich mir die Syntax schlecht merken kann und lieber eine
Funktion (aber keinen Knopf) hätte.
Da "der aktuelle Arbeitsbereich" ein Gültigkeitsbereich 
(in **R** heissen die Gültigkeitsbereiche "environments", in **S** hießen sie "frames") ist und die 
Funktionen  `ls` und `rm` nur in _einem_ Gültigkeitsbereich arbeiten, funktioniert das naheliegende
//begin.rcode, eval = FALSE
wipe_clean <- function() {
    rm(list = ls(all.names = TRUE))
}
//end.rcode 
*nicht*.

Wenn ich den Gültigkeitsbereich explizit 
//begin.rcode
wipe_clean <- function() {
    rm(list = ls(name = parent.frame(), all.names = TRUE), envir = parent.frame())
}
//end.rcode 
angebe, tut die Funktion, was ich wollte:
//begin.rcode
ls()
wipe_clean()
ls()
//end.rcode 




=== Argumente

Funktionen kennen Argmumente, am besten nicht zu viele (siehe zum Beispiel <<cc>>). 
Unsere Summenfunktion kennt beispielsweise eines, nämlich den Vektor, den sie summieren soll. Der ist also ein obligatorisches Element, er sollte keine Voreinstellung haben (und hat auch keine).


Eine Funktion, die, wie `wipe_clean`, kein Argument kennt, ist Folgende:


//begin.rcode, code = readLines(file.path("src", "memhogs.R"))
//end.rcode

Diese Funktion gibt mir für jedes Objekt des Gültigkeitsbereiches, in dem ich sie aufrufe, den Speicherverbrauch aus.

//begin.rcode
va <- rep(mtcars, 1)
vb <- rep(mtcars, 1000)
vc <- rep(mtcars, 2000)
vd <- rep(mtcars, 100)
memory_hogs()
//end.rcode

Bei so wenigen Objekten erkenne ich leicht, dass `vc` der größte Speicherfresser ist und ich, falls mir der Speicher platzt und ich `vc` nicht mehr unbedingt brauche, `vc` löschen sollte.

Aber wenn ich viele Objekte habe, wäre es doch schön, ein optionales Funktionsargument zu haben, dass in seiner Voreinstellung die Ausgabe nach Größe des Speicherbedarfs sortiert:

//begin.rcode, code = readLines(file.path("src", "memhogs_arg.R"))
//end.rcode

//begin.rcode
memory_hogs()
//end.rcode

Das ist ein klassisches (optionales) Steuerargument, das das Verhalten einer Funktion steuert.
Steuerargumente sollten eine sinnvolle Voreinstellung haben.

Da die `memory_hogs` intern nun die Funktion `order` aufruft, könnten wir ja auf die Idee kommen, dieser Funktion Argumente weiterreichen zu wollen. 
Das können wir entweder explizit tun, oder wir benutzen ein spezielles, _Ellipsis_ genanntes Argument, das durch drei Punkte (`...`) aufgerufen wird:

//begin.rcode, code = readLines(file.path("src", "memhogs_ellipsis.R"))
//end.rcode

//begin.rcode
memory_hogs()
memory_hogs(decreasing = TRUE)
//end.rcode

Jetzt können wir die Rückgabe unserer Funktion nutzen, um die beiden größten Speicherfresser zu löschen:

//begin.rcode
rm(list = names(memory_hogs(decreasing = TRUE)[1:2]))
memory_hogs()
//end.rcode

Wir können also, wenn wir wollen, drei Arten von Argumenten unterscheiden:

- Obligatorische. Sie sollten keine Voreinstellungen kennen und übergeben üblicherweise Objekte, die von der Funktion verarbeitet werden sollen.
- Optionale. Sie sollten Voreinstellungen kennen und dienen üblicherweise der Steuerung der Funktion.
- Die _Ellipsis_, um Argumente an andere Funktionen weiterzureichen.

=== Return Value und Side Effects
Jede Funktion in **R** gibt einen Wert zurück, falls sie nicht mit einem Fehler abbricht.
Wenn wir keinen Rückgabewert (return value) explizit angeben, ist er automatisch der Wert des letzten in der Funktion ausgewerteten Ausdrucks, also der letzte Wert, der wie auch immer berechnet oder zurückgegeben wurde.
Es ist daher sicher nicht schlecht, wenn Du versucht, den Rückgabewert explizit anzugeben.
Unsere Summenfunktion könnte auch so aussehen:

//begin.rcode
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
}
//end.rcode

Das ist zwar (um eine Zeile) kürzer und inhaltsgleich, aber weniger offensichtlich. Und damit weniger gut lesbar.
Und damit mehr schlechter als eine Zeile kürzer mehr besser ist, capisce?

Komplexere Funktionen haben oft Nebenwirkungen (side effects).
Bei vielen dieser Funktionen sind die Nebenwirkungen der eigentliche Zweck der Funktion, manchmal ist Rückgabewert sogar belanglos. Die Funktion `rm` gibt beispielsweise unsichtbar `NULL` zurück (und das selbst dann, wenn es gar nichts zu löschen gibt), das erkennen wir, wenn wir ihren Rückgabewert explizit drucken:
//begin.rcode
a <- "This is a string"
print(rm(a))
print(rm())
//end.rcode

Das heißt also, dass unsere Funktion `wipe_clean` den Wert `invisible(NULL)`, zurückgibt, denn das war der Wert des letzten in ihr ausgewerteten Ausdrucks (der Aufruf der Funktion `rm`).

Das können wir ändern, indem wir einen expliziten Rückgabewert einbauen (bei der Gelegenheit wandeln wir gleich noch den Gütigkeitsbereich, indem die Funktion l&ouml;scht, in ein Steuerargument mit Voreinstellung um):

//begin.rcode, code = grep("#'", readLines(file.path("src", "wipe_clean.R")), value = TRUE, invert = TRUE)
//end.rcode
//begin.rcode
print(wipe_clean())
ls()
//end.rcode
Jetzt gibt die Funktion die Namen der von ihr gelöschten Objekte zurück. Wir wissen also, wie hieß, was wir gelöscht haben. Damit können wir zwar nichts mehr anfangen, aber die Funktion hat nun genau einen expliziten Endpunkt. Das ist immerhin schön übersichtlich.


=== Funktionen verwalten

==== Im jeweiligen Skript
Ich schreibe viele Funktionen während Datenauswertungen, sie landen dann erstmal 
im jeweiligen Auswertungsskript. Manchmal sammele ich sie an dessen Beginn, meist lege ich 
sie aber gleich <<_lokal, lokal>> ab.

==== Lokal
Viele meiner wissenschaftlichen Projekte haben im R-Skript-Verzeichnis ein Unterverzeichnis mit dem Namen +./functions+.
Darin lege ich die Funktionen, die ich <<_im_jeweiligen_skript, in den Skripten des Projektes>> schreibe, ab.
Wichtige Funktionen kommen in eigene Dateien, die nach ihnen benannt sind, andere sammele ich, beispielsweise in 
+./functions/utils.R+ oder +./functions/misc.R+.

Jedes Auswertungsskript hat dann am Beginn die Zeile
//begin.rcode, eval = FALSE
for (f in dir("./functions/", full.names = TRUE, pattern = ".*\\.[rR]")) source(f)
//end.rcode

====  Global 
Funktionen, die Du nicht nur in einem Projekt nutzen willst, kannst Du zentral verwalten, 
in dem Du Dateien wie <<_lokal, lokal>>, aber in einem zentralen Verzeichnis ablegst, 
und in eine Deiner R-Startup-Dateien die Anweisung
//begin.rcode, eval = FALSE
for (f in dir("/full/path/to/functions_directory/", 
              full.names = TRUE, pattern = ".*\\.[rR]")) source(f)
//end.rcode
einfügst und den  "/full/path/to/functions_directory/" anpasst.
Geeignte R-Startup-Dateien verrät Dir die R-Hilfe +?Startup+ oder der Code:
//begin.rcode, results = "hide"
candidates <- c( Sys.getenv("R_PROFILE"),
                 Sys.getenv("R_PROFILE_USER"),
                 file.path(Sys.getenv("R_HOME"), "etc", "Rprofile.site"),
                 file.path(Sys.getenv("HOME"), ".Rprofile"),
                 file.path(getwd(), ".Rprofile") )

Filter(file.exists, candidates)
//end.rcode

==== Als Paket
Wenn Du Dir die Mühe machst, Deine Funktionen zu <<_funktionen_dokumentieren, dokumentieren>>, kannst 
Du sie eigentlich auch gleich in einem oder mehreren Paketen verwalten. 
Das ist am elegantesten.


== Schöner Programmieren

=== Argumententests
Wir haben verschiedene Möglichkeiten, die Objekte, die wir den Argumenten einer Funktion übergeben, zu testen.


==== Typentests

Wir können Objekte darauf testen, ob sie einem bestimmten Typ (einer Klasse) angehören; 
bei Objekten, die einer Funktion als Argument übergeben werden ist dies besonders ratsam.
Das geht mir reinen +base R+, ist aber eher umständlich,
die https://cran.r-project.org/web/packages/checkmate/vignettes/checkmate.html#intro[Vignette zu +checkmate+] 
bietet ein anschauliches Bespiel.

Ich kenne zwei Pakete, die Typentest vereinfachen: 
https://CRAN.R-project.org/package=assertthat[assertthat] und 
https://CRAN.R-project.org/package=checkmate[checkmate]

-  https://CRAN.R-project.org/package=checkmate[checkmate] ist hauptsächlich in C geschrieben, sehr schnell, 
sehr flexibel mit unterschiedlichen Testarten ("checks", "asserts" und "tests"), 
hat aber viele Abhängigkeiten und ist etwas sperrig: sein Manual ist über 100 Seiten lang. 
- https://CRAN.R-project.org/package=assertthat[assertthat] ist reines R ohne irgendwelche Abhängigkeiten und recht übersichtlich.

https://CRAN.R-project.org/package=assertthat[assertthat] ist sehr einfach:
//begin.rcode
x <- 6
assertthat::assert_that(is.numeric(x))
//end.rcode
//begin.rcode
x <- "This is a string."
assertthat::assert_that(is.numeric(x))
//end.rcode

.Was haben wir davon?
Wenn wir unserer Summenfunktion 

//begin.rcode, code = readLines(file.path("src", "my_sum.R"))
//end.rcode

ein nicht-numerisches Argument übergeben, erhalten wir eine recht kryptische Fehlermeldung:

//begin.rcode
my_sum(c("a", "b"))
//end.rcode


Durch den Einbau eines Typentests 

//begin.rcode, code = readLines(file.path("src", "my_sum_assertion.R"))
//end.rcode
wird die Meldung deutlich verständlicher:
//begin.rcode
my_sum(c("a", "b"))
//end.rcode

Mit https://CRAN.R-project.org/package=checkmate[checkmate] können wir sogar erzwingen, dass x nicht nur numerisch sein muss,
sondern auch mindestens zwei Elemente haben soll. Eine Summe einer Zahl ist ja etwas albern:
//begin.rcode, code = readLines(file.path("src", "my_sum_checkmate.R"))
//end.rcode

//begin.rcode
my_sum(42)
//end.rcode

_Ich nutze Typentests oft in Funktionen. Da https://CRAN.R-project.org/package=checkmate[checkmate] deutlich mehr Funktionalität bietet, nutzte ich https://CRAN.R-project.org/package=assertthat[assertthat] eher selten._

==== Auswahllisten
Mit Auswahllisten können wir Objekte darauf testen, ob sie eine von mehreren Möglichkeiten
enthalten. Das ist vor allem für Steuerargumente hilfreich.
+base R+ kennt +match.arg+, das mit alphanumerischen Vektoren arbeitet und einfach das Objekt zurückgibt, wenn
es in der Auswahlliste enthalten ist:
//begin.rcode
noten <-  c("sehr gut", "gut", "nicht soo gut", "das kann auf jeden Fall noch besser werden")
note  <- "gut"
match.arg(arg = note, choices = noten)
//end.rcode
Dabei bedient es sich dem "partial matching", das heißt, dass ein eindeutig einer Auswahlmöglichkeit zuzuordnender Anfang einer Zeichenkette ausreicht:
//begin.rcode
note  <- "das"
match.arg(arg = note, choices = noten)
//end.rcode

Wird kein Treffer in der Auswahlliste gefunden, erhalten wir einen Fehler:
//begin.rcode
note  <- "ausreichend"
match.arg(arg = note, choices = noten)
//end.rcode

+match.arg+ ist genau, was hinter Steuerargumenten vieler Funktionen (z.b.  +mgcv::gam(optimizer = ...)+) steckt, hier ein Beispiel aus der Hilfe zu +match.arg+:
//begin.rcode
center <- function(x, type = c("mean", "median", "trimmed")) {
    type <- match.arg(type)
    switch(type,
           mean = mean(x),
           median = median(x),
           trimmed = mean(x, trim = .1))
}
center(rnorm(100), "med")
center(rnorm(100), "m")
//end.rcode


https://CRAN.R-project.org/package=checkmate[checkmate] kennt auch Auswahllisten, macht aber kein +partial matching+ (was ich ganz gut finde):
//begin.rcode
note  <- "das"
checkmate::assertChoice(x = note, choices = noten)
//end.rcode

Außerdem gibt https://CRAN.R-project.org/package=checkmate[checkmate] die gefundene Rückgabe unsichtbar zurück, weshalb ich hier ein explizites +print+ benötige:
//begin.rcode
note  <- "gut"
checkmate::assertChoice(x = note, choices = noten)
print(checkmate::assertChoice(x = note, choices = noten))
//end.rcode

https://CRAN.R-project.org/package=checkmate[checkmate] kann nicht nur mit alphanumerischen Vektoren umgehen:
//begin.rcode
x <- 3
choices <- 1:7
print(checkmate::assertChoice(x = x, choices = choices))
//end.rcode


_Ich nutze Auswahllisten eher selten, da ich selten Steuerargumente mit mehreren Auswahlmöglichenkeiten in meinen Funktionen habe._

=== Funktionen testen
==== Unit Testing
Beim Unit Testing wollen wir nicht die einer Funktion übergebenen Argumente, sondern die Funktion selbst testen.
Also im Zweifel ihren Rückgabewert.

Ich kenne zwei Pakete, die Unit Testing in R formalisieren 
(im Prinzip geht es auch ohne spezielle Pakete, 
 aber seit ich die beiden Pakete kenne, 
 habe ich nie mehr wie früher "von Hand" getestet):

- https://CRAN.R-project.org/package=RUnit[RUnit] gibt es schon seit 2004, es ist sehr formal
 und hat wenige Abhängigkeiten (daher bevorzuge ich es beim Testen von Paketen).
- https://CRAN.R-project.org/package=testthat[testthat] finde ich interaktiv einfacher anzuwenden.

===== Erwartungen 
Die kleinste Testeinheit ist immer ein Vergleich. 

Wenn wir die Funktionen 

//begin.rcode, code = readLines(file.path("src", "my_sum.R"))
//end.rcode
 und 
//begin.rcode, code = readLines(file.path("src", "not_my_sum.R"))
//end.rcode
haben, können wir zum Beispiel mit +base R+ prüfen, ob sie tun, was wir erwarten:

//begin.rcode
my_sum(c(2, 7)) == 9
# better use identical(), see ?Comparison 
identical(not_my_sum(c(2, 7)), 9)
//end.rcode

Beide Pakete formalisieren dies zu Erwartungsfunktionen die hauptsächlich dazu dienen, 
Fehler zu beschreiben:

.https://CRAN.R-project.org/package=RUnit[RUnit]
//begin.rcode
RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
//end.rcode

.https://CRAN.R-project.org/package=testthat[testthat]
//begin.rcode, eval  = FALSE
testthat::expect_identical(not_my_sum(c(2, 7)), 9)
//end.rcode
//begin.rcode, echo  = FALSE
# testthat stop()s R, need to tryCatch
tryCatch(testthat::expect_identical(not_my_sum(c(2, 7)), 9), expectation_failure= function(cond) cat(unlist(cond)))
//end.rcode

===== Tests 
Um Erwartungen bei der Paketentwicklung oder in Bezug auf ihre <<_code_coverage, Coverage>> auszuwerten,
    werden in beiden Paketen Erwartungen zu Tests zusammenfasst 
(eigentlich sollten Tests immer nur Erwartungen zu einer Funktion enthalten, aber wir wollen ja auch Fehler sehen):

//begin.rcode, echo = FALSE
source(file.path("src", "my_sum.R"))
source(file.path("src", "not_my_sum.R"))
//end.rcode

.https://CRAN.R-project.org/package=testthat[testthat]
Du kannst einen Test entweder einzeln laufen lassen


//begin.rcode, code = readLines(file.path("src", "test_my_sum.R"))
//end.rcode

oder den Test in einer  Testdatei 

[source,r]
//begin.rcode, code = readLines(file.path("src", "test_my_sum.R")), eval = FALSE
//end.rcode

mit einer Funktion auswerten, bei https://CRAN.R-project.org/package=testthat[testthat] ändert sich 
relativ wenig: 

//begin.rcode
testthat::test_file(file.path("src", "test_my_sum.R"))
//end.rcode
Du erhälst aber die Information, dass der Fehler im ersten Test in Zeile 2 auftrat.

.https://CRAN.R-project.org/package=RUnit[RUnit]
Größer sind die Unterschiede bei https://CRAN.R-project.org/package=RUnit[RUnit], 
das primär für das Testen von Paketen entwickelt wurde:
Es ist beim einfachen
//begin.rcode
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
    RUnit::checkIdentical(my_sum(c(2, 7)), 9)
}
test_sum()
//end.rcode
recht spröde, mit einer Testdatei 

.src/runit_my_sum.R
[source,r]
//begin.rcode, code = readLines(file.path("src", "runit_my_sum.R")), eval = FALSE
//end.rcode

allerdings gesprächiger:

//begin.rcode
test_file <- normalizePath(file.path("src", "runit_my_sum.R"))
runit <- RUnit::runTestFile(test_file)
RUnit::printTextProtocol(runit)
//end.rcode

==== Code Coverage
Um zu sehen, ob Deine Unit Tests die Funktion gut testen, kannst Du ihre  (https://en.wikipedia.org/wiki/Code_coverage[Überdeckung]) berechnen.
https://CRAN.R-project.org/package=covr[covr] ist eines der Pakete, die Code Coverage implentieren und das einzige, das ich nutze. Ich weiß es nicht, glaube aber, dass https://CRAN.R-project.org/package=covr[covr] die https://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria[_branch coverage_]
berechnet. 
Prinzipiell ist eine hohe Überdeckung gut.

Wenn Du eine Datei mit einer Funktionsdefinition

.src/my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "my_sum_assertion.R")), eval = FALSE
//end.rcode

und eine mit dem Test

.src/test_my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "test_my_sum_assertion.R")), eval = FALSE
//end.rcode

hast, kannst Du die Überdeckung berechnen.

//begin.rcode
cov <- covr::file_coverage(file.path("src", "my_sum_assertion.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
//end.rcode

Wenn Du eine Funktion schreibst, in der eine Zeile eingebaut ist, die der Test nicht
erreicht, weist Dich https://CRAN.R-project.org/package=covr[covr] darauf hin:

.src/my_sum_assertion.R
//begin.rcode, code = readLines(file.path("src", "my_sum_coverage.R")), eval = FALSE
//end.rcode

//begin.rcode
cov <- covr::file_coverage(file.path("src", "my_sum_coverage.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
//end.rcode

https://CRAN.R-project.org/package=covr[covr] sagt Dir sogar, dass es die dritte Zeile ist:
//begin.rcode
covr::zero_coverage(cov)
//end.rcode

===== Nebenwirkungen testen

Funktionen sind relativ einfach zu testen, wenn ihr Rückgabewert ihr Zweck ist.
Wenn sie aber Nebenwirkungen bezwecken, finde ich Tests schwieriger zu schreiben.

Stell Dir vor, Du hättest die fehlerhafte Löschfunktion aus 
<<_arbeiten_mit_gültigkeitsbereichen, Arbeiten mit Gültigkeitsbereichen>> 
in eine Datei geschrieben:

.src/wipe_clean_broken.R
[source,r]
include::src/wipe_clean_broken.R[]

Nun schreibst Du eine Testdatei:

.src/test_wipe_clean_broken.R
[source,r]
include::src/test_wipe_clean_broken.R[]

Und erhälst vollständige Überdeckung:

//begin.rcode
cov <- covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                           file.path("src", "test_wipe_clean_broken.R"))
print(cov)
//end.rcode

Alles gut? Nein, die Funktion ist kaputt und die Testdatei, die dies zeigt müsste 
auf die Nebenwirkung testen:

.src/test_wipe_clean.R
[source,r]
include::src/test_wipe_clean.R[]

//begin.rcode
covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                    file.path("src", "test_wipe_clean.R"))
//end.rcode

==== Was soll die ganze Testerei?
//begin.rcode, echo = FALSE, results = "hide"
source(file.path("src", "wipe_clean.R"))
wipe_clean()
//end.rcode

Stell Dir vor, Du erstelltest öfter Abbildungen. 
Jetzt bist Du ein Mensch mit einem Gefühl für Harmonien,
daher willst Du gerne, wenn möglich, den 
https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldenen Schnitt] bei der 
Wahl der Zuschnitte berücksichtigen.

Da Du Dir den Goldenen Schnitt nicht gut merken kannst, schreibst Du folgende Funktion:

//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_ratio_bare.R"
withr::with_dir("src", file.copy(src, "golden_ratio.R", overwrite = TRUE))
src <- "test_golden_ratio_bare.R"
withr::with_dir("src", file.copy(src, "test_golden_ratio.R", overwrite = TRUE))
//end.rcode
.src/golden_ratio.R
// WARNING: Do not use
//     [source,r]
//     include::src/golden_ratio.R[]
// here as does not evaluate _now_ whereas knitr does!
//begin.rcode, code = readLines(file.path("src", "golden_ratio.R")), eval = FALSE
//end.rcode

Das ginge auch als Einzeiler: 
//begin.rcode, eval = FALSE
golden_ratio  <- function() return((1 + sqrt(5)) / 2)  
//end.rcode
aber den findest Du auch nicht viel eleganter, dafür aber schlechter lesbar.

Du schreibst auch einen Test, obwohl der ziemlich trivial ist:

.src/test_golden_ratio.R
//begin.rcode, code = readLines(file.path("src", "test_golden_ratio.R")), eval = FALSE
//end.rcode
[source,r]
//begin.rcode
covr::file_coverage(file.path("src", "golden_ratio.R"), 
                    file.path("src", "test_golden_ratio.R"))
//end.rcode

Wenn Du Graphiken nach dem Goldenen Schnitt proportionieren willst, musst Du bei 
gegebener Länge der kurzen Seite diese mit dem Goldenen Schnitt multipizieren 
um die Länge der langen Seite zu erhalten. 

Das ist eigentlich nicht allzu kompliziert, dennoch kommst Du manchmal durcheinander, 
also schreibst Du die folgende Funktion:
//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_a.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

Auch für diese Funktion schreibst Du einen Test:

//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_rectangle_a.R"
withr::with_dir("src", file.copy(src, "test_golden_rectangle.R", overwrite = TRUE))
//end.rcode
.src/test_golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "test_golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
covr::file_coverage(file.path("src", c("golden_ratio.R", "golden_rectangle.R")), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Du benutzt die Funtktion ...

//begin.rcode cars, fig.show = "hide"
source(file.path("src", "golden_ratio.R"))
width <- 4
png("p1.png", units = "cm", res = 400,
    width = width, 
    height = golden_rectangle(width)[["a"]])
par(mar=c(1,1,1,1))
plot(cars)
dev.off()
//end.rcode

 und bist begeistert:

.Oh, wie schön!
image::p1.png[]
[caption=""]


Du benutzt die Funktion eine Weile weiter, merkst dann aber, dass Du ja auch querformatige
Abbildungen erstellen willst und daher 
bei gegebener Länge der 
langen Seite diese durch den Goldenen Schnitt dividieren musst, um die Länge 
der kurzen Seite zu erhalten.

Jetzt kannst Du entweder eine neue Funktion schreiben oder die alte erweitern.
Da die Funktionalitäten zum selben Thema passen und +golden_rectangle+ bislang
recht simpel ist, schreibst Du Deine Funktion also um:

//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_ab.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
width <- 4
png("p2.png", units = "cm", res = 400,
    width = width, 
    height = golden_rectangle(width)[["b"]])
par(mar=c(1,1,1,1))
plot(cars)
dev.off()
//end.rcode

.Auch sehr schön!
image::p2.png[]
[caption=""]

Herzlichen Glückwunsch, Du hast gerade die https://en.wikipedia.org/wiki/Application_programming_interface[Schnittstelle] Deiner Funktion zerschossen, indem Du ihr voreingestelltes Verhalten geändert hast. 
Glücklicherweise hast Du einen Test, der Dir jetzt um die Ohren fliegt:

//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Was bedeutet das? 
Du musst entweder

- *alle* Aufrufe der Funktion, die Du vor der Veränderung ihrer Schnittstelle progammiert hast, 
  anpassen (indem Du +, landscape = FALSE+ einfügst) oder
- die Funktion so ändern, dass der Test weiterhin funktioniert.

Du entscheidest Dich, die Funktion zu ändern 
(und erweiterst bei der Gelegenheit gleich den R&uuml;ckgabewert):


//begin.rcode, echo = FALSE, results = "hide"
src <- "golden_rectangle_ba.R"
withr::with_dir("src", file.copy(src, "golden_rectangle.R", overwrite = TRUE))
source(file.path("src", "golden_rectangle.R"))
//end.rcode
.src/golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode

Um Querformatige Proportionen zu erhalten musst Du nun aktiv Querformat einstellen:
+golden_rectangle(width, landscape = TRUE)+

Der Test funktioniert wieder, da Du aber die Funktion geändert hast, überdeckt
er sie nicht mehr vollständig:

//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

Du erweiterst also Deine Testdatei an:

//begin.rcode, echo = FALSE, results = "hide"
src <- "test_golden_rectangle_ba.R"
withr::with_dir("src", file.copy(src, "test_golden_rectangle.R", overwrite = TRUE))
//end.rcode
.src/test_golden_rectangle.R
//begin.rcode, code = readLines(file.path("src", "golden_rectangle.R")), eval = FALSE
//end.rcode
//begin.rcode
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
//end.rcode

+golden_rectangle+ habe ich mir nur ausgedacht, um Dir mein Vorgehen zu verdeutlichen. Aber:

 _Ich teste fast alle meine Funktion nach genau dem Ablauf in diesem Abschnitt spätestens, 
wenn ich sie in ein Paket verpacke._

=== Weniger schlecht programmieren
Ich möchte Dir gerne noch drei Funktionen aus drei verschiedenen Paketen vorstellen, 
die Dir helfen können, gut lesbare Funktionen zu schreiben. 

_Ich nutze alle drei standardmäßig bei der Entwicklung von Paketen._

Aber vorweg stelle ich Dir noch https://CRAN.R-project.org/package=codetools[codetools] vor, es gehört zur Gruppe der "_recommended_ Packages" von **R** und kann Programmfehler finden, die drei anderen Pakete gibt es nur, weil https://CRAN.R-project.org/package=codetools[codetools] schon da war.

Stell Dir vor, Du hättest in der Datei "src/code.R" folgende unschöne 
und kaputte Funktion geschrieben:

//begin.rcode, code = readLines(file.path("src", "code.R")), eval = FALSE
//end.rcode

==== Code prüfen mit https://CRAN.R-project.org/package=codetools[codetools] 
In Deiner Funktion findet https://CRAN.R-project.org/package=codetools[codetools] 
die nicht benutzten Funktionsargumente und das nicht definierte Objekt +this_is_not_defined+:

//begin.rcode
source(file.path("src", "code.R"))
codetools::checkUsage(foo, all = TRUE)
//end.rcode

==== Entflusen mit  https://CRAN.R-project.org/package=lintr[lintr]  

Das Paket https://CRAN.R-project.org/package=lintr[lintr] prüft Code auf Fussel, 
das sind Abweichungen des Codes von Richtlinien zur übersichtlichen Formatierung. 
Die Richtlinien (gegen die https://CRAN.R-project.org/package=lintr[lintr] prüft, und die sind gut, halte Dich an sie;
                 zu mehr über Progammierrichtlinien findest Du im https://fvafrcu.github.io/programmierleitfaden.ps[Programmierleitfaden an der Forstlichen Versuchs- und Forschungsanstalt Baden-Württemberg]) 
sehen unter anderem vor, 
dass auf Kommas immer ein Leerzeichen folgen sollte, 
dass auf öffnende geschweifte Klammern immer ein Zeilenumbruch folgen sollte und 
dass eine Datei keine Leerzeilen am Ende enthalten sollte:

//begin.rcode
lintr::lint(file.path("src", "code.R"))
//end.rcode

Das Paket kennt viele Optionen, lies Dir die Hilfe durch!

Seit Ende 2017 gibt es auch das Paket https://CRAN.R-project.org/package=styler[styler], 
welches Code (auch in Dateien) umformatiert und in meinen Augen deutlich bessere 
Ergebnisse bringt als https://CRAN.R-project.org/package=formatR[formatR]. 
Ich nutze https://CRAN.R-project.org/package=styler[styler], wenn 
ich richtig schlecht geschriebenen Code lesen muss.

==== Code säubern mit  https://CRAN.R-project.org/package=cleanr[cleanr]  
Das Paket https://CRAN.R-project.org/package=cleanr[cleanr] prüft die Länge und (Zeilen-) Breite von Funktionen und Codedateien und
die Verschachtelungstiefe von Funktionen, ihre Argumentenanzahl und ob sie einen expliziten
Rückgabewert haben.
//begin.rcode
print(suppressWarnings(cleanr::check_file(file.path("src", "code.R"))))
//end.rcode


Auch dieses Paket kennt viele Optionen, lies Dir die Hilfe durch!

==== Cyclomatic Complexity prüfen mit https://CRAN.R-project.org/package=cyclocomp[cyclocomp] 

McCabes "cyclomatic complexity" (<<cyc>>) mißt die 
Komplexität von Programmcode.
Mit ihr kannst Du prüfen, ob Deine Funktionen einfach genug sind.

Insbesondere gibt Dir die "cyclomatic complexity" eine Idee davon, wie viele Testfälle Du 
für eine Funktion schreiben solltest
(genau genommen ist sie eine obere Grenze für die Anzahl der für vollständige https://en.wikipedia.org/wiki/Code_coverage[branch coverage] benötigten Testfälle).
Für Deine häßliche Funktion bräuchtest Du also 
+r cyclocomp::cyclocomp(parse(text = readLines(file.path("src", "code.R"))))+ Testfälle:

//begin.rcode
cyclocomp::cyclocomp(parse(text = readLines(file.path("src", "code.R"))))
//end.rcode

Allgemein gilt: je höher die "cyclomatic complexity", desto unverständlicher der Code.
McCabe empfiehlt eine "cyclomatic complexity" von nicht mehr als 10 für eine Funktion. Und der war professioneller Programmierer des Departement of Defense der National Security Agency. Bei einer "cyclomatic complexity"  von 20 dürfte es selbst für professionelle Programmiererinnen langsam schwierig werden, die Absicht hinter Deinem Code zu verstehen. Wenn Du eine "cyclomatic complexity" von mehr als 40 schaffst, hast Du vielleicht eine Funktion geschrieben, die tut, was sie soll, aber ziemlich sicher eine, die kaum ein Mensch mehr versteht. 

Natürlich gibt es immer Ausnahmen von der Regel. Die Funktion `devtools::release` beispielsweise 
hat eine ganze Reihe von interaktiven Abfragen des Typs
//begin.rcode, eval = FALSE
  if (yesno("Were devtool's checks successful?"))
    return(invisible())
//end.rcode
Diese treiben die "cyclomatic complexity" in die Höhe (weil die `return`-Anweisungen 
                                                        viele verschiedene mögliche Endpunkte der Funktion definieren. Eine gut strukturierte Funktion hat _genau einen_ "exit node"):

//begin.rcode
source(file.path("src", "release.R"))
cyclocomp::cyclocomp(release)
//end.rcode
Dabei ist die Funktion lediglich schwer verdaulich und nicht völlig unlesbar.
Dennoch sollte Hadley Wickham die Funktion dringend entrümpeln:
//begin.rcode
linters <- lintr::default_linters[names(lintr::default_linters )!= "object_usage_linter"]
lintr::lint(file.path("src", "release.R"), linters = linters)
suppressWarnings(cleanr::check_file(file.path("src", "release.R")))
//end.rcode

=== Funktionen dokumentieren 
Wenn Du Hilfe zu einer Funktion in **R** suchst, kannst Du unter anderem die 
**R**-Hilfe mit +help(topic)+ oder der Kurzform +?topic+ aufrufen, bei Paketen findest Du
die selbe Information auch immer als pdf beigelegt.

Solche Hilfeformate kannst Du f&uuml;r Deine Funktionen auch schreiben.

==== Warum solltest Du Deine Funktionen dokumentieren?
Wenn Du Funktionen dokumentierst, erkl&auml;rst Du einer anderen Person, was die Funktion
tun sollte. Wenn Du das schaffst, kannst Du Dir einigerma&szlig;en sicher sein, 
dass Du wei&szlig;t, was die Funktion tut und dass es richtig war, 
sie (und nicht eine etwas andere) zu schreiben.

Au&szlig;erdem ist es von dokumentierten Funktionen zu Paketen nicht mehr weit, 
was ihre <<_als_paket, Verwaltung>> deutlich erleichtert.

Nehmen wir unser <<_was_soll_die_ganze_testerei, Beispiel zum Goldenen Schnitt>>:

Du merkst, dass Du die Funktion +golden_ratio+ eigentlich nur innerhalb 
von +golden_rectangle+ benutzt und letzteres kein gl&uuml;cklicher Name ist, weil 
Du die Funktion zwar zum Errechnen von Seitenl&auml;ngen von Graphiken nutzt, sie
ja aber ganz allgemein den Goldenen Schnitt ausrechnet.
Du entschlie&szlig;t Dich daher, die interne Funktion in 
+.golden_ratio+ (der f&uuml;hrende Punkt ist eine Konvention, die aus der UNIX-Welt stammt, 
                 dort werden (vorwiegend Konfigurations-) Dateien mit einem f&uuml;hrenden Punkt 
                 aus dem directory listing ausgeschlossen (unter Windows heissen diese Dateien "versteckt")
                 -- in **R** kennzeichnet die Konvention interne Funktionen, die gew&ouml;hnlich
                 nicht direkt aufgerufen werden (sollten))
                 und +golden_rectangle+ in +golden_ratio+ umzubenennen.
Dazu musst Du 

- die Funktionsdateien und die zugeh&ouml;rigen Testdateien umbenennen,
- die Namen in den Funktionsdefinitionen &auml;ndern und
- die Namen in den Funktionsaufrufen &auml;ndern.

Das kannst Du von Hand machen, oder Du schreibst folgende Funktionen:

//begin.rcode

substitute_function <- function(from, to, file_name) {
        patterns <- c(definition_pattern = paste0(from, "( *<-)"),
                      call_pattern = paste0(from, "(\\()"))
        x <- readLines(file_name)
        for (pattern in patterns) 
            x <- sub(pattern, paste0(to, "\\1"), x)

        writeLines(x, con = file_name)

}

rename_function <- function(from, to, directory = ".") {
    file_names <- list.files(directory, full.names = TRUE, 
                             pattern = paste0("^(test_|)", from, "\\.[rR]$")
                             )
    new_file_names <- NULL

    for (file_name in file_names) {

        substitute_function(from = from, to = to, file_name = file_name)
        new_file_name <- file.path(dirname(file_name), 
                                   sub(from, to, basename(file_name)))
        file.rename(file_name, new_file_name)
        new_file_names <- c(new_file_names, new_file_name)
    }
    return(new_file_names)
}
//end.rcode
Diese Funktionen leben ja von Nebenwirkungen, sie sind schwer zu testen und wir hoffen also, dass Du keine Fehler gemachst hast.

Funktionieren tut das so:

//begin.rcode
rename_function(from = "golden_ratio", to = ".golden_ratio", 
                 directory = "src")
# replace calls to golden_ratio()!
substitute_function(from = "golden_ratio", to = ".golden_ratio", 
                 file_name = file.path("src", "test_golden_rectangle.R"))
substitute_function(from = "golden_ratio", to = ".golden_ratio", 
                 file_name = file.path("src", "golden_rectangle.R"))
rename_function(from = "golden_rectangle", to = "golden_ratio", 
                 directory = "src")


//end.rcode
Du testest nat&uuml;rlich Deine neuen Dateien:
//begin.rcode
covr::file_coverage(file.path("src", ".golden_ratio.R"), 
                    file.path("src", "test_.golden_ratio.R"))
covr::file_coverage(file.path("src", c("golden_ratio.R", ".golden_ratio.R")), 
                    file.path("src", "test_golden_ratio.R"))
//end.rcode

Scheint geklappt zu haben.

Du siehst also, dass Du Deine Funktionen ver&auml;ndert hast, _weil_ Du sie dokumentieren 
willst.


==== Wie kannst Du Funktionen dokumentieren?

Das **R**-Hilfeformat wird https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Writing-R-documentation-files[hier] 
beschrieben, ich rate Dir aber, https://cran.r-project.org/web/packages/roxygen2/index.html[roxygen2] zu
benutzen (http://r-pkgs.had.co.nz/man.html[hier] gibt Hadley Wickham eine druckreife Einf&uuml;hrung).

Du ver&auml;nderst also Deine Funktionsdatei, in dem Du Dokumentationskommentare einf&uuml;gst:

//begin.rcode, echo = FALSE, results = "hide"
code <- c(readLines(file.path("src", "golden_ratio_doc.R")), 
          readLines(file.path("src", "golden_ratio.R"))) 
writeLines(text = code,
           con = file.path("src", "golden_ratio.R"))
//end.rcode

.src/golden_ratio.R
//begin.rcode, code = readLines(file.path("src", "golden_ratio.R")), eval = FALSE
//end.rcode

und weil dokumentieren Dir soviel Spa&szlig; bereit, dokumentierst Du gleich auch
die interne Funktion (interne Funktionen zu dokumentieren ist ein wenig umstritten,
                      ich finde es gut).

//begin.rcode, echo = FALSE, results = "hide"
code <- c(readLines(file.path("src", ".golden_ratio_doc.R")), 
          readLines(file.path("src", ".golden_ratio.R"))) 
writeLines(text = code,
           con = file.path("src", ".golden_ratio.R"))
//end.rcode

.src/.golden_ratio.R
//begin.rcode, code = readLines(file.path("src", ".golden_ratio.R")), eval = FALSE
//end.rcode

Was hast Du davon, au&szlig;er Arbeit?

Wenn Du Deine beiden Funktionen in eine Datei schreibst

//begin.rcode, echo = FALSE, results = "hide"

code <- c(readLines(file.path("src", ".golden_ratio.R")), "",
          readLines(file.path("src", "golden_ratio.R"))) 
writeLines(text = code,
           con = file.path("src", "golden_ratios.R"))
//end.rcode

.src/golden_ratios.R
//begin.rcode, code = readLines(file.path("src", "golden_ratios.R")), eval = FALSE
//end.rcode

kannst Du mit dem Paket https://CRAN.R-project.org/package=document[document] Hilfe-Dateien erstellen, 
wie Du sie aus **R** kennst:

//begin.rcode, results = "hide", warning = FALSE, message = FALSE, error = FALSE
document::document(file.path("src", "golden_ratios.R"), output_directory = ".")
//end.rcode
//begin.rcode
list.files(pattern = "^golden.*", full.names = TRUE)
//end.rcode

Au&szlig;erdem kannst Du mit https://CRAN.R-project.org/package=document[document] nach der Erstellung der Hilfe-Dateien 
in einer laufenden **R**-Sitzung die Hilfe zu Deiner Funktion ansehen:
//begin.rcode, echo = FALSE
pager_function <- function(x, ...){
    x <- readLines(x)
    x <- gsub("_", "", x)
    cat(paste(x, collapse="\n"), "\n")}
options(pager = pager_function)
//end.rcode
//begin.rcode, comment = ""
document::man("golden_ratio")
//end.rcode

Und zum Dritten und Wichtigsten: Du hast Deine Funktionen dokumentiert und ihre 
Schnittstellen beschrieben. Sie sind jetzt <<_paketieren,paketierungsreif>>.

=== Paketieren

Zum Paketieren nimmst Du wieder die getrennten Funktionsdateien, 
+src/golden_ratio.R+ und und +src/.golden_ratio.R+ und ihre zugeh&ouml;rigen Testdateien.

Damit sie den Paketanforderungen gen&uuml;gen, mu&szlig;t Du noch zwei kleine
&Auml;derungen vornehmen: +golden_ratio.R+ braucht noch einen
Verweis darauf, dass interne Funktionen in +golden_ratio_internals.R+ stehen

//begin.rcode
code <- c("#' @include golden_ratio_internals.R", "NULL", "",
          readLines(file.path("src", "golden_ratio.R")))
writeLines(code, file.path("src", "golden_ratio.R"))
//end.rcode
.src/golden_ratio.R
//begin.rcode, code = readLines(file.path("src", "golden_ratio.R")), eval = FALSE
//end.rcode

und die Dokumentation f&uuml;r +.golden_ratio+ sollte in eine Datei geschrieben
werden, deren Name nicht mit einem Punkt beginnt
(der Name der Hilfedatei wird, wenn Du ihn nicht explizit angibst, aus dem der
dokumentierten Funktion abgeleitet)

//begin.rcode
code <- readLines(file.path("src", ".golden_ratio.R"))
return_line <- grep("@return", code)
code_upper <- code[1:return_line]
code_lower <- code[(return_line + 1):length(code)]
code <- c(code_upper, "#' @rdname internals", code_lower)
writeLines(code, file.path("src", ".golden_ratio.R"))
//end.rcode
.src/.golden_ratio.R
//begin.rcode, code = readLines(file.path("src", ".golden_ratio.R")), eval = FALSE
//end.rcode



Du erstellst eine Paketvorlage und kopierst die Dateien hinein:

//begin.rcode, results = "hide", message = FALSE
# Create package skeleton
package_name <- "mytools"
package_dir <- file.path(dirname(tempdir()), package_name)
unlink(package_dir, recursive = TRUE) # make sure it's not there 
devtools::create(package_dir)
# add source files
file.copy(from = file.path("src", c("golden_ratio.R", ".golden_ratio.R")), 
          to = file.path(package_dir, "R"))
# rename the hidden file, package will not build otherwise:
file.rename(file.path(package_dir, "R", ".golden_ratio.R"), 
            file.path(package_dir, "R", "golden_ratio_internals.R"))
# create package's testing skeleton
devtools::use_testthat(package_dir)
# add test files
file.copy(from = file.path("src", c("test_golden_ratio.R", 
                                    "test_.golden_ratio.R")), 
                           file.path(package_dir, "tests", "testthat"))
# build the docs
roxygen2::roxygenize(package_dir)
# Set package Metadata
desc::desc_set_authors(person(given = "Your", family = "Name", 
                              role = c("aut", "cre"), 
                              email = "your.name@somewhe.re"), 
                       file = package_dir, normalize = TRUE)
desc::desc_bump_version("minor", package_dir)
## Fix some more metadata
d <- desc::desc(package_dir)
### Use title case
d$set(Title = tools::toTitleCase(d$get("Title")))
### Set package License
d$set(License = "GPL")
d$write()

//end.rcode

Nun kannst Du das Paket pr&uuml;fen:

//begin.rcode, results = "hide", message = FALSE
check <- rcmdcheck::rcmdcheck(package_dir, args = "--as-cran")
//end.rcode
//begin.rcode
print(check)
//end.rcode
Nun ja, Du hast die Metadaten noch nicht angepa&szlig;t. Solltest Du noch tun.

Du kannst Dein Paket auch testen:

//begin.rcode
covr::package_coverage(package_dir)
//end.rcode

Und Du solltest immer auch die Deine <<_weniger_schlecht_programmieren,drei Freunde>>  
fragen (wobei https://CRAN.R-project.org/package=lintr[lintr] hier die vorhandene Funktion
        +.golden_ratio()+ _nicht_ erkennt 
        footnote::[Das ist ein altes Problem, siehe https://github.com/jimhester/lintr/issues/27. Wenn Du mit +devtools::install(package_dir)+ das Paket installierst, verschwindet die falsch positive Warnung.] und https://CRAN.R-project.org/package=cyclocomp[cyclocomp] 
        ebenfalls nicht 
        footnote::[In Version 1.1.0 des Pakets ruft +cyclocomp::cyclocomp_package_dir+ die Funktion +cyclocomp::cyclocomp_package+ und diese +ls(asNamespace(package))+, wobei +package+ das aktuelle Paket, hier also "mytools", ist und +ls+ mit der Voreinstellung +all.names = FALSE+ Objekte mit einem f&uuml;hrenden Punkt nicht auflistet.]
        und daher keine +cyclomatic complexity+ f&uuml;r sie berechnet:

//begin.rcode
print(lintr::lint_package(package_dir))
print(suppressWarnings(cleanr::check_directory(package_dir)))
print(cyclocomp::cyclocomp_package_dir(package_dir))
//end.rcode

Gut! Das wird jetzt verpackt:
//begin.rcode
withr::with_dir(dirname(package_dir), 
                callr::rcmd_safe("build", basename(package_dir)))
package_path <- paste0(package_dir, "_0.1.0.tar.gz")
if (file.exists(package_path)) print(package_path)
//end.rcode

Paket fertig. Die Metadaten sind nat&uuml;rlich gelogen (Du solltest die Datei +DESCRIPTION+ anpassen, Du solltest eine Datei +NEWS.md+ pflegen, Du solltest ein https://de.wikipedia.org/wiki/Versionsverwaltung[version control system] benutzten), aber es funktional ist es korrekt.

== Bibliographie
[bibliography]
- [[[cc]]] R.C. Martin. 2008. 'Clean Code: A Handbook of Agile Software Craftsmanship'. 
    Pearson Education.
- [[[cyc]]]  T. J. McCabe, 1976. 'A Complexity Measure'
   IEEE Transactions on Software Engineering archive.
   Volume 2, Issue 4, Pages 308-320 

