= Funktionen Schreiben in **R**
Dominik Cullmann 
:toc2:
:numbered:
:data-uri:
:duration: 120

== Worum geht es?

=== Was sind Funktionen?

* Funktionen sind Programmkonstrukte, mit denen Du Teile des von Dir 
  geschriebenen Codes wiederverwenden kannst
  (siehe https://de.wikipedia.org/wiki/Funktion_(Programmierung)[Wikipedia]).
* Funktionen sind in den Standardbiliotheken jeder Programmiersprache vorhanden, 
  viele R-Funktionen kennst Du wahrscheinlich schon: `sum()`, `mean()` 
  oder `summary()`.

=== Warum Funktionen?

* Damit Du Teile des von Dir geschriebenen Codes wiederverwenden kannst.
* Dann musst Du, wenn Du Fehler im Code entdeckst, diesen auch nur an einer 
  Stelle korrigieren.

=== Wann Funktionen?

Immer wenn Du merkst, dass Du (alten) Code mehrfach kopierst und an anderer Stelle einf&uuml;gst und ihn kaum ver&auml;nderst, solltest Du dar&uuml;ber nachdenken, eine Funktion (oder mehrere) daraus zu machen. 


== Eine neue Summenfunktion f&uuml;r R

=== Warum wir diese Funktion nicht schreiben sollten

//begin_no_slide
Eine Summenfunktion gibt es wahrscheinlich in jeder Programmiersprache, in **R** hei&szlig;t sie `sum()`. Diese Funktion ist besser, stabiler und schneller, als alles, das wir selbst programmieren k&ouml;nnen.
//end_no_slide

=== Warum wir es trotzdem tun

//begin_no_slide
Ich habe die Summenberechnung ausf&uuml;hrlich als Beispiel zur Schleifenprogrammierung in 
https://fvafrcu.github.io/programmieren_in_r/#gute-schleifen[Programmieren in R] benutzt:
//end_no_slide


== Vom Code ...
//begin.rcode, eval = FALSE
include::src/sum.R[]
//end.rcode
//begin.rcode, include = FALSE
source("src/sum.R", local = knitr::knit_global())
//end.rcode

//begin_no_slide
Dabei siehst Du:
//end_no_slide

<1> Definition des zu summierenden Vektors
<2> Definition des zur Addition neutralen Elementes
<3> Schleife &uuml;ber den Vektor
<4> Addition
<5> Ausgabe des Ergebnisses

== ... zur Funktion
//begin_no_slide
F&uuml;r unsere Summenfunktion soll die Definition des zu summierenden Vektors
der Anwenderin &uuml;berlassen werden, daher wird der Vektor zu einem Argument
der Funktion. Ich w&auml;hle als Namen in diesem Fall +x+, das k&ouml;nnte aber
auch +a+ bleiben, es ist eine Frage der Konvention, und unter +x+ verstehen wir
meist eine Unbekannte. Und als Ausgabe verwenden wir keine Druck- sondern eine
R&uuml;ckgabefunktion (+return()+ statt +print()+). 
Das Ergebnis sieht dann so aus:

//end_no_slide



//begin.rcode, eval = FALSE
include::src/my_sum.R[]
//end.rcode
//begin.rcode, echo = FALSE
source("src/my_sum.R")
//end.rcode


== Scoping
== Scoping I //slide_only
.Ausgangszustand
//begin_no_slide
Objekte in **R** haben einen G&uuml;ltigkeitsbereich. Im Augenblick hat das Objekte +value+ den Wert +r value+:
//end_no_slide

//begin.rcode
print(value)
//end.rcode

.Funktionsausf&uuml;rung
//begin_no_slide
Jetzt wenden wir unsere Summenfunktion an und berechnen die Summe eines anderen Vektors: 
//end_no_slide
//begin.rcode
print(my_sum(1:3))
//end.rcode

//begin_no_slide
Das Objekt `value` beh&auml;lt seinen Wert:
//end_no_slide
//begin.rcode
print(value)
//end.rcode
//begin_no_slide
Und dass, obwohl wir innerhalb der Funktion dem Objekt +value+ in der ersten Zeile den Wert 0 zuweisen und diesen dann in der Schleife mit den Werten 1, 3 und 6 &uuml;berschreiben.
//end_no_slide

== Scoping II //slide_only

//begin_no_slide
.#TODO: add content


//end_no_slide
//begin.rcode, eval = FALSE
include::src/my_sum_scope1.R[]
//end.rcode
//begin.rcode, echo = FALSE
source("src/my_sum_scope1.R", local = knitr::knit_global())
//end.rcode
//begin.rcode
print(my_sum(1:3))
print(my_sum_broken(1:3))
//end.rcode

== Scoping III //slide_only
//begin.rcode
rm(value)
//end.rcode

//begin.rcode
print(my_sum_broken(1:3))
//end.rcode

== Argumente
Defaults

== Return Value und Side Effects
was ist was

== Modularisierung

== Funktionen verwalten

=== Lokal
Mit source

===  global 
Mit .Rprofile und einer Schleife

=== Als Package


== Typentests

//begin_no_slide
Neben +asserthat+ gibt es auch das R-Package +checkmate+.
//end_no_slide
assertthat und checkmate
//begin.rcode
assertthat::assert_that(is.numeric(6))
//end.rcode
//begin.rcode
assertthat::assert_that(is.numeric("This is a string."))
//end.rcode
//begin.rcode, eval = FALSE
include::src/my_sum_assertion.R[]
//end.rcode
//begin.rcode, echo = FALSE
source("src/my_sum_assertion.R")
//end.rcode

== Testing

//begin_no_slide
Neben +thestthat+ gibt es auch das R-Package +RUnit+.
//end_no_slide

=== Testthat

//begin.rcode
testthat::test_that("Simple test on summation.",
                    testthat::expect_identical(my_sum(c(2, 7)), 8)
                    )


//end.rcode
//begin.rcode, eval = FALSE
include::src/test_my_sum.R[]
//end.rcode
//begin.rcode, echo = FALSE
source("src/test_my_sum.R")
//end.rcode

=== Test Coverage

//begin.rcode
cov <- covr::file_coverage("src/my_sum_assertion.R", "src/test_my_sum_assertion.R")
print(cov)
//end.rcode

//begin.rcode
cov <- covr::file_coverage("src/my_sum_coverage.R", "src/test_my_sum_assertion.R")
print(cov)
//end.rcode

//begin.rcode
covr::zero_coverage(cov)
//end.rcode

== cleanr


== Funktionen dokumentieren
