= Funktionen Schreiben in **R**
Dominik Cullmann 
:toc2:
:numbered:
:data-uri:
:duration: 120

//begin_only_slide
== Skript
https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]
//end_only_slide

== Worum geht es?

//begin_no_slide
Naja, ums Schreiben von Funktionen in der Programmiersprache **R**.
//end_no_slide

=== Was sind Funktionen?

* Funktionen sind Programmkonstrukte, mit denen Du Teile des von Dir 
  geschriebenen Codes wiederverwenden kannst
  (siehe https://de.wikipedia.org/wiki/Funktion_(Programmierung)[Wikipedia]).
* Funktionen sind in den Standardbiliotheken jeder Programmiersprache vorhanden, 
  viele R-Funktionen kennst Du wahrscheinlich schon: `sum()`, `mean()` 
  oder `summary()`.

=== Warum Funktionen?

* Damit Du Teile des von Dir geschriebenen Codes wiederverwenden kannst.
* Dann musst Du, wenn Du Fehler im Code entdeckst, diese auch nur an einer 
  Stelle korrigieren.

=== Wann Funktionen?

Immer wenn Du merkst, dass Du (alten) Code mehrfach kopierst und an anderer
Stelle einfügst ohne ihn stark zu verändern, solltest Du darüber nachdenken, 
eine Funktion (oder mehrere) aus ihm  zu schreiben. 


== Eine neue Summenfunktion für R

=== Warum wir diese Funktion nicht schreiben sollten

//begin_no_slide
Eine Summenfunktion gibt es wahrscheinlich in jeder Programmiersprache, in **R**
heißt sie `sum()`. Diese Funktion ist besser, stabiler und schneller, als
alles, das wir selbst programmieren können.
//end_no_slide

=== Warum wir es trotzdem tun

//begin_no_slide
Nunja, irgendwelchen Code müssen wir ja nehmen.  
Ich habe die Summenberechnung ausführlich als Beispiel zur Schleifenprogrammierung in 
https://fvafrcu.github.io/programmieren_in_r/#gute-schleifen[Programmieren in R] benutzt, 
    und eine Wiederholung schadet sicher nicht.
//end_no_slide


== Vom Code ...

[source,r]
----
a  <- c(2, 3, 4, 10) # <1>
value <- 0 # <2>
for (a_i in a) { # <3>
    value <- value + a_i  # <4>
}
print(value) # <5>
----

----
## [1] 19
----


//begin_no_slide
Dabei siehst Du:
//end_no_slide

<1> Definition des zu summierenden Vektors
<2> Definition des zur Addition neutralen Elementes
<3> Schleife über die Elemente des Vektors
<4> Addition des aktuellen Vektorelementes zum Ergebnis
<5> Ausgabe des Ergebnisses

== ... zur Funktion

//begin_no_slide
Für unsere Summenfunktion soll die Definition des zu summierenden Vektors
der Anwenderin überlassen werden, daher wird der Vektor zu einem Argument
der Funktion. Ich wähle als Namen für das Argument jetzt +x+, das könnte aber
auch +a+ bleiben, es ist eine Frage der Konvention, und unter +x+ verstehen wir
meist eine Unbekannte. Und als Ausgabe verwenden wir keine Druck- sondern eine
Rückgabefunktion (+return()+ statt +print()+). 
Das Ergebnis sieht dann so aus:

//end_no_slide




[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



== Scoping
Programmiersprachen kennen für Objekte unterschiedliche Gültigkeitsbereiche 
(englisch "scope"), wir sehen uns das am Beispiel an:

== Scoping I //slide_only
=== Schreibzugriffe
.Ausgangszustand
//begin_no_slide
Im Augenblick hat das Objekte +value+ den Wert 19:
//end_no_slide


[source,r]
----
print(value)
----

----
## [1] 19
----


.Funktionsausführung
//begin_no_slide
Jetzt wenden wir unsere Summenfunktion an und berechnen die Summe eines anderen Vektors: 
//end_no_slide

[source,r]
----
print(my_sum(1:3))
----

----
## [1] 6
----


//begin_no_slide
Das Objekt `value` behält seinen Wert:
//end_no_slide

[source,r]
----
print(value)
----

----
## [1] 19
----

//begin_no_slide
Und das, obwohl wir innerhalb der Funktion dem Objekt +value+ in der ersten
Zeile den Wert 0 zuweisen und diesen dann in der Schleife mit den Werten 1, 3
und 6 überschreiben:
**R** verwaltet automatisch die Gültigkeitsbereiche aller Objekte. 
Es gibt daher ein Objekt names  +value+ außerhalb der Funktion, das den Wert 19 enthält und unverändert bleibt.
Innerhalb der Funktion legt **R** ein neues lokales Objekt, ebenfalls mit dem Namen
+value+, an.
Du _kannst_ auch aus einer Funktion in einen <<_arbeiten_mit_gültigkeitsbereichen, anderen Gültigkeitsbereich>> schreiben, wenn Du das wirklich willst.
//end_no_slide

== Scoping II //slide_only

=== Lesezugriffe
.Lesen ist unsicher
//begin_no_slide
Mit dem Namen eines Objektes wird dieses gelesen, innerhalb einer Funktion sucht
**R** zunächst nach einem lokalen Objekt des gesuchten Namens, dann in den der
Funktion übergeordneten Gültigkeitsbereichen, also außerhalb der Funktion.

Das kann zu unerwünschten Nebeneffekten führen. Stell Dir vor, Du kommentierst 
beim Schreiben der Summenfunktion die Definition des zur Addition neutralen
Elementes aus Versehen aus:
//end_no_slide

[source,r]
----
my_sum_broken <- function(x) {
    # FIXME: this is accidentally commented out:
    # value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----

//begin_no_slide

Du führst die Funktion aus und erhälst:
//end_no_slide

[source,r]
----
print(my_sum_broken(1:3))
----

----
## [1] 25
----

Was ist passiert?
//begin_no_slide
Im ersten Durchlauf der Schleife gibt es beim Lesen von
+value+ noch kein lokales Objekt dieses Namens. Daher sucht **R** außerhalb der
Funktion und findet ein Objekt mit dem Wert 19. 
Zu diesem Objekt addieren
wir +x_i+, das im ersten Schleifendurchlauf den Wert +1+ enthält und erschaffen
damit in der Funktion ein lokales Objekt names +value+, das dann im zweiten
Durchlauf der Schleife auch gelesen werden kann.
//end_no_slide

== Scoping III //slide_only
//begin_no_slide
Wenn Du diese Funktion verwendest, ohne vorher das Objekt +value+ zu definieren,
oder das Objekt +value+ entfernst und dann die Funktion ausführst
//end_no_slide

[source,r]
----
rm(value)
print(my_sum_broken(1:3))
----

[source,r]
----
## Error in my_sum_broken(1:3): object 'value' not found

----

//begin_no_slide
erhälst Du einen Fehler, weil **R** auch außerhalb der Funktion kein Objekt
names +value+ finden kann. Und diesen Fehler erwarten wir ja eigentlich, wenn 
wir nur die Funktion betrachten: sie ist fehlerhaft.
//end_no_slide

== Scoping IV //slide_only
.Sicherer Lesen
//begin_no_slide
Wie wir eine Funktion dazu bringen können, außerhalb ihres Gültigkeitsbereiches
zu schreiben (nein, das _wie_ habe ich Dir noch nicht gezeigt... ), so können wir 
eine Funktion auch zwingen, beim Lesen nur nach lokalen Objekten zu
suchen:
//end_no_slide

[source,r]
----
my_sum_safer <- function(x) {
    for (x_i in x) {
        value <- get("value", inherits = FALSE) + x_i 
    }
    return(value)
}
----


//begin_no_slide
Selbst wenn wir ein Objekt namens +value+ anlegen, gibt die Funktion nun einen
Fehler aus:
//end_no_slide

[source,r]
----
value <- 42
my_sum_safer(1:10)
----

[source,r]
----
## Error in get("value", inherits = FALSE): object 'value' not found

----

//begin_no_slide
Ich finde es aber praktiabler, beim Schreiben einer Funktion darauf zu achten,
welche Objekte ich lese. + 
Und wenn Du Funktionen <<_testing,testest>>, findest Du Fehler, die auf Scoping beruhen,
sehr schnell. 
//end_no_slide


== Arbeiten mit Gültigkeitsbereiche (environments) //slide_only
=== Arbeiten mit Gültigkeitsbereichen 

//begin_no_slide
Ein Befehl, mit dem Du alle Objekte Deines aktuellen Arbeitsbereiches löschen
kannst (entsprechend dem RStudio-Knopf mit dem Besensymbol footnote:[Im https://github.com/rstudio/rstudio/releases/tag/v1.1.426[Code von RStudio v1.1.426] findet sich die Funktion hinter dem Knopf  in der Datei src/cpp/session/modules/SessionEnvironment.R, sie besteht im wesentlichen aus der Zeile +
rm(list=ls(envir=env, all.names=includeHidden), envir=env) +
Sie wird in src/cpp/session/modules/environment/SessionEnvironment.cpp in der C++-Funktion  removeAllObjects aufgerufen.
]) lautet:
//end_no_slide


[source,r]
----
rm(list = ls(all.names = TRUE))
----

//begin_no_slide
Nun  bin ich
vergesslich, weshalb ich mir die Syntax schlecht merken kann und lieber eine
Funktion (aber keinen Knopf) hätte.
Da "der aktuelle Arbeitsbereich" ein Gültigkeitsbereich 
(in **R** heissen die Gültigkeitsbereiche "environments", in **S** hiessen sie "frames") ist, und die 
Funktionen  `ls` und `rm` nur in _einem_ Gültigkeitsbereich arbeiten, funktioniert das naheliegende
//end_no_slide

[source,r]
----
wipe_clean <- function() {
    rm(list = ls(all.names = TRUE))
}
----

//begin_no_slide
*nicht*.

Wenn ich den Gültigkeitsbereich explizit 
//end_no_slide

[source,r]
----
wipe_clean <- function() {
    rm(list = ls(name = parent.frame(), all.names = TRUE), envir = parent.frame())
}
----

//begin_no_slide
angebe, tut die Funktion, was ich wollte:
//end_no_slide

[source,r]
----
ls()
----

----
## [1] "a"             "a_i"           "my_sum"        "my_sum_broken"
## [5] "my_sum_safer"  "value"         "wipe_clean"
----

[source,r]
----
wipe_clean()
ls()
----

----
## character(0)
----





== Argumente

//begin_no_slide
Funktionen kennen Argmumente, am besten nicht zu viele (siehe zum Beispiel <<cc>>). 
Unsere Summenfunktion kennt beispielsweise eines, nämlich den Vektor, den sie summieren soll. Der ist also ein obligatorisches Element, er hat keine Voreinstellung.

Eine Funktion, die, wie `wipe_clean`, kein Argument kennt, ist Folgende:
//end_no_slide



[source,r]
----
memory_hogs <- function() {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    return(z)
}
----


Diese Funktion gibt mir für jedes Objekt des Gültigkeitsbereiches, in dem ich sie aufrufe, den Speicherverbrauch aus.


[source,r]
----
va <- rep(mtcars, 1)
vb <- rep(mtcars, 1000)
vc <- rep(mtcars, 2000)
vd <- rep(mtcars, 100)
memory_hogs()
----

----
## memory_hogs          va          vb          vc          vd 
##        7576        4232     3432720     6864720      343920
----


Bei so wenigen Objekten erkenne ich gleich, dass `vc` der größte Speicherfresser ist, und ich, falls mir der Speicher platzt und ich `vc` nicht mehr unbedingt brauche, `vc` löschen sollte.

Aber wenn ich viele Objekte habe, wäre es doch schön, ein optionales Funktionsargument zu haben, dass in seiner Voreinstellung die Ausgabe nach Größe des Speicherbedarfs sortiert:


[source,r]
----
memory_hogs <- function(order = TRUE) {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    if (order) z <- z[order(z)]
    return(z)
}
----



[source,r]
----
memory_hogs()
----

----
##          va memory_hogs          vd          vb          vc 
##        4232        9576      343920     3432720     6864720
----


Das ist ein klassisches Steuerargument, dass das Verhalten einer Funktion steuert.


[source,r]
----
memory_hogs <- function(...) {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    if (! missing(...)) {
      z <- z[order(z, ...)]
    }
    return(z)
}
----



[source,r]
----
memory_hogs()
----

----
## memory_hogs          va          vb          vc          vd 
##       13080        4232     3432720     6864720      343920
----

[source,r]
----
memory_hogs(decreasing = TRUE)
----

----
##          vc          vb          vd memory_hogs          va 
##     6864720     3432720      343920       48048        4232
----


Anwendung:

[source,r]
----
rm(list = names(memory_hogs(decreasing = TRUE)[1:2]))
memory_hogs(decreasing = TRUE)
----

----
##          vd memory_hogs          va 
##      343920       48048        4232
----


== Return Value und Side Effects

[source,r]
----
wipe_clean <- function(environment = parent.frame()) {
    objects <- ls(name = environment, all.names = TRUE)
    rm(list = objects, envir = environment)
    return(invisible(objects))
}
----


[source,r]
----
print(wipe_clean())
----

----
## [1] "memory_hogs" "va"          "vd"          "wipe_clean"
----

[source,r]
----
ls()
----

----
## character(0)
----




== Modularisierung

== Funktionen verwalten

=== Lokal
Mit source

===  global 
Mit .Rprofile und einer Schleife

=== Als Package
Das ist am aufwendigsten, aber auch am elegantesten.

== Argumententests

=== Typentests

//begin_no_slide
Neben +asserthat+ gibt es auch das R-Package +checkmate+.
//end_no_slide
assertthat und checkmate

[source,r]
----
assertthat::assert_that(is.numeric(6))
----

----
## [1] TRUE
----


[source,r]
----
assertthat::assert_that(is.numeric("This is a string."))
----

[source,r]
----
## Error: "This is a string." is not a numeric or integer vector

----


[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----


=== Auswahllisten
match.arg

== Testing

//begin_no_slide
Neben +testthat+ gibt es auch das R-Package +RUnit+.
//end_no_slide

=== Testthat


[source,r]
----
testthat::test_that("Simple test on summation.",
                    testthat::expect_identical(my_sum(c(2, 7)), 8)
                    )
----

[source,r]
----
## Error: Test failed: 'Simple test on summation.'
## * my_sum(c(2, 7)) not identical to 8.
## 1/1 mismatches
## [1] 9 - 8 == 1

----


[source,r]
----
testthat::test_that("Simple test on summation.",
                    testthat::expect_identical(my_sum(c(2, 7)), 9)
                    )
----


=== Test Coverage


[source,r]
----
cov <- covr::file_coverage("src/my_sum_assertion.R", "src/test_my_sum_assertion.R")
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/my_sum_assertion.R: 100.00%

----



[source,r]
----
cov <- covr::file_coverage("src/my_sum_coverage.R", "src/test_my_sum_assertion.R")
print(cov)
----

[source,r]
----
## Coverage: 83.33%

----

[source,r]
----
## src/my_sum_coverage.R: 83.33%

----



[source,r]
----
covr::zero_coverage(cov)
----

----
##                filename functions line value
## 2 src/my_sum_coverage.R    my_sum    3     0
----


== cleanr


== Funktionen dokumentieren

[source,r]
----
#' Remove All Objects From an Environment
#'
#' @param environment The environment to be wiped.
#' @return A character vector containing the names of objects removed.
#' @export
wipe_clean <- function(environment = parent.frame()) {
    objects <- ls(name = environment, all.names = TRUE)
    rm(list = objects, envir = environment)
    return(invisible(objects))
}
----

== Bibliographie
[bibliography]
- [[[cc]]] R.C. Martin. 2008. 'Clean Code: A Handbook of Agile Software Craftsmanship'. 
    Pearson Education.

