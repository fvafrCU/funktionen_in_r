= Funktionen Schreiben in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:numbered:
:data-uri:
:duration: 120

//begin_only_slide
== Skript
https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]
//end_only_slide

== Worum geht es?

//begin_no_slide
Naja, ums Schreiben von Funktionen in der Programmiersprache **R**.
//end_no_slide



=== Was sind Funktionen?

* Funktionen sind Programmkonstrukte, mit denen Du Teile des von Dir 
  geschriebenen Codes wiederverwenden kannst
  (siehe https://de.wikipedia.org/wiki/Funktion_(Programmierung)[Wikipedia]).
* Funktionen sind in den Standardbiliotheken jeder Programmiersprache vorhanden, 
  viele R-Funktionen kennst Du wahrscheinlich schon: `sum()`, `mean()` 
  oder `summary()`.

=== Warum Funktionen?

* Damit Du Teile des von Dir geschriebenen Codes wiederverwenden kannst.
* Damit Du, wenn Du Fehler im Code entdeckst, diese auch nur an einer 
  Stelle korrigieren musst.

=== Wann Funktionen?

Immer wenn Du merkst, dass Du (alten) Code mehrfach kopierst und an anderer
Stelle einfügst ohne ihn stark zu verändern, solltest Du darüber nachdenken, 
eine (oder mehrere) Funktion(en)  aus ihm  zu machen. 


== Eine Funktion schreiben
== Eine neue Summenfunktion //slide_only
=== Eine neue Summenfunktion //no_slide

.Warum wir diese Funktion nicht schreiben sollten

//begin_no_slide
Eine Summenfunktion gibt es wahrscheinlich in jeder Programmiersprache, in **R**
heißt sie `sum()`. Diese Funktion ist besser, stabiler und schneller, als
alles, das wir selbst programmieren können.
//end_no_slide

.Warum wir es trotzdem tun

//begin_no_slide
Nunja, irgendwelchen Code müssen wir ja nehmen.  
Ich habe die Summenberechnung ausführlich als Beispiel zur Schleifenprogrammierung in 
https://fvafrcu.github.io/programmieren_in_r/#gute-schleifen[Programmieren in R] benutzt, 
    und eine Wiederholung schadet sicher nicht.
//end_no_slide


== Vom Code ... //slide_only
=== Vom Code ... //no_slide

[source,r]
----
a  <- c(2, 3, 4, 10) # <1>
value <- 0 # <2>
for (a_i in a) { # <3>
    value <- value + a_i  # <4>
}
print(value) # <5>
----

----
## [1] 19
----


//begin_no_slide
Dabei siehst Du:
//end_no_slide

<1> Definition des zu summierenden Vektors
<2> Definition des zur Addition neutralen Elementes
<3> Schleife über die Elemente des Vektors
<4> Addition des aktuellen Vektorelementes zum Ergebnis
<5> Ausgabe des Ergebnisses

== ... zur Funktion //slide_only
=== ... zur Funktion //no_slide

//begin_no_slide
Für unsere Summenfunktion soll die Definition des zu summierenden Vektors
der Anwenderin überlassen werden, daher wird der Vektor zu einem Argument
der Funktion. Ich wähle als Namen für das Argument jetzt +x+, das könnte aber
auch +a+ bleiben, es ist eine Frage der Konvention, und unter +x+ verstehen wir
meist eine Unbekannte. Und als Ausgabe verwenden wir keine Druck- sondern eine
Rückgabefunktion (+return()+ statt +print()+). 
Das Ergebnis sieht dann so aus:

//end_no_slide




[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



=== Scoping //no_slide
== Scoping I //slide_only
//begin_no_slide
Programmiersprachen kennen für Objekte unterschiedliche Gültigkeitsbereiche 
(englisch "scope"), wir sehen uns das am Beispiel an:
//end_no_slide
==== Schreibzugriffe
.Ausgangszustand
//begin_no_slide
Im Augenblick hat das Objekte +value+ den Wert 19:
//end_no_slide


[source,r]
----
print(value)
----

----
## [1] 19
----


.Funktionsausführung
//begin_no_slide
Jetzt wenden wir unsere Summenfunktion an und berechnen die Summe eines anderen Vektors: 
//end_no_slide

[source,r]
----
print(my_sum(1:3))
----

----
## [1] 6
----


//begin_no_slide
Das Objekt `value` behält seinen Wert:
//end_no_slide

[source,r]
----
print(value)
----

----
## [1] 19
----

//begin_no_slide
Und das, obwohl wir innerhalb der Funktion dem Objekt +value+ in der ersten
Zeile den Wert 0 zuweisen und diesen dann in der Schleife mit den Werten 1, 3
und 6 überschreiben:
**R** verwaltet automatisch die Gültigkeitsbereiche aller Objekte. 
Es gibt daher ein Objekt names  +value+ außerhalb der Funktion, das den Wert 19 enthält und unverändert bleibt.
Innerhalb der Funktion legt **R** ein neues lokales Objekt, ebenfalls mit dem Namen
+value+, an.
Du _kannst_ auch aus einer Funktion in einen <<_arbeiten_mit_gültigkeitsbereichen, anderen Gültigkeitsbereich>> schreiben, wenn Du das wirklich willst.
//end_no_slide

== Scoping II //slide_only

==== Lesezugriffe
.Lesen ist unsicher
//begin_no_slide
Mit dem Namen eines Objektes wird dieses gelesen, innerhalb einer Funktion sucht
**R** zunächst nach einem lokalen Objekt des gesuchten Namens, dann in den der
Funktion übergeordneten Gültigkeitsbereichen, also außerhalb der Funktion.

Das kann zu unerwünschten Nebeneffekten führen. Stell Dir vor, Du kommentierst 
beim Schreiben der Summenfunktion die Definition des zur Addition neutralen
Elementes aus Versehen aus:
//end_no_slide

[source,r]
----
my_sum_broken <- function(x) {
    # FIXME: this is accidentally commented out:
    # value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----

//begin_no_slide

Du führst die Funktion aus und erhälst:
//end_no_slide

[source,r]
----
print(my_sum_broken(1:3))
----

----
## [1] 25
----

Was ist passiert?
//begin_no_slide
Im ersten Durchlauf der Schleife gibt es beim Lesen von
+value+ noch kein lokales Objekt dieses Namens. Daher sucht **R** außerhalb der
Funktion und findet ein Objekt mit dem Wert 19. 
Zu diesem Objekt addieren
wir +x_i+, das im ersten Schleifendurchlauf den Wert +1+ enthält und erschaffen
damit in der Funktion ein lokales Objekt names +value+, das dann im zweiten
Durchlauf der Schleife auch gelesen werden kann.
//end_no_slide

== Scoping III //slide_only
//begin_no_slide
Wenn Du diese Funktion verwendest, ohne vorher das Objekt +value+ zu definieren,
oder das Objekt +value+ entfernst und dann die Funktion ausführst
//end_no_slide

[source,r]
----
rm(value)
print(my_sum_broken(1:3))
----

[source,r]
----
## Error: object 'value' not found

----

//begin_no_slide
erhälst Du einen Fehler, weil **R** auch außerhalb der Funktion kein Objekt
names +value+ finden kann. Und diesen Fehler erwarten wir ja eigentlich, wenn 
wir nur die Funktion betrachten: sie ist fehlerhaft.
//end_no_slide

== Scoping IV //slide_only
.Sicherer Lesen
//begin_no_slide
Wie wir eine Funktion dazu bringen können, außerhalb ihres Gültigkeitsbereiches
zu schreiben (nein, das _wie_ habe ich Dir noch nicht gezeigt... ), so können wir 
eine Funktion auch zwingen, beim Lesen nur nach lokalen Objekten zu
suchen:
//end_no_slide

[source,r]
----
my_sum_safer <- function(x) {
    for (x_i in x) {
        value <- get("value", inherits = FALSE) + x_i 
    }
    return(value)
}
----


//begin_no_slide
Selbst wenn wir ein Objekt namens +value+ anlegen, gibt die Funktion nun einen
Fehler aus:
//end_no_slide

[source,r]
----
value <- 42
my_sum_safer(1:10)
----

[source,r]
----
## Error in get("value", inherits = FALSE): object 'value' not found

----

//begin_no_slide
Ich finde es aber praktiabler, beim Schreiben einer Funktion darauf zu achten,
welche Objekte ich lese. + 
Und wenn Du Funktionen <<_testing,testest>>, findest Du Fehler, die auf Scoping beruhen,
sehr schnell. 
//end_no_slide


== Arbeiten mit Gültigkeitsbereiche (environments) //slide_only
==== Arbeiten mit Gültigkeitsbereichen //no_slide

//begin_no_slide
Ein Befehl, mit dem Du alle Objekte Deines aktuellen Arbeitsbereiches löschen
kannst (entsprechend dem RStudio-Knopf mit dem Besensymbol footnote:[Im https://github.com/rstudio/rstudio/releases/tag/v1.1.426[Code von RStudio v1.1.426] findet sich die Funktion hinter dem Knopf  in der Datei src/cpp/session/modules/SessionEnvironment.R, sie besteht im wesentlichen aus der Zeile +
rm(list=ls(envir=env, all.names=includeHidden), envir=env) +
Sie wird in src/cpp/session/modules/environment/SessionEnvironment.cpp in der C++-Funktion  removeAllObjects aufgerufen.
]) lautet:
//end_no_slide


[source,r]
----
rm(list = ls(all.names = TRUE))
----

//begin_no_slide
Nun  bin ich
vergesslich, weshalb ich mir die Syntax schlecht merken kann und lieber eine
Funktion (aber keinen Knopf) hätte.
Da "der aktuelle Arbeitsbereich" ein Gültigkeitsbereich 
(in **R** heissen die Gültigkeitsbereiche "environments", in **S** hie&szlig;en sie "frames") ist, und die 
Funktionen  `ls` und `rm` nur in _einem_ Gültigkeitsbereich arbeiten, funktioniert das naheliegende
//end_no_slide

[source,r]
----
wipe_clean <- function() {
    rm(list = ls(all.names = TRUE))
}
----

//begin_no_slide
*nicht*.

Wenn ich den Gültigkeitsbereich explizit 
//end_no_slide

[source,r]
----
wipe_clean <- function() {
    rm(list = ls(name = parent.frame(), all.names = TRUE), envir = parent.frame())
}
----

//begin_no_slide
angebe, tut die Funktion, was ich wollte:
//end_no_slide

[source,r]
----
ls()
----

----
## [1] "a"             "a_i"           "my_sum"        "my_sum_broken"
## [5] "my_sum_safer"  "tmp"           "value"         "wipe_clean"
----

[source,r]
----
wipe_clean()
ls()
----

----
## character(0)
----





== Argumente //slide_only
=== Argumente//no_slide

//begin_no_slide
Funktionen kennen Argmumente, am besten nicht zu viele (siehe zum Beispiel <<cc>>). 
Unsere Summenfunktion kennt beispielsweise eines, nämlich den Vektor, den sie summieren soll. Der ist also ein obligatorisches Element, er sollte keine Voreinstellung haben (und hat auch keine).


Eine Funktion, die, wie `wipe_clean`, kein Argument kennt, ist Folgende:
//end_no_slide



[source,r]
----
memory_hogs <- function() {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    return(z)
}
----


//begin_no_slide
Diese Funktion gibt mir für jedes Objekt des Gültigkeitsbereiches, in dem ich sie aufrufe, den Speicherverbrauch aus.
//end_no_slide


[source,r]
----
va <- rep(mtcars, 1)
vb <- rep(mtcars, 1000)
vc <- rep(mtcars, 2000)
vd <- rep(mtcars, 100)
memory_hogs()
----

----
## memory_hogs          va          vb          vc          vd 
##        7576        4232     3432720     6864720      343920
----


//begin_no_slide
Bei so wenigen Objekten erkenne ich leicht, dass `vc` der größte Speicherfresser ist, und ich, falls mir der Speicher platzt und ich `vc` nicht mehr unbedingt brauche, `vc` löschen sollte.

Aber wenn ich viele Objekte habe, wäre es doch schön, ein optionales Funktionsargument zu haben, dass in seiner Voreinstellung die Ausgabe nach Größe des Speicherbedarfs sortiert:
//end_no_slide


[source,r]
----
memory_hogs <- function(order = TRUE) {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    if (order) z <- z[order(z)]
    return(z)
}
----



[source,r]
----
memory_hogs()
----

----
##          va memory_hogs          vd          vb          vc 
##        4232        9576      343920     3432720     6864720
----


//begin_no_slide
Das ist ein klassisches (optionales) Steuerargument, das das Verhalten einer Funktion steuert.
Steuerargumente sollten eine sinnvolle Voreinstellung haben.

Da die `memory_hogs` intern nun die Funktion `order` aufruft, k&ouml;nnten wir ja auf die Idee kommen, dieser Funktion Argumente weiterreichen zu wollen. 
Das k&ouml;nnen wir entweder explizit tun, oder wir benutzen ein spezielles, _Ellipsis_ genanntes Argument, das durch drei Punkte (`...`) aufgerufen wird:
//end_no_slide


[source,r]
----
memory_hogs <- function(...) {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    if (! missing(...)) {
      z <- z[order(z, ...)]
    }
    return(z)
}
----



[source,r]
----
memory_hogs()
----

----
## memory_hogs          va          vb          vc          vd 
##       13080        4232     3432720     6864720      343920
----

[source,r]
----
memory_hogs(decreasing = TRUE)
----

----
##          vc          vb          vd memory_hogs          va 
##     6864720     3432720      343920       13080        4232
----


//begin_no_slide
Jetzt k&ouml;nnen wir die R&uuml;ckgabe unserer Funktion nutzen, um die beiden gr&ouml;&szlig;ten Speicherfresser zu l&ouml;schen:
//end_no_slide


[source,r]
----
rm(list = names(memory_hogs(decreasing = TRUE)[1:2]))
memory_hogs()
----

----
## memory_hogs          va          vd 
##       13080        4232      343920
----


Wir k&ouml;nnen also, wenn wir wollen, drei Arten von Argumenten unterscheiden:

- Obligatorische. Sie sollten keine Voreinstellungen kennen und &uuml;bergeben &uuml;blicherweise Objekte, die von der Funktion verarbeitet werden sollen.
- Optionale. Sie sollten Voreinstellungen kennen und dienen &uuml;blicherweise der Steuerung der Funktion.
- Die _Ellipsis_, um Argumente an andere Funktionen weiterzureichen.

== Return Value und Side Effects //slide_only
=== Return Value und Side Effects//no_slide
//begin_no_slide
Jede Funktion in **R** gibt einen Wert zur&uuml;ck, falls sie nicht mit einem Fehler abbricht.
Wenn wir keinen R&uuml;ckgabewert (return value) explizit angeben, ist er automatisch der Wert des letzten in der Funktion ausgewerteten Ausdrucks, also der letzte Wert, der wie auch immer berechnet oder zur&uuml;ckgegeben wurde.
Es ist daher sicher nicht schlecht, wenn Du versucht, den R&uuml;ckgabewert explizit anzugeben.
Unsere Summenfunktion k&ouml;nnte auch so aussehen:
//end_no_slide


[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
}
----


//begin_no_slide
Das ist zwar (um eine Zeile) k&uuml;rzer und inhaltsgleich, aber weniger offentsichtlich. Und damit weniger gut lesbar.
Und damit mehr schlechter als eine Zeile k&uuml;rzer mehr besser ist, capisce?

Komplexere Funktionen haben oft Nebenwirkungen (side effects)
Bei vielen dieser Funktionen sind die Nebenwirkungen der eigentliche Zweck der Funktion, manchmal ist R&uuml;ckgabewert sogar belanglos. Die Funktion `rm` gibt beispielsweise unsichtbar `NULL` zur&uuml;ck (und das selbst dann, wenn es gar nichts zu l&ouml;schen gibt), das erkennen wir, wenn wir ihren R&ouml;ckgabewert explizit drucken:
//end_no_slide

[source,r]
----
a <- "This is a string"
print(rm(a))
----

----
## NULL
----

[source,r]
----
print(rm())
----

----
## NULL
----

//begin_no_slide

Das hei&szlig;t also, dass unsere Funktion `wipe_clean` den Wert `invisible(NULL)`, zur&uuml;ckgibt, denn das war der Wert des letzten in ihr ausgewerteten Ausdrucks (der Aufruf der Funktion `rm`).

Das k&ouml;nnen wir &auml;ndern, indem wir einen expliziten R&uuml;ckgabewert einbauen (bei der Gelegenheit wandeln wir gleich noch den G&uuml;tigkeitsbereich, indem die Funktion l&auml;scht, in ein Steuerargument mit Voreinstellung um):
//end_no_slide


[source,r]
----
wipe_clean <- function(environment = parent.frame()) {
    objects <- ls(name = environment, all.names = TRUE)
    rm(list = objects, envir = environment)
    return(invisible(objects))
}
----


[source,r]
----
print(wipe_clean())
----

----
## [1] "memory_hogs" "my_sum"      "va"          "vd"          "wipe_clean"
----

[source,r]
----
ls()
----

----
## character(0)
----

Jetzt gibt die Funktion die Namen der von ihr gel&ouml;schten Objekte zur&uuml;ck. Wir wissen also, wie hie&szlig;, was wir gel&ouml;scht haben. Damit k&ouml;nnen wir zwar nichts mehr anfangen, aber die Fnktion hat nun genau einen expliziten Endpunkt. Das ist immerhin schön übersichtlich.


== Funktionen verwalten //slide_only
=== Funktionen verwalten//no_slide

==== Lokal
Mit source

====  Global 
Mit .Rprofile und einer Schleife

==== Als Package
Das ist am aufwendigsten, aber auch am elegantesten.


== Weniger schlecht programmieren

== Argumententests //slide_only
=== Argumententests//no_slide
Wir haben verschiedene Möglichkeiten, die Objekte, die wir den Argumenten einer Funktion übergeben, zu testen.


== Typentests //slide_only
==== Typentests//no_slide

//begin_no_slide
Wir k&ouml;nnen Objekte darauf testen, ob sie einem bestimmten Typ (einer Klasse) angeh&ouml;ren; 
bei Objekten, die einer Funktion als Argument &uuml;bergeben werden ist dies besonders ratsam.
Das geht mir reinen +base R+, ist aber eher umst&auml;ndlich,
die https://cran.r-project.org/web/packages/checkmate/vignettes/checkmate.html#intro[Vignette zu +checkmate+] 
bietet ein anschauliches Bespiel.

Ich kenne zwei Packages, die Typentest vereinfachen: +assertthat+ und +checkmate+.

- +checkmate+ ist hauptsächlich in C geschrieben, sehr schnell, 
sehr flexibel mit unterschiedlichen Testarten ("checks", "asserts" und "tests"), 
hat aber viele Abhängigkeiten und ist etwas sperrig: sein Manual ist &uuml;ber 100 Seiten lang. 
- +assertthat+ ist reines R ohne irgendwelche Abhängigkeiten und recht &uuml;bersichtlich.

+assertthat+ ist sehr einfach:
//end_no_slide

[source,r]
----
x <- 6
assertthat::assert_that(is.numeric(x))
----

----
## [1] TRUE
----


[source,r]
----
x <- "This is a string."
assertthat::assert_that(is.numeric(x))
----

[source,r]
----
## Error: x is not a numeric or integer vector

----


.Was haben wir davon?
Wenn wir unserer Summenfunktion 


[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----


ein nicht-numerisches Argument &uuml;bergeben, erhalten wir eine recht kryptische Fehlermeldung:


[source,r]
----
my_sum(c("a", "b"))
----

[source,r]
----
## Error in value + x_i: non-numeric argument to binary operator

----



Durch den Einbau eines Typentests 


[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----

wird die Meldung deutlich verst&auml;ndlicher:

[source,r]
----
my_sum(c("a", "b"))
----

[source,r]
----
## Error: x is not a numeric or integer vector

----


Mit +checkmate+ k&ouml;nnen wir sogar erzwingen, dass x nicht nur numerisch sein muss,
sondern auch mindestens zwei Elemente haben soll. Eine Summe einer Zahl ist ja etwas albern:

[source,r]
----
my_sum <- function(x) {
    checkmate::qassert(x, "n>=2")
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



[source,r]
----
my_sum(42)
----

[source,r]
----
## Error in rasciidoc::render_slides("index.Rasciidoc"): Assertion on 'x' failed. Must be of length >= 2, but has length 1.

----


_Ich nutze Typentests oft in Funktionen. Da +checkmate+ deutlich mehr Funktionalit&auml;t bietet, nutzte ich +assert_that+ eher selten._

== Auswahllisten //slide_only
==== Auswahllisten//no_slide
Mit Auswahllisten k&ouml;nnen wir Objekte darauf testen, ob sie eine von mehreren M&ouml;glichkeiten
enthalten. Das ist vor allem f&uuml;r Steuerargumente hilfreich.
+base R+ kennt +match.arg+, das mit alphanumerischen Vektoren arbeitet und einfach das Objekt zur&uuml;gibt, wenn
es in der Auswahlliste enthalten ist:

[source,r]
----
noten <-  c("sehr gut", "gut", "nicht soo gut", "das kann auf jeden Fall noch besser werden")
note  <- "gut"
match.arg(arg = note, choices = noten)
----

----
## [1] "gut"
----

Dabei bedient es sich dem "partial matching", das hei&szlig;t, dass ein eindeutig einer Auswahlm&ouml;glichkeit zuzuordnender Anfang einer Zeichenkette ausreicht:

[source,r]
----
note  <- "das"
match.arg(arg = note, choices = noten)
----

----
## [1] "das kann auf jeden Fall noch besser werden"
----


Wird kein Treffer in der Auswahlliste gefunden, erhalten wir einen Fehler:

[source,r]
----
note  <- "ausreichend"
match.arg(arg = note, choices = noten)
----

[source,r]
----
## Error in match.arg(arg = note, choices = noten): 'arg' should be one of "sehr gut", "gut", "nicht soo gut", "das kann auf jeden Fall noch besser werden"

----


+match.arg+ ist genau, was hinter Steuerargumenten vieler Funktionen (z.b.  +mgcv::gam(optimizer = ...)+) steckt, hier ein Beispiel aus der Hilfe zu +match.arg+:

[source,r]
----
center <- function(x, type = c("mean", "median", "trimmed")) {
    type <- match.arg(type)
    switch(type,
           mean = mean(x),
           median = median(x),
           trimmed = mean(x, trim = .1))
}
center(rnorm(100), "med")
----

----
## [1] 0.02185232
----

[source,r]
----
center(rnorm(100), "m")
----

[source,r]
----
## Error in match.arg(type): 'arg' should be one of "mean", "median", "trimmed"

----



+checkmate+ kennt auch Auswahllisten, macht aber kein +partial matching+ (was ich ganz gut finde):

[source,r]
----
note  <- "das"
checkmate::assertChoice(x = note, choices = noten)
----

[source,r]
----
## Error in rasciidoc::render_slides("index.Rasciidoc"): Assertion on 'note' failed: Must be element of set {'sehr gut','gut','nicht soo gut','das kann auf jeden Fall noch besser werden'}, but is 'das'.

----


Au&szlig;erdem gibt +checkmate+ die gefundene R&uuml;ckgabe unsichtbar zur&uuml;ck, weshalb ich hier ein explizites +print+ ben&ouml;tige:

[source,r]
----
note  <- "gut"
checkmate::assertChoice(x = note, choices = noten)
print(checkmate::assertChoice(x = note, choices = noten))
----

----
## [1] "gut"
----


+checkmate+ kann nicht nur mit alphanumerischen Vektoren umgehen:

[source,r]
----
x <- 3
choices <- 1:7
print(checkmate::assertChoice(x = x, choices = choices))
----

----
## [1] 3
----



_Ich nutze Auswahllisten eher selten, da ich selten Steuerargumente mit mehreren Auswahlm&ouml;glichenkeiten in meinen Funktionen habe._

== Unit Testing //slide_only
=== Unit Testing//no_slide
Beim Unit Testing wollen wir nicht die einer Funktion &uuml;bergebenen Argumente, sondern die Funktion selbst testen.
Also im Zweifel ihren R&uuml;ckgabewert.

//begin_no_slide
Neben +testthat+ gibt es auch das R-Package +RUnit+.
//end_no_slide

== Testthat //slide_only
==== Testthat//no_slide


[source,r]
----
testthat::test_that("Simple test on summation.",
                    testthat::expect_identical(my_sum(c(2, 7)), 8)
                    )
----

[source,r]
----
## Error: Test failed: 'Simple test on summation.'
## * my_sum(c(2, 7)) not identical to 8.
## 1/1 mismatches
## [1] 9 - 8 == 1

----


[source,r]
----
testthat::test_that("Simple test on summation.",
                    testthat::expect_identical(my_sum(c(2, 7)), 9)
                    )
----


== Test Coverage //slide_only
==== Test Coverage//no_slide


[source,r]
----
cov <- covr::file_coverage("src/my_sum_assertion.R", "src/test_my_sum_assertion.R")
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/my_sum_assertion.R: 100.00%

----



[source,r]
----
cov <- covr::file_coverage("src/my_sum_coverage.R", "src/test_my_sum_assertion.R")
print(cov)
----

[source,r]
----
## Coverage: 83.33%

----

[source,r]
----
## src/my_sum_coverage.R: 83.33%

----



[source,r]
----
covr::zero_coverage(cov)
----

----
##                filename functions line value
## 2 src/my_sum_coverage.R    my_sum    3     0
----


== Nebenwirkungen testen //slide_only
==== Nebenwirkungen testen//no_slide

[source,r]
----
cov <- covr::file_coverage("src/wipe_clean_broken.R", "src/test_wipe_clean_broken.R")
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/wipe_clean_broken.R: 100.00%

----


_Ich teste fast alle meine Funktion sp&auml;testens, wenn ich sie in ein Package verpacke._

== Sch&ouml;ner Programmieren //slide_only
=== Sch&ouml;ner Programmieren//no_slide
//begin_no_slide
Ich m&ouml;chte Dir gerne noch drei Funktionen aus drei verschiedenen Packages vorstellen, 
die Dir helfen k&ouml;nnen, gut lesbare Funktionen zu schreiben. _Ich nutze alle drei standardm&auml;&szlig;ig bei der Entwicklung von Packages._
Aber vorweg stelle ich Dir noch +codetools+ vor, es gehört zur Gruppe der _recommended_ Packages von **R** und kann Programmfehler finden, die drei anderen Packages gibt es nur, weil +codetools+ schon da war.

Stell Dir vor, Du h&auml;ttest in der Datei "src/code.R" folgende unsch&ouml;ne 
und kaputte Funktion geschrieben:
//end_no_slide


[source,r]
----
foo <- function(this, func, has, way, too, many,args) {
    if (TRUE) { if (TRUE) {
            if (TRUE) {
                if (TRUE) {
                    if (TRUE) {
                        print(this_is_not_defined)
                    } else {
                        stop("Foobar!")
                    }
                } else {
                    stop("Foobar!")
                }
            } else {
                stop("Foobar!")
            }
        } else {
            stop("Foobar!")
        }
    } else {
        stop("Foobar!")
    }
    return(invisible(NULL))
}
----


==== Code prüfen mit Codetools //no_slide
== Code prüfen mit Codetools //slide_only
In Deiner Funktion findet +codetools+ die nicht benutzten Funktionsargumente und das nicht definierte Objekt +this_is_not_defined+:


[source,r]
----
source("src/code.R")
codetools::checkUsage(foo, all = TRUE)
----

----
## <anonymous>: no visible binding for global variable 'this_is_not_defined'
## <anonymous>: parameter 'args' may not be used
## <anonymous>: parameter 'func' may not be used
## <anonymous>: parameter 'has' may not be used
## <anonymous>: parameter 'many' may not be used
## <anonymous>: parameter 'this' may not be used
## <anonymous>: parameter 'too' may not be used
## <anonymous>: parameter 'way' may not be used
----


==== Entflusen mit lintr //no_slide
== Entflusen mit lintr //slide_only

Das Package `lintr` prüft Code auf Fussel, das sind Abweichungen des Codes von Richtlinien 
zur übersichtlichen Formatierung. 
Die Richtlinien (gegen die `lintr` prüft, und die sind gut, halte Dich an sie;
                 zu mehr über Progammierrichtlinien findest Du im https://fvafrcu.github.io/programmierleitfaden.ps[Programmierleitfaden an der Forstlichen Versuchs- und Forschungsanstalt Baden-Württemberg]) 
sehen unter anderem vor, 
dass auf Kommas immer ein Leerzeichen folgen sollte, 
dass auf öffnende geschweifte Klammern immer ein Zeilenumbruch folgen sollte und 
dass eine Datei keine Leerzeilen am Ende enthalten sollte:


[source,r]
----
lintr::lint("src/code.R")
----

----
## src/code.R:1:49: style: Commas should always have a space after.
## foo <- function(this, func, has, way, too, many,args) {
##                                                 ^
## src/code.R:2:15: style: Opening curly braces should never go on their own line and should always be followed by a new line.
##     if (TRUE) { if (TRUE) {
##               ^
## src/code.R:6:31: warning: no visible binding for global variable 'this_is_not_defined'
##                         print(this_is_not_defined)
##                               ^~~~~~~~~~~~~~~~~~~
## src/code.R:24:1: style: Trailing blank lines are superfluous.
## 
## ^
----


Das Package kennt viele Optionen, lies Dir die Hilfe durch!

==== Code s&auml;ubern mit cleanr //no_slide
== Code s&auml;ubern mit cleanr //slide_only
Das Package `cleanr` prüft die Länge und (Zeilen-) Breite von Funktionen und Codedateien und
die Verschachtelungstiefe von Funktionen, ihre Argumentenanzahl und ob sie einen expliziten
Rückgabewert haben.

[source,r]
----
print(suppressWarnings(cleanr::check_file("src/code.R")))
----

[source,r]
----
## Error in cleanr::check_file("src/code.R"):  src/code.R  foo  found 7 arguments, max_num_arguments was 5
## foo  found nesting depth 4, max_nesting_depth was 3

----



Auch dieses Package kennt viele Optionen, lies Dir die Hilfe durch!

==== Cyclomatic Complexity pr&uuml;fen mit cyclocomp //no_slide
== Cyclomatic Complexity pr&uuml;fen mit cyclocomp //slide_only
//begin_no_slide

McCabes "cyclomatic complexity" (<<cyc>>) mi&szlig;t die 
Komplexit&auml;t von Programmcode.
Mit ihr können wir prüfen, ob unsere Funktionen einfach genug sind.

Insbesondere gibt uns die "cyclomatic complexity" eine Idee davon, wie viele Testfälle wir 
für eine Funktion schreiben sollten 
(genau genommen ist sie eine obere Grenze für die Anzahl der für vollständige https://en.wikipedia.org/wiki/Code_coverage[branch coverage] benötigten Testfälle).
Für Deine häßliche Funktion bräuchtest Du also 
6 Testfälle:
//end_no_slide


[source,r]
----
cyclocomp::cyclocomp(parse(text = readLines("src/code.R")))
----

----
## [1] 6
----


//begin_no_slide
Allgemein gilt: je höher die "cyclomatic complexity", desto unverständlicher der Code.
McCabe empfiehlt eine "cyclomatic complexity" von nicht mehr als 10 für eine Funktion. Und der war professioneller Programmierer des Departement of Defense der National Security Agency. Bei einer "cyclomatic complexity"  von 20 dürfte es selbst für professionelle Programmiererinnen langsam schwierig werden, die Absicht hinter Deinem Code zu verstehen. Wenn Du eine "cyclomatic complexity" von mehr als 40 schaffst, hast Du vielleicht eine Funktion geschrieben, die tut, was sie soll, aber ziemlich sicher eine, die kaum ein Mensch mehr versteht. 

Natürlich gibt es immer Ausnahmen von der Regel. Die Funktion `devtools::release` beispielsweise 
hat eine ganze Reihe von interaktiven Abfragen des Typs

[source,r]
----
if (yesno("Were devtool's checks successful?"))
  return(invisible())
----

Diese treiben die "cyclomatic complexity" in die Höhe (weil die `return`-Anweisungen 
                                                        viele verschiedene mögliche Endpunkte der Funktion definieren. Eine gut strukturierte Funktion hat _genau einen_ "exit node"):
//end_no_slide


[source,r]
----
source("src/release.R")
cyclocomp::cyclocomp(release)
----

----
## [1] 44
----

//begin_no_slide
Dabei ist die Funktion nur schwer verdaulich und nicht völlig unlesbar.
Dennoch sollte Hadley Wickham die Funktion dringend entrümpeln:

[source,r]
----
linters <- lintr::default_linters[names(lintr::default_linters )!= "object_usage_linter"]
lintr::lint("src/release.R", linters = linters)
----

----
## src/release.R:70:1: style: lines should not be more than 80 characters.
##     if (yesno("Is documentation free of spelling errors? (you can ignore false positives)"))
## ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## src/release.R:87:40: warning: Do not use absolute paths.
##     cran_url <- paste0(cran_mirror(), "/web/checks/check_results_",
##                                        ^~~~
## src/release.R:100:49: style: Commas should never have a space before.
##     msg <- paste0("Have you checked the ", deps ," packages that depend on ",
##                                                ~^
## src/release.R:100:50: style: Commas should always have a space after.
##     msg <- paste0("Have you checked the ", deps ," packages that depend on ",
##                                                  ^
## src/release.R:166:1: style: lines should not be more than 80 characters.
##   yeses <- c("Yes", "Definitely", "For sure", "Yup", "Yeah", "I agree", "Absolutely")
## ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## src/release.R:187:53: style: Closing curly-braces should always be on their own line, unless it's followed by an else.
##     utils::browseURL(url, browser = email_browser())},
##                                                     ^
## src/release.R:301:17: style: Variable and function names should be all lowercase.
##   new_url$query$strErr
##                 ^~~~~~
----

//end_no_slide

[source,r]
----
suppressWarnings(cleanr::check_file("src/release.R"))
----

[source,r]
----
## Error in cleanr::check_file("src/release.R"):  src/release.R: line 70 counts 92 characters.
## src/release.R: line 166 counts 85 characters.
## src/release.R: 325 lines in file.
##  src/release.R  as.object_size  found no return() statement at all.
## src/release.R  build_cran  found no return() statement at all.
## src/release.R  cran_comments  found no return() statement at all.
## src/release.R  email  found no return() statement at all.
## src/release.R  email_browser  found no return() statement at all.
## src/release.R  maintainer  found no return() statement at all.
## src/release.R  release  line 24: found width 92 max_line_width was 80
## release  found 98 lines, max_lines was 65
## release  found 97 lines of code, max_lines_of_code was 50
## release  found no return() statement at all.
## src/release.R  release_email  found no return() statement at all.
## src/release.R  submit_cran  found no return() statement at all.
## src/release.R  upload_cran  found no return() statement at all.
## src/release.R  yesno  line 1: found width 85 max_line_width was 80
## yesno  found no return() statement at all.

----


== Funktionen dokumentieren //slide_only
=== Funktionen dokumentieren //no_slide

[source,r]
----
#' Remove All Objects From an Environment
#'
#' @param environment The environment to be wiped.
#' @return A character vector containing the names of objects removed.
#' @export
wipe_clean <- function(environment = parent.frame()) {
    objects <- ls(name = environment, all.names = TRUE)
    rm(list = objects, envir = environment)
    return(invisible(objects))
}
----


== Bibliographie
[bibliography]
- [[[cc]]] R.C. Martin. 2008. 'Clean Code: A Handbook of Agile Software Craftsmanship'. 
    Pearson Education.
- [[[cyc]]]  T. J. McCabe, 1976. 'A Complexity Measure'
   IEEE Transactions on Software Engineering archive.
   Volume 2, Issue 4, Pages 308-320 

