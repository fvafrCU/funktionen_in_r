= Funktionen Schreiben in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:numbered:
:data-uri:
:duration: 120

// //begin_only_slide
// == Skript
// https://fvafrcu.github.io/funktionen_in_r/[https://fvafrcu.github.io/funktionen_in_r/]
// //end_only_slide

== Worum geht es?

Naja, ums Schreiben von Funktionen in der Programmiersprache **R**.



=== Was sind Funktionen?

* Funktionen sind Programmkonstrukte, mit denen Du Teile des von Dir 
  geschriebenen Codes wiederverwenden kannst
  (siehe https://de.wikipedia.org/wiki/Funktion_(Programmierung)[Wikipedia]).
* Funktionen sind in den Standardbiliotheken jeder Programmiersprache vorhanden, 
  viele R-Funktionen kennst Du wahrscheinlich schon: `sum()`, `mean()` 
  oder `summary()`.

=== Warum Funktionen?

* Damit Du Teile des von Dir geschriebenen Codes wiederverwenden kannst.
* Damit Du, wenn Du Fehler im Code entdeckst, diese auch nur an einer 
  Stelle korrigieren musst.

=== Wann Funktionen?

Immer wenn Du merkst, dass Du (alten) Code mehrfach kopierst und an anderer
Stelle einfügst ohne ihn stark zu verändern, solltest Du darüber nachdenken, 
eine (oder mehrere) Funktion(en)  aus ihm  zu machen. 


== Eine Funktion schreiben
=== Eine neue Summenfunktion

.Warum wir diese Funktion nicht schreiben sollten

Eine Summenfunktion gibt es wahrscheinlich in jeder Programmiersprache, in **R**
heißt sie `sum()`. Diese Funktion ist besser, stabiler und schneller, als
alles, das wir selbst programmieren können.

.Warum wir es trotzdem tun

Nunja, irgendwelchen Code müssen wir ja nehmen.  
Ich habe die Summenberechnung ausführlich als Beispiel zur Schleifenprogrammierung in 
https://fvafrcu.github.io/programmieren_in_r/#gute-schleifen[Programmieren in R] benutzt, 
    und eine Wiederholung schadet sicher nicht.


==== Vom Code ... 

[source,r]
----
a  <- c(2, 3, 4, 10) # <1>
value <- 0 # <2>
for (a_i in a) { # <3>
    value <- value + a_i  # <4>
}
print(value) # <5>
----

----
## [1] 19
----


Dabei siehst Du:

<1> Definition des zu summierenden Vektors
<2> Definition des zur Addition neutralen Elementes
<3> Schleife über die Elemente des Vektors
<4> Addition des aktuellen Vektorelementes zum Ergebnis
<5> Ausgabe des Ergebnisses

==== ... zur Funktion 

Für unsere Summenfunktion soll die Definition des zu summierenden Vektors
der Anwenderin überlassen werden, daher wird der Vektor zu einem Argument
der Funktion. Ich wähle als Namen für das Argument jetzt +x+, das könnte aber
auch +a+ bleiben, es ist eine Frage der Konvention, und unter +x+ verstehen wir
meist eine Unbekannte. Und als Ausgabe verwenden wir keine Druck- sondern eine
Rückgabefunktion (+return()+ statt +print()+). 
Das Ergebnis sieht dann so aus:





[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



=== Scoping 
Programmiersprachen kennen für Objekte unterschiedliche Gültigkeitsbereiche 
(englisch "scope"), wir sehen uns das am Beispiel an:

==== Schreibzugriffe

.Ausgangszustand
Im Augenblick hat das Objekte +value+ den Wert 19:


[source,r]
----
print(value)
----

----
## [1] 19
----


.Funktionsausführung
Jetzt wenden wir unsere Summenfunktion an und berechnen die Summe eines anderen Vektors: 

[source,r]
----
print(my_sum(1:3))
----

----
## [1] 6
----


Das Objekt `value` behält seinen Wert:

[source,r]
----
print(value)
----

----
## [1] 19
----

Und das, obwohl wir innerhalb der Funktion dem Objekt +value+ in der ersten
Zeile den Wert 0 zuweisen und diesen dann in der Schleife mit den Werten 1, 3
und 6 überschreiben:
**R** verwaltet automatisch die Gültigkeitsbereiche aller Objekte. 
Es gibt daher ein Objekt names  +value+ außerhalb der Funktion, das den Wert 19 enthält und unverändert bleibt.
Innerhalb der Funktion legt **R** ein neues lokales Objekt, ebenfalls mit dem Namen
+value+, an.
Du _kannst_ auch aus einer Funktion in einen <<_arbeiten_mit_gültigkeitsbereichen, anderen Gültigkeitsbereich>> schreiben, wenn Du das wirklich willst.


==== Lesezugriffe

.Lesen ist unsicher
Mit dem Namen eines Objektes wird dieses gelesen, innerhalb einer Funktion sucht
**R** zunächst nach einem lokalen Objekt des gesuchten Namens, dann in den der
Funktion übergeordneten Gültigkeitsbereichen, also außerhalb der Funktion.

Das kann zu unerwünschten Nebeneffekten führen. Stell Dir vor, Du kommentierst 
beim Schreiben der Summenfunktion die Definition des zur Addition neutralen
Elementes aus Versehen aus:

[source,r]
----
my_sum_broken <- function(x) {
    # FIXME: this is accidentally commented out:
    # value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----


Du führst die Funktion aus und erhälst:

[source,r]
----
print(my_sum_broken(1:3))
----

----
## [1] 25
----

Was ist passiert?
Im ersten Durchlauf der Schleife gibt es beim Lesen von
+value+ noch kein lokales Objekt dieses Namens. Daher sucht **R** außerhalb der
Funktion und findet ein Objekt mit dem Wert 19. 
Zu diesem Objekt addieren
wir +x_i+, das im ersten Schleifendurchlauf den Wert +1+ enthält und erschaffen
damit in der Funktion ein lokales Objekt names +value+, das dann im zweiten
Durchlauf der Schleife auch gelesen werden kann.

Wenn Du diese Funktion verwendest, ohne vorher das Objekt +value+ zu definieren,
oder das Objekt +value+ entfernst und dann die Funktion ausführst

[source,r]
----
rm(value)
print(my_sum_broken(1:3))
----

[source,r]
----
## Error: object 'value' not found

----

erhälst Du einen Fehler, weil **R** auch außerhalb der Funktion kein Objekt
names +value+ finden kann. Und diesen Fehler erwarten wir ja eigentlich, wenn 
wir nur die Funktion betrachten: sie ist fehlerhaft.

.Sicherer Lesen
Wie wir eine Funktion dazu bringen können, außerhalb ihres Gültigkeitsbereiches
zu schreiben (nein, das _wie_ habe ich Dir noch nicht gezeigt), so können wir 
eine Funktion auch zwingen, beim Lesen nur nach lokalen Objekten zu
suchen:

[source,r]
----
my_sum_safer <- function(x) {
    for (x_i in x) {
        value <- get("value", inherits = FALSE) + x_i 
    }
    return(value)
}
----


Selbst wenn wir ein Objekt namens +value+ anlegen, gibt die Funktion nun einen
Fehler aus:

[source,r]
----
value <- 42
my_sum_safer(1:10)
----

[source,r]
----
## Error in get("value", inherits = FALSE): object 'value' not found

----

Ich finde es aber praktiabler, beim Schreiben einer Funktion darauf zu achten,
welche Objekte ich lese. + 
Und wenn Du Funktionen <<_funktionen_testen,testest>>, findest Du Fehler, die auf Scoping beruhen,
sehr schnell. 


==== Arbeiten mit Gültigkeitsbereichen 

Ein Befehl, mit dem Du alle Objekte Deines aktuellen Arbeitsbereiches löschen
kannst (entsprechend dem RStudio-Knopf mit dem Besensymbol footnote:[Im https://github.com/rstudio/rstudio/releases/tag/v1.1.426[Code von RStudio v1.1.426] findet sich die Funktion hinter dem Knopf  in der Datei src/cpp/session/modules/SessionEnvironment.R, sie besteht im wesentlichen aus der Zeile +
rm(list=ls(envir=env, all.names=includeHidden), envir=env) +
Sie wird in src/cpp/session/modules/environment/SessionEnvironment.cpp in der C++-Funktion  removeAllObjects aufgerufen.
]) lautet:


[source,r]
----
rm(list = ls(all.names = TRUE))
----

Nun  bin ich
vergesslich, weshalb ich mir die Syntax schlecht merken kann und lieber eine
Funktion (aber keinen Knopf) hätte.
Da "der aktuelle Arbeitsbereich" ein Gültigkeitsbereich 
(in **R** heissen die Gültigkeitsbereiche "environments", in **S** hießen sie "frames") ist und die 
Funktionen  `ls` und `rm` nur in _einem_ Gültigkeitsbereich arbeiten, funktioniert das naheliegende

[source,r]
----
wipe_clean <- function() {
    rm(list = ls(all.names = TRUE))
}
----

*nicht*.

Wenn ich den Gültigkeitsbereich explizit 

[source,r]
----
wipe_clean <- function() {
    rm(list = ls(name = parent.frame(), all.names = TRUE), envir = parent.frame())
}
----

angebe, tut die Funktion, was ich wollte:

[source,r]
----
ls()
----

----
## [1] "a"             "a_i"           "my_sum"        "my_sum_broken"
## [5] "my_sum_safer"  "tmp"           "value"         "wipe_clean"
----

[source,r]
----
wipe_clean()
ls()
----

----
## character(0)
----





=== Argumente

Funktionen kennen Argmumente, am besten nicht zu viele (siehe zum Beispiel <<cc>>). 
Unsere Summenfunktion kennt beispielsweise eines, nämlich den Vektor, den sie summieren soll. Der ist also ein obligatorisches Element, er sollte keine Voreinstellung haben (und hat auch keine).


Eine Funktion, die, wie `wipe_clean`, kein Argument kennt, ist Folgende:



[source,r]
----
memory_hogs <- function() {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    return(z)
}
----


Diese Funktion gibt mir für jedes Objekt des Gültigkeitsbereiches, in dem ich sie aufrufe, den Speicherverbrauch aus.


[source,r]
----
va <- rep(mtcars, 1)
vb <- rep(mtcars, 1000)
vc <- rep(mtcars, 2000)
vd <- rep(mtcars, 100)
memory_hogs()
----

----
## memory_hogs          va          vb          vc          vd 
##        7576        4232     3432720     6864720      343920
----


Bei so wenigen Objekten erkenne ich leicht, dass `vc` der größte Speicherfresser ist und ich, falls mir der Speicher platzt und ich `vc` nicht mehr unbedingt brauche, `vc` löschen sollte.

Aber wenn ich viele Objekte habe, wäre es doch schön, ein optionales Funktionsargument zu haben, dass in seiner Voreinstellung die Ausgabe nach Größe des Speicherbedarfs sortiert:


[source,r]
----
memory_hogs <- function(order = TRUE) {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    if (order) z <- z[order(z)]
    return(z)
}
----



[source,r]
----
memory_hogs()
----

----
##          va memory_hogs          vd          vb          vc 
##        4232        9576      343920     3432720     6864720
----


Das ist ein klassisches (optionales) Steuerargument, das das Verhalten einer Funktion steuert.
Steuerargumente sollten eine sinnvolle Voreinstellung haben.

Da die `memory_hogs` intern nun die Funktion `order` aufruft, könnten wir ja auf die Idee kommen, dieser Funktion Argumente weiterreichen zu wollen. 
Das können wir entweder explizit tun, oder wir benutzen ein spezielles, _Ellipsis_ genanntes Argument, das durch drei Punkte (`...`) aufgerufen wird:


[source,r]
----
memory_hogs <- function(...) {
    z <- sapply(ls(envir = parent.frame()), 
                function(x) object.size(get(x, envir = parent.frame())))
    if (! missing(...)) {
      z <- z[order(z, ...)]
    }
    return(z)
}
----



[source,r]
----
memory_hogs()
----

----
## memory_hogs          va          vb          vc          vd 
##       13080        4232     3432720     6864720      343920
----

[source,r]
----
memory_hogs(decreasing = TRUE)
----

----
##          vc          vb          vd memory_hogs          va 
##     6864720     3432720      343920       13080        4232
----


Jetzt können wir die Rückgabe unserer Funktion nutzen, um die beiden größten Speicherfresser zu löschen:


[source,r]
----
rm(list = names(memory_hogs(decreasing = TRUE)[1:2]))
memory_hogs()
----

----
## memory_hogs          va          vd 
##       13080        4232      343920
----


Wir können also, wenn wir wollen, drei Arten von Argumenten unterscheiden:

- Obligatorische. Sie sollten keine Voreinstellungen kennen und übergeben üblicherweise Objekte, die von der Funktion verarbeitet werden sollen.
- Optionale. Sie sollten Voreinstellungen kennen und dienen üblicherweise der Steuerung der Funktion.
- Die _Ellipsis_, um Argumente an andere Funktionen weiterzureichen.

=== Return Value und Side Effects
Jede Funktion in **R** gibt einen Wert zurück, falls sie nicht mit einem Fehler abbricht.
Wenn wir keinen Rückgabewert (return value) explizit angeben, ist er automatisch der Wert des letzten in der Funktion ausgewerteten Ausdrucks, also der letzte Wert, der wie auch immer berechnet oder zurückgegeben wurde.
Es ist daher sicher nicht schlecht, wenn Du versucht, den Rückgabewert explizit anzugeben.
Unsere Summenfunktion könnte auch so aussehen:


[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
}
----


Das ist zwar (um eine Zeile) kürzer und inhaltsgleich, aber weniger offentsichtlich. Und damit weniger gut lesbar.
Und damit mehr schlechter als eine Zeile kürzer mehr besser ist, capisce?

Komplexere Funktionen haben oft Nebenwirkungen (side effects)
Bei vielen dieser Funktionen sind die Nebenwirkungen der eigentliche Zweck der Funktion, manchmal ist Rückgabewert sogar belanglos. Die Funktion `rm` gibt beispielsweise unsichtbar `NULL` zurück (und das selbst dann, wenn es gar nichts zu löschen gibt), das erkennen wir, wenn wir ihren Rückgabewert explizit drucken:

[source,r]
----
a <- "This is a string"
print(rm(a))
----

----
## NULL
----

[source,r]
----
print(rm())
----

----
## NULL
----


Das heißt also, dass unsere Funktion `wipe_clean` den Wert `invisible(NULL)`, zurückgibt, denn das war der Wert des letzten in ihr ausgewerteten Ausdrucks (der Aufruf der Funktion `rm`).

Das können wir ändern, indem wir einen expliziten Rückgabewert einbauen (bei der Gelegenheit wandeln wir gleich noch den Gütigkeitsbereich, indem die Funktion läscht, in ein Steuerargument mit Voreinstellung um):


[source,r]
----
wipe_clean <- function(environment = parent.frame()) {
    objects <- ls(name = environment, all.names = TRUE)
    rm(list = objects, envir = environment)
    return(invisible(objects))
}
----


[source,r]
----
print(wipe_clean())
----

----
## [1] "memory_hogs" "my_sum"      "va"          "vd"          "wipe_clean"
----

[source,r]
----
ls()
----

----
## character(0)
----

Jetzt gibt die Funktion die Namen der von ihr gelöschten Objekte zurück. Wir wissen also, wie hieß, was wir gelöscht haben. Damit können wir zwar nichts mehr anfangen, aber die Funktion hat nun genau einen expliziten Endpunkt. Das ist immerhin schön übersichtlich.


=== Funktionen verwalten

==== Im jeweiligen Skript
Ich schreibe viele Funktionen während Datenauswertungen, sie landen dann erstmal 
im jeweiligen Auswertungsskript. Manchmal sammele ich sie an dessen Beginn, meist lege ich 
sie aber gleich <<_lokal, lokal>> ab.

==== Lokal
Viele meiner wissenschaftlichen Projekte haben im R-Skript-Verzeichnis ein Unterverzeichnis mit dem Namen +./functions+.
Darin lege ich die Funktionen, die ich <<_im_jeweiligen_skript, in den Skripten des Projektes>> schreibe, ab.
Wichtige Funktionen kommen in eigene Dateien, die nach ihnen benannt sind, andere sammele ich, beispielsweise in 
+./functions/utils.R+ oder +./functions/misc.R+.

Jedes Auswertungsskript hat dann am Beginn die Zeile

[source,r]
----
for (f in dir("./functions/", full.names = TRUE, pattern = ".*\\.[rR]")) source(f)
----


====  Global 
Funktionen, die Du nicht nur in einem Projekt nutzen willst, kannst Du zentral verwalten, 
in dem Du Dateien wie <<_lokal, lokal>>, aber in einem zentralen Verzeichnis ablegst, 
und in eine Deiner R-Startup-Dateien die Anweisung

[source,r]
----
for (f in dir("/full/path/to/functions_directory/", 
              full.names = TRUE, pattern = ".*\\.[rR]")) source(f)
----

einfügst und den  "/full/path/to/functions_directory/" anpasst.
Geeignte R-Startup-Dateien verrät Dir die R-Hilfe +?Startup+ oder der Code:

[source,r]
----
candidates <- c( Sys.getenv("R_PROFILE"),
                 Sys.getenv("R_PROFILE_USER"),
                 file.path(Sys.getenv("R_HOME"), "etc", "Rprofile.site"),
                 file.path(Sys.getenv("HOME"), ".Rprofile"),
                 file.path(getwd(), ".Rprofile") )

Filter(file.exists, candidates)
----


==== Als Paket
Wenn Du Dir die Mühe machst, Deine Funktionen zu <<_funktionen_dokumentieren, dokumentieren>>, kannst 
Du sie eigentlich auch gleich in einem oder mehreren Paketen verwalten. 
Das ist am elegantesten.


== Schöner Programmieren

=== Argumententests
Wir haben verschiedene Möglichkeiten, die Objekte, die wir den Argumenten einer Funktion übergeben, zu testen.


==== Typentests

Wir können Objekte darauf testen, ob sie einem bestimmten Typ (einer Klasse) angehören; 
bei Objekten, die einer Funktion als Argument übergeben werden ist dies besonders ratsam.
Das geht mir reinen +base R+, ist aber eher umständlich,
die https://cran.r-project.org/web/packages/checkmate/vignettes/checkmate.html#intro[Vignette zu +checkmate+] 
bietet ein anschauliches Bespiel.

Ich kenne zwei Pakete, die Typentest vereinfachen: 
https://CRAN.R-project.org/package=assertthat[assertthat] und 
https://CRAN.R-project.org/package=checkmate[checkmate]

-  https://CRAN.R-project.org/package=checkmate[checkmate] ist hauptsächlich in C geschrieben, sehr schnell, 
sehr flexibel mit unterschiedlichen Testarten ("checks", "asserts" und "tests"), 
hat aber viele Abhängigkeiten und ist etwas sperrig: sein Manual ist über 100 Seiten lang. 
- https://CRAN.R-project.org/package=assertthat[assertthat] ist reines R ohne irgendwelche Abhängigkeiten und recht übersichtlich.

https://CRAN.R-project.org/package=assertthat[assertthat] ist sehr einfach:

[source,r]
----
x <- 6
assertthat::assert_that(is.numeric(x))
----

----
## [1] TRUE
----


[source,r]
----
x <- "This is a string."
assertthat::assert_that(is.numeric(x))
----

[source,r]
----
## Error: x is not a numeric or integer vector

----


.Was haben wir davon?
Wenn wir unserer Summenfunktion 


[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----


ein nicht-numerisches Argument übergeben, erhalten wir eine recht kryptische Fehlermeldung:


[source,r]
----
my_sum(c("a", "b"))
----

[source,r]
----
## Error in value + x_i: non-numeric argument to binary operator

----



Durch den Einbau eines Typentests 


[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----

wird die Meldung deutlich verständlicher:

[source,r]
----
my_sum(c("a", "b"))
----

[source,r]
----
## Error: x is not a numeric or integer vector

----


Mit https://CRAN.R-project.org/package=checkmate[checkmate] können wir sogar erzwingen, dass x nicht nur numerisch sein muss,
sondern auch mindestens zwei Elemente haben soll. Eine Summe einer Zahl ist ja etwas albern:

[source,r]
----
my_sum <- function(x) {
    checkmate::qassert(x, "n>=2")
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



[source,r]
----
my_sum(42)
----

[source,r]
----
## Error in rasciidoc::render("index.Rasciidoc"): Assertion on 'x' failed. Must be of length >= 2, but has length 1.

----


_Ich nutze Typentests oft in Funktionen. Da https://CRAN.R-project.org/package=checkmate[checkmate] deutlich mehr Funktionalität bietet, nutzte ich https://CRAN.R-project.org/package=assertthat[assertthat] eher selten._

==== Auswahllisten
Mit Auswahllisten können wir Objekte darauf testen, ob sie eine von mehreren Möglichkeiten
enthalten. Das ist vor allem für Steuerargumente hilfreich.
+base R+ kennt +match.arg+, das mit alphanumerischen Vektoren arbeitet und einfach das Objekt zurückgibt, wenn
es in der Auswahlliste enthalten ist:

[source,r]
----
noten <-  c("sehr gut", "gut", "nicht soo gut", "das kann auf jeden Fall noch besser werden")
note  <- "gut"
match.arg(arg = note, choices = noten)
----

----
## [1] "gut"
----

Dabei bedient es sich dem "partial matching", das heißt, dass ein eindeutig einer Auswahlmöglichkeit zuzuordnender Anfang einer Zeichenkette ausreicht:

[source,r]
----
note  <- "das"
match.arg(arg = note, choices = noten)
----

----
## [1] "das kann auf jeden Fall noch besser werden"
----


Wird kein Treffer in der Auswahlliste gefunden, erhalten wir einen Fehler:

[source,r]
----
note  <- "ausreichend"
match.arg(arg = note, choices = noten)
----

[source,r]
----
## Error in match.arg(arg = note, choices = noten): 'arg' should be one of "sehr gut", "gut", "nicht soo gut", "das kann auf jeden Fall noch besser werden"

----


+match.arg+ ist genau, was hinter Steuerargumenten vieler Funktionen (z.b.  +mgcv::gam(optimizer = ...)+) steckt, hier ein Beispiel aus der Hilfe zu +match.arg+:

[source,r]
----
center <- function(x, type = c("mean", "median", "trimmed")) {
    type <- match.arg(type)
    switch(type,
           mean = mean(x),
           median = median(x),
           trimmed = mean(x, trim = .1))
}
center(rnorm(100), "med")
----

----
## [1] -0.02185017
----

[source,r]
----
center(rnorm(100), "m")
----

[source,r]
----
## Error in match.arg(type): 'arg' should be one of "mean", "median", "trimmed"

----



https://CRAN.R-project.org/package=checkmate[checkmate] kennt auch Auswahllisten, macht aber kein +partial matching+ (was ich ganz gut finde):

[source,r]
----
note  <- "das"
checkmate::assertChoice(x = note, choices = noten)
----

[source,r]
----
## Error in rasciidoc::render("index.Rasciidoc"): Assertion on 'note' failed: Must be element of set {'sehr gut','gut','nicht soo gut','das kann auf jeden Fall noch besser werden'}, but is 'das'.

----


Außerdem gibt https://CRAN.R-project.org/package=checkmate[checkmate] die gefundene Rückgabe unsichtbar zurück, weshalb ich hier ein explizites +print+ benötige:

[source,r]
----
note  <- "gut"
checkmate::assertChoice(x = note, choices = noten)
print(checkmate::assertChoice(x = note, choices = noten))
----

----
## [1] "gut"
----


https://CRAN.R-project.org/package=checkmate[checkmate] kann nicht nur mit alphanumerischen Vektoren umgehen:

[source,r]
----
x <- 3
choices <- 1:7
print(checkmate::assertChoice(x = x, choices = choices))
----

----
## [1] 3
----



_Ich nutze Auswahllisten eher selten, da ich selten Steuerargumente mit mehreren Auswahlmöglichenkeiten in meinen Funktionen habe._

=== Funktionen testen
==== Unit Testing
Beim Unit Testing wollen wir nicht die einer Funktion übergebenen Argumente, sondern die Funktion selbst testen.
Also im Zweifel ihren Rückgabewert.

Ich kenne zwei Pakete, die Unit Testing in R formalisieren 
(im Prinzip geht es auch ohne spezielle Pakete, 
 aber seit ich die beiden Pakete kenne, 
 habe ich nie mehr wie früher "von Hand" getestet):

- https://CRAN.R-project.org/package=RUnit[RUnit] gibt es schon seit 2004, es ist sehr formal
 und hat wenige Abhängigkeiten (daher bevorzuge ich es beim Testen von Paketen).
- https://CRAN.R-project.org/package=testthat[testthat] finde ich interaktiv einfacher anzuwenden.

===== Erwartungen 
Die kleinste Testeinheit ist immer ein Vergleich. 

Wenn wir die Funktionen 


[source,r]
----
my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----

 und 

[source,r]
----
not_my_sum <- function(x) {
    value <- 0
    for (x_i in x) {
        value <- value - x_i 
    }
    return(value)
}
----

haben, können wir zum Beispiel mit +base R+ prüfen, ob sie tun, was wir erwarten:


[source,r]
----
my_sum(c(2, 7)) == 9
----

----
## [1] TRUE
----

[source,r]
----
# better use identical(), see ?Comparison 
identical(not_my_sum(c(2, 7)), 9)
----

----
## [1] FALSE
----


Beide Pakete formalisieren dies zu Erwartungsfunktionen die hauptsächlich dazu dienen, 
Fehler zu beschreiben:

.https://CRAN.R-project.org/package=RUnit[RUnit]

[source,r]
----
RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
----

[source,r]
----
## Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9): FALSE 
## 

----


.https://CRAN.R-project.org/package=testthat[testthat]

[source,r]
----
testthat::expect_identical(not_my_sum(c(2, 7)), 9)
----


----
## not_my_sum(c(2, 7)) not identical to 9.
## 1/1 mismatches
## [1] -9 - 9 == -18
----


===== Tests 
Um Erwartungen bei der Paketentwicklung oder in Bezug auf ihre <<_code_coverage, Coverage>> auszuwerten,
    werden in beiden Paketen Erwartungen zu Tests zusammenfasst 
(eigentlich sollten Tests immer nur Erwartungen zu einer Funktion enthalten, aber wir wollen ja auch Fehler sehen):



.https://CRAN.R-project.org/package=testthat[testthat]
Du kannst einen Test entweder einzeln laufen lassen



[source,r]
----
testthat::test_that("Simple test on summation.", {
                        testthat::expect_identical(not_my_sum(c(2, 7)), 9,
                                                   info = "Not my sum.")
                        testthat::expect_identical(my_sum(c(2, 7)), 9, 
                                                   info = "My sum.")
})
----

[source,r]
----
## Error: Test failed: 'Simple test on summation.'
## * not_my_sum(c(2, 7)) not identical to 9.
## 1/1 mismatches
## [1] -9 - 9 == -18
## Not my sum.

----


oder den Test in einer  Testdatei 

[source,r]

[source,r]
----
testthat::test_that("Simple test on summation.", {
                        testthat::expect_identical(not_my_sum(c(2, 7)), 9,
                                                   info = "Not my sum.")
                        testthat::expect_identical(my_sum(c(2, 7)), 9, 
                                                   info = "My sum.")
})
----


mit einer Funktion auswerten, bei https://CRAN.R-project.org/package=testthat[testthat] ändert sich 
relativ wenig: 


[source,r]
----
testthat::test_file(file.path("src", "test_my_sum.R"))
----

----
## 1.
## Failed --------------------------------------------------------------------
## 1. Failure: Simple test on summation. (@test_my_sum.R#2) ------------------
## not_my_sum(c(2, 7)) not identical to 9.
## 1/1 mismatches
## [1] -9 - 9 == -18
## Not my sum.
## 
## DONE ======================================================================
----

Du erhälst aber die Information, dass der Fehler im ersten Test in Zeile 2 auftrat.

.https://CRAN.R-project.org/package=RUnit[RUnit]
Größer sind die Unterschiede bei https://CRAN.R-project.org/package=RUnit[RUnit], 
das primär für das Testen von Paketen entwickelt wurde:
Es ist beim einfachen

[source,r]
----
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
    RUnit::checkIdentical(my_sum(c(2, 7)), 9)
}
test_sum()
----

[source,r]
----
## Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9): FALSE 
## 

----

recht spröde, mit einer Testdatei 

.src/runit_my_sum.R
[source,r]

[source,r]
----
test_sum <- function() {
    RUnit::checkIdentical(not_my_sum(c(2, 7)), 9)
    RUnit::checkIdentical(my_sum(c(2, 7)), 9)
}
----


allerdings gesprächiger:


[source,r]
----
test_file <- normalizePath(file.path("src", "runit_my_sum.R"))
runit <- RUnit::runTestFile(test_file)
----

----
## 
## 
## Executing test function test_sum  ... Timing stopped at: 0 0 0 
##  done successfully.
----

[source,r]
----
RUnit::printTextProtocol(runit)
----

----
## RUNIT TEST PROTOCOL -- Thu Mar 22 13:21:32 2018 
## *********************************************** 
## Number of test functions: 1 
## Number of errors: 0 
## Number of failures: 1 
## 
##  
## 1 Test Suite : 
## runit_my_sum - 1 test function, 0 errors, 1 failure
## FAILURE in test_sum: Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9) : FALSE 
##  
## 
## 
## 
## Details 
## *************************** 
## Test Suite: runit_my_sum 
## Test function regexp: ^test.+ 
## Test file regexp: ^runit_my_sum.R$ 
## Involved directory: 
## /home/nik/git/cs/fvafrcu/funktionen_in_r/src 
## --------------------------- 
## Test file: /home/nik/git/cs/fvafrcu/funktionen_in_r/src/runit_my_sum.R 
## test_sum: FAILURE !! (check number 1)
## Error in RUnit::checkIdentical(not_my_sum(c(2, 7)), 9) : FALSE 
## 
----


==== Code Coverage
Um zu sehen, ob Deine Unit Tests die Funktion gut testen, kannst Du ihre  (https://en.wikipedia.org/wiki/Code_coverage[Überdeckung]) berechnen.
https://CRAN.R-project.org/package=covr[covr] ist eines der Pakete, die Code Coverage implentieren und das einzige, das ich nutze. Ich weiß es nicht, glaube aber, dass https://CRAN.R-project.org/package=covr[covr] die https://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria[_branch coverage_]
berechnet. 
Prinzipiell ist eine hohe Überdeckung gut.

Wenn Du eine Datei mit einer Funktionsdefinition

.src/my_sum_assertion.R

[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----


und eine mit dem Test

.src/test_my_sum_assertion.R

[source,r]
----
testthat::test_that("Simple test on summation.",
                    testthat::expect_identical(my_sum(c(2, 7)), 9)
                    )
----


hast, kannst Du die Überdeckung berechnen.


[source,r]
----
cov <- covr::file_coverage(file.path("src", "my_sum_assertion.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/my_sum_assertion.R: 100.00%

----


Wenn Du eine Funktion schreibst, in der eine Zeile eingebaut ist, die der Test nicht
erreicht, weist Dich https://CRAN.R-project.org/package=covr[covr] darauf hin:

.src/my_sum_assertion.R

[source,r]
----
my_sum <- function(x) {
    assertthat::assert_that(is.numeric(x))
    if (! is.numeric(x)) message("You'll never get here!")
    value <- 0
    for (x_i in x) {
        value <- value + x_i 
    }
    return(value)
}
----



[source,r]
----
cov <- covr::file_coverage(file.path("src", "my_sum_coverage.R"), 
                           file.path("src", "test_my_sum_assertion.R"))
print(cov)
----

[source,r]
----
## Coverage: 83.33%

----

[source,r]
----
## src/my_sum_coverage.R: 83.33%

----


https://CRAN.R-project.org/package=covr[covr] sagt Dir sogar, dass es die dritte Zeile ist:

[source,r]
----
covr::zero_coverage(cov)
----

----
##                filename functions line value
## 2 src/my_sum_coverage.R    my_sum    3     0
----


===== Nebenwirkungen testen

Funktionen sind relativ einfach zu testen, wenn ihr Rückgabewert ihr Zweck ist.
Wenn sie aber Nebenwirkungen bezwecken, finde ich Tests schwieriger zu schreiben.

Stell Dir vor, Du hättest die fehlerhafte Löschfunktion aus 
<<_arbeiten_mit_gültigkeitsbereichen, Arbeiten mit Gültigkeitsbereichen>> 
in eine Datei geschrieben:

.src/wipe_clean_broken.R
[source,r]
include::src/wipe_clean_broken.R[]

Nun schreibst Du eine Testdatei:

.src/test_wipe_clean_broken.R
[source,r]
include::src/test_wipe_clean_broken.R[]

Und erhälst vollständige Überdeckung:


[source,r]
----
cov <- covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                           file.path("src", "test_wipe_clean_broken.R"))
print(cov)
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/wipe_clean_broken.R: 100.00%

----


Alles gut? Nein, die Funktion ist kaputt und die Testdatei, die dies zeigt müsste 
auf die Nebenwirkung testen:

.src/test_wipe_clean.R
[source,r]
include::src/test_wipe_clean.R[]


[source,r]
----
covr::file_coverage(file.path("src", "wipe_clean_broken.R"), 
                    file.path("src", "test_wipe_clean.R"))
----

[source,r]
----
## Error: Test failed: 'Test return value and side effects.'
## * ls() not identical to character(0).
## Lengths differ: 1 vs 0

----


==== Was soll die ganze Testerei?


Stell Dir vor, Du erstelltest öfter Abbildungen. 
Jetzt bist Du ein Mensch mit einem Gefühl für Harmonien,
daher willst Du gerne, wenn möglich, den 
https://de.wikipedia.org/wiki/Goldener_Schnitt[Goldenen Schnitt] bei der 
Wahl der Zuschnitte berücksichtigen.

Da Du Dir den Goldenen Schnitt nicht gut merken kannst, schreibst Du folgende Funktion:


.src/golden_ratio.R
// WARNING: Do not use
//     [source,r]
//     include::src/golden_ratio.R[]
// here as does not evaluate _now_ whereas knitr does!

[source,r]
----
golden_ratio  <- function() {
    phi <- (1 + sqrt(5)) / 2
    return(phi)
}
----


Das ginge auch als Einzeiler: 

[source,r]
----
golden_ratio  <- function() return((1 + sqrt(5)) / 2)  
----

aber den findest Du auch nicht viel eleganter, dafür aber schlechter lesbar.

Du schreibst auch einen Test, obwohl der ziemlich trivial ist:

.src/test_golden_ratio.R

[source,r]
----
testthat::test_that("Test on Golden Ratio", {
                        expectation <- (1 + sqrt(5)) / 2
                        result <- golden_ratio()
                        testthat::expect_identical(result, expectation)
})
----

[source,r]

[source,r]
----
covr::file_coverage(file.path("src", "golden_ratio.R"), 
                    file.path("src", "test_golden_ratio.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_ratio.R: 100.00%

----


Wenn Du Graphiken nach dem Goldenen Schnitt proportionieren willst, musst Du bei 
gegebener Länge der kurzen Seite diese mit dem Goldenen Schnitt multipizieren 
um die Länge der langen Seite zu erhalten. 

Das ist eigentlich nicht allzu kompliziert, dennoch kommst Du manchmal durcheinander, 
also schreibst Du die folgende Funktion:

.src/golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(b) {
    a <- b * golden_ratio()
    return(c("a" = a, "b" = b))
}
----


Auch für diese Funktion schreibst Du einen Test:


.src/test_golden_rectangle.R

[source,r]
----
testthat::test_that("Test on golden rectangle", {
                        b <- 2
                        expectation <- c(a = b * golden_ratio(), b = b)
                        result <- golden_rectangle(b)
                        testthat::expect_identical(result, expectation)
})
----


[source,r]
----
covr::file_coverage(file.path("src", c("golden_ratio.R", "golden_rectangle.R")), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_ratio.R: 100.00%

----

[source,r]
----
## src/golden_rectangle.R: 100.00%

----


Du benutzt die Funtktion ...


[source,r]
----
source(file.path("src", "golden_ratio.R"))
width <- 4
png("p1.png", units = "cm", res = 400,
    width = width, 
    height = golden_rectangle(width)[["a"]])
par(mar=c(1,1,1,1))
plot(cars)
dev.off()
----

----
## pdf 
##   2
----


 und bist begeistert:

.Oh, wie schön!
image::p1.png[]
[caption=""]


Du benutzt die Funktion eine Weile weiter, merkst dann aber, dass Du ja auch querformatige
Abbildungen erstellen willst und daher 
bei gegebener Länge der 
langen Seite diese durch den Goldenen Schnitt dividieren musst, um die Länge 
der kurzen Seite zu erhalten.

Jetzt kannst Du entweder eine neue Funktion schreiben oder die alte erweitern.
Da die Funktionalitäten zum selben Thema passen und +golden_rectangle+ bislang
recht simpel ist, schreibst Du Deine Funktion also um:


.src/golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(value, landscape = TRUE) {
    phi <- golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


[source,r]
----
width <- 4
png("p2.png", units = "cm", res = 400,
    width = width, 
    height = golden_rectangle(width)[["b"]])
par(mar=c(1,1,1,1))
plot(cars)
dev.off()
----

----
## pdf 
##   2
----


.Auch sehr schön!
image::p2.png[]
[caption=""]

Herzlichen Glückwunsch, Du hast gerade die https://en.wikipedia.org/wiki/Application_programming_interface[Schnittstelle] Deiner Funktion zerschossen, indem Du ihr voreingestelltes Verhalten geändert hast. 
Glücklicherweise hast Du einen Test, der Dir jetzt um die Ohren fliegt:


[source,r]
----
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Error: Test failed: 'Test on golden rectangle'
## * `result` not identical to `expectation`.
## 2/2 mismatches (average diff: 1)
## [1] 2.00 - 3.24 == -1.236
## [2] 1.24 - 2.00 == -0.764

----


Was bedeutet das? 
Du musst entweder

- *alle* Aufrufe der Funktion, die Du vor der Veränderung ihrer Schnittstelle progammiert hast, 
  anpassen (indem Du +, landscape = FALSE+ einfügst) oder
- die Funktion so ändern, dass der Test weiterhin funktioniert.

Du entscheidest Dich, die Funktion zu ändern 
(und erweiterst bei der Gelegenheit gleich den R&uuml;ckgabewert):



.src/golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(value, landscape = FALSE) {
    phi <- golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


Um Querformatige Proportionen zu erhalten musst Du nun aktiv Querformat einstellen:
+golden_rectangle(width, landscape = TRUE)+

Der Test funktioniert wieder, da Du aber die Funktion geändert hast, überdeckt
er sie nicht mehr vollständig:


[source,r]
----
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Coverage: 71.43%

----

[source,r]
----
## src/golden_rectangle.R: 71.43%

----


Du erweiterst also Deine Testdatei an:


.src/test_golden_rectangle.R

[source,r]
----
golden_rectangle  <- function(value, landscape = FALSE) {
    phi <- golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


[source,r]
----
covr::file_coverage(file.path("src", "golden_rectangle.R"), 
                    file.path("src", "test_golden_rectangle.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_rectangle.R: 100.00%

----


+golden_rectangle+ habe ich mir nur ausgedacht, um Dir mein Vorgehen zu verdeutlichen. Aber:

 _Ich teste fast alle meine Funktion nach genau dem Ablauf in diesem Abschnitt spätestens, 
wenn ich sie in ein Paket verpacke._

=== Weniger schlecht programmieren
Ich möchte Dir gerne noch drei Funktionen aus drei verschiedenen Paketen vorstellen, 
die Dir helfen können, gut lesbare Funktionen zu schreiben. 

_Ich nutze alle drei standardmäßig bei der Entwicklung von Paketen._

Aber vorweg stelle ich Dir noch https://CRAN.R-project.org/package=codetools[codetools] vor, es gehört zur Gruppe der "_recommended_ Packages" von **R** und kann Programmfehler finden, die drei anderen Pakete gibt es nur, weil https://CRAN.R-project.org/package=codetools[codetools] schon da war.

Stell Dir vor, Du hättest in der Datei "src/code.R" folgende unschöne 
und kaputte Funktion geschrieben:


[source,r]
----
foo <- function(this, func, has, way, too, many,args) {
    if (TRUE) { if (TRUE) {
            if (TRUE) {
                if (TRUE) {
                    if (TRUE) {
                        print(this_is_not_defined)
                    } else {
                        stop("Foobar!")
                    }
                } else {
                    stop("Foobar!")
                }
            } else {
                stop("Foobar!")
            }
        } else {
            stop("Foobar!")
        }
    } else {
        stop("Foobar!")
    }
    return(invisible(NULL))
}
----


==== Code prüfen mit https://CRAN.R-project.org/package=codetools[codetools] 
In Deiner Funktion findet https://CRAN.R-project.org/package=codetools[codetools] 
die nicht benutzten Funktionsargumente und das nicht definierte Objekt +this_is_not_defined+:


[source,r]
----
source(file.path("src", "code.R"))
codetools::checkUsage(foo, all = TRUE)
----

----
## <anonymous>: no visible binding for global variable 'this_is_not_defined'
## <anonymous>: parameter 'args' may not be used
## <anonymous>: parameter 'func' may not be used
## <anonymous>: parameter 'has' may not be used
## <anonymous>: parameter 'many' may not be used
## <anonymous>: parameter 'this' may not be used
## <anonymous>: parameter 'too' may not be used
## <anonymous>: parameter 'way' may not be used
----


==== Entflusen mit  https://CRAN.R-project.org/package=lintr[lintr]  

Das Paket https://CRAN.R-project.org/package=lintr[lintr] prüft Code auf Fussel, das sind Abweichungen des Codes von Richtlinien 
zur übersichtlichen Formatierung. 
Die Richtlinien (gegen die https://CRAN.R-project.org/package=lintr[lintr] prüft, und die sind gut, halte Dich an sie;
                 zu mehr über Progammierrichtlinien findest Du im https://fvafrcu.github.io/programmierleitfaden.ps[Programmierleitfaden an der Forstlichen Versuchs- und Forschungsanstalt Baden-Württemberg]) 
sehen unter anderem vor, 
dass auf Kommas immer ein Leerzeichen folgen sollte, 
dass auf öffnende geschweifte Klammern immer ein Zeilenumbruch folgen sollte und 
dass eine Datei keine Leerzeilen am Ende enthalten sollte:


[source,r]
----
lintr::lint(file.path("src", "code.R"))
----

----
## src/code.R:1:49: style: Commas should always have a space after.
## foo <- function(this, func, has, way, too, many,args) {
##                                                 ^
## src/code.R:2:15: style: Opening curly braces should never go on their own line and should always be followed by a new line.
##     if (TRUE) { if (TRUE) {
##               ^
## src/code.R:6:31: warning: no visible binding for global variable 'this_is_not_defined'
##                         print(this_is_not_defined)
##                               ^~~~~~~~~~~~~~~~~~~
## src/code.R:24:1: style: Trailing blank lines are superfluous.
## 
## ^
----


Das Paket kennt viele Optionen, lies Dir die Hilfe durch!

==== Code säubern mit  https://CRAN.R-project.org/package=cleanr[cleanr]  
Das Paket https://CRAN.R-project.org/package=cleanr[cleanr] prüft die Länge und (Zeilen-) Breite von Funktionen und Codedateien und
die Verschachtelungstiefe von Funktionen, ihre Argumentenanzahl und ob sie einen expliziten
Rückgabewert haben.

[source,r]
----
print(suppressWarnings(cleanr::check_file(file.path("src", "code.R"))))
----

[source,r]
----
## Error in cleanr::check_file(file.path("src", "code.R")):  src/code.R  foo  found 7 arguments, max_num_arguments was 5
## foo  found nesting depth 4, max_nesting_depth was 3

----



Auch dieses Paket kennt viele Optionen, lies Dir die Hilfe durch!

==== Cyclomatic Complexity prüfen mit https://CRAN.R-project.org/package=cyclocomp[cyclocomp] 

McCabes "cyclomatic complexity" (<<cyc>>) mißt die 
Komplexität von Programmcode.
Mit ihr kannst Du prüfen, ob Deine Funktionen einfach genug sind.

Insbesondere gibt Dir die "cyclomatic complexity" eine Idee davon, wie viele Testfälle Du 
für eine Funktion schreiben solltest
(genau genommen ist sie eine obere Grenze für die Anzahl der für vollständige https://en.wikipedia.org/wiki/Code_coverage[branch coverage] benötigten Testfälle).
Für Deine häßliche Funktion bräuchtest Du also 
6 Testfälle:


[source,r]
----
cyclocomp::cyclocomp(parse(text = readLines(file.path("src", "code.R"))))
----

----
## [1] 6
----


Allgemein gilt: je höher die "cyclomatic complexity", desto unverständlicher der Code.
McCabe empfiehlt eine "cyclomatic complexity" von nicht mehr als 10 für eine Funktion. Und der war professioneller Programmierer des Departement of Defense der National Security Agency. Bei einer "cyclomatic complexity"  von 20 dürfte es selbst für professionelle Programmiererinnen langsam schwierig werden, die Absicht hinter Deinem Code zu verstehen. Wenn Du eine "cyclomatic complexity" von mehr als 40 schaffst, hast Du vielleicht eine Funktion geschrieben, die tut, was sie soll, aber ziemlich sicher eine, die kaum ein Mensch mehr versteht. 

Natürlich gibt es immer Ausnahmen von der Regel. Die Funktion `devtools::release` beispielsweise 
hat eine ganze Reihe von interaktiven Abfragen des Typs

[source,r]
----
if (yesno("Were devtool's checks successful?"))
  return(invisible())
----

Diese treiben die "cyclomatic complexity" in die Höhe (weil die `return`-Anweisungen 
                                                        viele verschiedene mögliche Endpunkte der Funktion definieren. Eine gut strukturierte Funktion hat _genau einen_ "exit node"):


[source,r]
----
source(file.path("src", "release.R"))
cyclocomp::cyclocomp(release)
----

----
## [1] 44
----

Dabei ist die Funktion lediglich schwer verdaulich und nicht völlig unlesbar.
Dennoch sollte Hadley Wickham die Funktion dringend entrümpeln:

[source,r]
----
linters <- lintr::default_linters[names(lintr::default_linters )!= "object_usage_linter"]
lintr::lint(file.path("src", "release.R"), linters = linters)
----

----
## src/release.R:70:1: style: lines should not be more than 80 characters.
##     if (yesno("Is documentation free of spelling errors? (you can ignore false positives)"))
## ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## src/release.R:87:40: warning: Do not use absolute paths.
##     cran_url <- paste0(cran_mirror(), "/web/checks/check_results_",
##                                        ^~~~
## src/release.R:100:49: style: Commas should never have a space before.
##     msg <- paste0("Have you checked the ", deps ," packages that depend on ",
##                                                ~^
## src/release.R:100:50: style: Commas should always have a space after.
##     msg <- paste0("Have you checked the ", deps ," packages that depend on ",
##                                                  ^
## src/release.R:166:1: style: lines should not be more than 80 characters.
##   yeses <- c("Yes", "Definitely", "For sure", "Yup", "Yeah", "I agree", "Absolutely")
## ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## src/release.R:187:53: style: Closing curly-braces should always be on their own line, unless it's followed by an else.
##     utils::browseURL(url, browser = email_browser())},
##                                                     ^
## src/release.R:301:17: style: Variable and function names should be all lowercase.
##   new_url$query$strErr
##                 ^~~~~~
----

[source,r]
----
suppressWarnings(cleanr::check_file(file.path("src", "release.R")))
----

[source,r]
----
## Error in cleanr::check_file(file.path("src", "release.R")):  src/release.R: line 70 counts 92 characters.
## src/release.R: line 166 counts 85 characters.
## src/release.R: 325 lines in file.
##  src/release.R  as.object_size  found no return() statement at all.
## src/release.R  build_cran  found no return() statement at all.
## src/release.R  cran_comments  found no return() statement at all.
## src/release.R  email  found no return() statement at all.
## src/release.R  email_browser  found no return() statement at all.
## src/release.R  maintainer  found no return() statement at all.
## src/release.R  release  line 24: found width 92 max_line_width was 80
## release  found 98 lines, max_lines was 65
## release  found 97 lines of code, max_lines_of_code was 50
## release  found no return() statement at all.
## src/release.R  release_email  found no return() statement at all.
## src/release.R  submit_cran  found no return() statement at all.
## src/release.R  upload_cran  found no return() statement at all.
## src/release.R  yesno  line 1: found width 85 max_line_width was 80
## yesno  found no return() statement at all.

----


=== Funktionen dokumentieren 
Wenn Du Hilfe zu einer Funktion in **R** suchst, kannst Du unter anderem die 
**R**-Hilfe mit +help(topic)+ oder der Kurzform +?topic+ aufrufen, bei Paketen findest Du
die selbe Information auch immer als pdf beigelegt.

Solche Hilfeformate kannst Du f&uuml;r Deine Funktionen auch schreiben.

==== Warum solltest Du Deine Funktionen dokumentieren?
Wenn Du Funktionen dokumentierst, erkl&auml;rst Du einer anderen Person, was die Funktion
tun sollte. Wenn Du das schaffst, kannst Du Dir einigerma&szlig;en sicher sein, 
dass Du wei&szlig;t, was die Funktion tut und dass es richtig war, 
sie (und nicht eine etwas andere) zu schreiben.

Au&szlig;erdem ist es von dokumentierten Funktionen zu Paketen nicht mehr weit, 
was ihre <<_als_paket, Verwaltung>> deutlich erleichtert.

Nehmen wir unser <<_was_soll_die_ganze_testerei, Beispiel zum Goldenen Schnitt>>:

Du merkst, dass Du die Funktion +golden_ratio+ eigentlich nur innerhalb 
von +golden_rectangle+ benutzt und letzteres kein gl&uuml;cklicher Name ist, weil 
Du die Funktion zwar zum Errechnen von Seitenl&auml;ngen von Graphiken nutzt, sie
ja aber ganz allgemein den Goldenen Schnitt ausrechnet.
Du entschlie&szlig;t Dich daher, die interne Funktion in 
+.golden_ratio+ (der f&uuml;hrende Punkt ist eine Konvention, die aus der UNIX-Welt stammt, 
                 dort werden (vorwiegend Konfigurations-) Dateien mit einem f&uuml;hrenden Punkt 
                 aus dem directory listing ausgeschlossen (unter Windows heissen diese Dateien "versteckt")
                 -- in **R** kennzeichnet die Konvention interne Funktionen, die gew&ouml;hnlich
                 nicht direkt aufgerufen werden (sollten))
                 und +golden_rectangle+ in +golden_ratio+ umzubenennen.
Dazu musst Du 

- die Funktionsdateien und die zugeh&ouml;rigen Testdateien umbenennen,
- die Namen in den Funktionsdefinitionen &auml;ndern und
- die Namen in den Funktionsaufrufen &auml;ndern.

Das kannst Du von Hand machen, oder Du schreibst folgende Funktionen:


[source,r]
----
substitute_function <- function(from, to, file_name) {
        patterns <- c(definition_pattern = paste0(from, "( *<-)"),
                      call_pattern = paste0(from, "(\\()"))
        x <- readLines(file_name)
        for (pattern in patterns) 
            x <- sub(pattern, paste0(to, "\\1"), x)

        writeLines(x, con = file_name)

}

rename_function <- function(from, to, directory = ".") {
    file_names <- list.files(directory, full.names = TRUE, 
                             pattern = paste0("^(test_|)", from, "\\.[rR]$")
                             )
    new_file_names <- NULL

    for (file_name in file_names) {

        substitute_function(from = from, to = to, file_name = file_name)
        new_file_name <- file.path(dirname(file_name), 
                                   sub(from, to, basename(file_name)))
        file.rename(file_name, new_file_name)
        new_file_names <- c(new_file_names, new_file_name)
    }
    return(new_file_names)
}
----

Diese Funktionen leben ja von Nebenwirkungen, sie sind schwer zu testen und wir hoffen also, dass Du keine Fehler gemachst hast.

Funktionieren tut das so:


[source,r]
----
rename_function(from = "golden_ratio", to = ".golden_ratio", 
                 directory = "src")
----

----
## [1] "src/.golden_ratio.R"      "src/test_.golden_ratio.R"
----

[source,r]
----
# replace calls to golden_ratio()!
substitute_function(from = "golden_ratio", to = ".golden_ratio", 
                 file_name = file.path("src", "test_golden_rectangle.R"))
substitute_function(from = "golden_ratio", to = ".golden_ratio", 
                 file_name = file.path("src", "golden_rectangle.R"))
rename_function(from = "golden_rectangle", to = "golden_ratio", 
                 directory = "src")
----

----
## [1] "src/golden_ratio.R"      "src/test_golden_ratio.R"
----

Du testest nat&uuml;rlich Deine neuen Dateien:

[source,r]
----
covr::file_coverage(file.path("src", ".golden_ratio.R"), 
                    file.path("src", "test_.golden_ratio.R"))
----

[source,r]
----
covr::file_coverage(file.path("src", c("golden_ratio.R", ".golden_ratio.R")), 
                    file.path("src", "test_golden_ratio.R"))
----

[source,r]
----
## Coverage: 100.00%

----

[source,r]
----
## src/golden_ratio.R: 100.00%

----


Scheint geklappt zu haben.

Du siehst also, dass Du Deine Funktionen ver&auml;ndert hast, _weil_ Du sie dokumentieren 
willst.


==== Wie kannst Du Funktionen dokumentieren?

Das **R**-Hilfeformat wird https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Writing-R-documentation-files[hier] 
beschrieben, ich rate Dir aber, https://cran.r-project.org/web/packages/roxygen2/index.html[roxygen2] zu
benutzen (http://r-pkgs.had.co.nz/man.html[hier] gibt Hadley Wickham eine druckreife Einf&uuml;hrung).

Du ver&auml;nderst also Deine Funktionsdatei, in dem Du Dokumentationskommentare einf&uuml;gst:



.src/golden_ratio.R

[source,r]
----
#' Compute the Other Quantity in Golden Ratio
#'
#' See \url{https://en.wikipedia.org/wiki/Golden_ratio} for an introduction to
#' the Golden Ratio.
#'
#' Specify \code{value = 1} to obtain the Golden Ratio itself in element "a" of 
#' the return value.
#' @param value A Quantity.
#' @param landscape Is the quantity given by \code{value} the larger one ("a")?
#' @return A vector giving the quantities "a" and "b".
#' @export
#' @examples
#' print(golden_ratio(value = 1)[["a"]])
golden_ratio  <- function(value, landscape = FALSE) {
    phi <- .golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


und weil dokumentieren Dir soviel Spa&szlig; bereit, dokumentierst Du gleich auch
die interne Funktion (interne Funktionen zu dokumentieren ist ein wenig umstritten,
                      ich finde es gut).



.src/.golden_ratio.R

[source,r]
----
#' Compute the Golden Ratio
#'
#' See \url{https://en.wikipedia.org/wiki/Golden_ratio} for an introduction to
#' the Golden Ratio.
#'
#' @return The Golden Ratio
#' @keywords internal
.golden_ratio  <- function() {
    phi <- (1 + sqrt(5)) / 2
    return(phi)
}
----


Was hast Du davon, au&szlig;er Arbeit?

Wenn Du Deine beiden Funktionen in eine Datei schreibst



.src/golden_ratios.R

[source,r]
----
#' Compute the Golden Ratio
#'
#' See \url{https://en.wikipedia.org/wiki/Golden_ratio} for an introduction to
#' the Golden Ratio.
#'
#' @return The Golden Ratio
#' @keywords internal
.golden_ratio  <- function() {
    phi <- (1 + sqrt(5)) / 2
    return(phi)
}

#' Compute the Other Quantity in Golden Ratio
#'
#' See \url{https://en.wikipedia.org/wiki/Golden_ratio} for an introduction to
#' the Golden Ratio.
#'
#' Specify \code{value = 1} to obtain the Golden Ratio itself in element "a" of 
#' the return value.
#' @param value A Quantity.
#' @param landscape Is the quantity given by \code{value} the larger one ("a")?
#' @return A vector giving the quantities "a" and "b".
#' @export
#' @examples
#' print(golden_ratio(value = 1)[["a"]])
golden_ratio  <- function(value, landscape = FALSE) {
    phi <- .golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


kannst Du mit dem Paket https://CRAN.R-project.org/package=document[document] Hilfe-Dateien erstellen, 
wie Du sie aus **R** kennst:


[source,r]
----
document::document(file.path("src", "golden_ratios.R"), output_directory = ".")
----


[source,r]
----
list.files(pattern = "^golden.*", full.names = TRUE)
----

----
## [1] "./golden_ratios.html" "./golden_ratios.pdf"  "./golden_ratios.txt"
----


Au&szlig;erdem kannst Du mit https://CRAN.R-project.org/package=document[document] nach der Erstellung der Hilfe-Dateien 
in einer laufenden **R**-Sitzung die Hilfe zu Deiner Funktion ansehen:


[source,r]
----
document::man("golden_ratio")
----

----
Compute the Other Quantity in Golden Ratio

Description:

     See <URL: https://en.wikipedia.org/wiki/Golden_ratio> for an
     introduction to the Golden Ratio.

Usage:

     golden_ratio(value, landscape = FALSE)
     
Arguments:

   value: A Quantity.

landscape: Is the quantity given by ‘value’ the larger one ("a")?

Details:

     Specify ‘value = 1’ to obtain the Golden Ratio itself in element
     "a" of the return value.

Value:

     A vector giving the quantities "a" and "b".

Examples:

     print(golden_ratio(value = 1)[["a"]])
     
 
----


Und zum Dritten und Wichtigsten: Du hast Deine Funktionen dokumentiert und ihre 
Schnittstellen beschrieben. Sie sind jetzt <<_paketieren,paketierungsreif>>.

=== Paketieren

Zum Paketieren nimmst Du wieder die getrennten Funktionsdateien, 
+src/golden_ratio.R+ und und +src/.golden_ratio.R+ und ihre zugeh&ouml;rigen Testdateien.

Damit sie den Paketanforderungen gen&uuml;gen, mu&szlig;t Du noch zwei kleine
&Auml;derungen vornehmen: +golden_ratio.R+ braucht noch einen
Verweis darauf, dass interne Funktionen in +golden_ratio_internals.R+ stehen


[source,r]
----
code <- c("#' @include golden_ratio_internals.R", "NULL", "",
          readLines(file.path("src", "golden_ratio.R")))
writeLines(code, file.path("src", "golden_ratio.R"))
----

.src/golden_ratio.R

[source,r]
----
#' @include golden_ratio_internals.R
NULL

#' Compute the Other Quantity in Golden Ratio
#'
#' See \url{https://en.wikipedia.org/wiki/Golden_ratio} for an introduction to
#' the Golden Ratio.
#'
#' Specify \code{value = 1} to obtain the Golden Ratio itself in element "a" of 
#' the return value.
#' @param value A Quantity.
#' @param landscape Is the quantity given by \code{value} the larger one ("a")?
#' @return A vector giving the quantities "a" and "b".
#' @export
#' @examples
#' print(golden_ratio(value = 1)[["a"]])
golden_ratio  <- function(value, landscape = FALSE) {
    phi <- .golden_ratio()
    if (isTRUE(landscape)) {
        a  <- value
        b <- a / phi
    } else {
        b <- value
        a <- b * phi
    }
    return(c("a" = a, "b" = b))
}
----


und die Dokumentation f&uuml;r +.golden_ratio+ sollte in eine Datei geschrieben
werden, deren Name nicht mit einem Punkt beginnt
(der Name der Hilfedatei wird, wenn Du ihn nicht explizit angibst, aus dem der
dokumentierten Funktion abgeleitet)


[source,r]
----
code <- readLines(file.path("src", ".golden_ratio.R"))
return_line <- grep("@return", code)
code_upper <- code[1:return_line]
code_lower <- code[(return_line + 1):length(code)]
code <- c(code_upper, "#' @rdname internals", code_lower)
writeLines(code, file.path("src", ".golden_ratio.R"))
----

.src/.golden_ratio.R

[source,r]
----
#' Compute the Golden Ratio
#'
#' See \url{https://en.wikipedia.org/wiki/Golden_ratio} for an introduction to
#' the Golden Ratio.
#'
#' @return The Golden Ratio
#' @rdname internals
#' @keywords internal
.golden_ratio  <- function() {
    phi <- (1 + sqrt(5)) / 2
    return(phi)
}
----




Du erstellst eine Paketvorlage und kopierst die Dateien hinein:


[source,r]
----
# Create package skeleton
package_name <- "mytools"
package_dir <- file.path(dirname(tempdir()), package_name)
unlink(package_dir, recursive = TRUE) # make sure it's not there 
devtools::create(package_dir)
# add source files
file.copy(from = file.path("src", c("golden_ratio.R", ".golden_ratio.R")), 
          to = file.path(package_dir, "R"))
# rename the hidden file, package will not build otherwise:
file.rename(file.path(package_dir, "R", ".golden_ratio.R"), 
            file.path(package_dir, "R", "golden_ratio_internals.R"))
# create package's testing skeleton
devtools::use_testthat(package_dir)
# add test files
file.copy(from = file.path("src", c("test_golden_ratio.R", 
                                    "test_.golden_ratio.R")), 
                           file.path(package_dir, "tests", "testthat"))
# build the docs
roxygen2::roxygenize(package_dir)
# Set package Metadata
desc::desc_set_authors(person(given = "Your", family = "Name", 
                              role = c("aut", "cre"), 
                              email = "your.name@somewhe.re"), 
                       file = package_dir, normalize = TRUE)
desc::desc_bump_version("minor", package_dir)
## Fix some more metadata
d <- desc::desc(package_dir)
### Use title case
d$set(Title = tools::toTitleCase(d$get("Title")))
### Set package License
d$set(License = "GPL")
d$write()
----


Nun kannst Du das Paket pr&uuml;fen:


[source,r]
----
check <- rcmdcheck::rcmdcheck(package_dir, args = "--as-cran")
----


[source,r]
----
print(check)
----

----
## 
## ── R CMD check results ───────────────────────────────── mytools 0.1.0 ────
## 
## ── 0 errors ✔ | 0 warnings ✔ | 0 notes ✔
----

Nun ja, Du hast die Metadaten noch nicht angepa&szlig;t. Solltest Du noch tun.

Du kannst Dein Paket auch testen:


[source,r]
----
covr::package_coverage(package_dir)
----

[source,r]
----
## mytools Coverage: 100.00%

----

[source,r]
----
## R/golden_ratio_internals.R: 100.00%

----

[source,r]
----
## R/golden_ratio.R: 100.00%

----


Und Du solltest immer auch die Deine <<_weniger_schlecht_programmieren,drei Freunde>>  
fragen (wobei https://CRAN.R-project.org/package=lintr[lintr] hier die vorhandene Funktion
        +.golden_ratio()+ _nicht_ erkennt und https://CRAN.R-project.org/package=cyclocomp[cyclocomp] 
        ebenfalls nicht und daher keine +cyclomatic complexity+ f&uuml;r sie berechnet:


[source,r]
----
print(lintr::lint_package(package_dir))
----

----
## R/golden_ratio.R:18:12: warning: no visible global function definition for '.golden_ratio', Did you mean 'golden_ratio'?
##     phi <- .golden_ratio()
##            ^~~~~~~~~~~~~
----

[source,r]
----
print(suppressWarnings(cleanr::check_directory(package_dir)))
----

----
## [1] TRUE
----

[source,r]
----
print(cyclocomp::cyclocomp_package_dir(package_dir))
----

----
##           name cyclocomp
## 1 golden_ratio         2
----


Gut! Das wird jetzt verpackt:

[source,r]
----
withr::with_dir(dirname(package_dir), 
                callr::rcmd_safe("build", basename(package_dir)))
----

----
## $stdout
## [1] "* checking for file ‘mytools/DESCRIPTION’ ... OK\n* preparing ‘mytools’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files\n* checking for empty or unneeded directories\n* building ‘mytools_0.1.0.tar.gz’\n"
## 
## $stderr
## [1] "\n"
## 
## $status
## [1] 0
----

[source,r]
----
package_path <- paste0(package_dir, "_0.1.0.tar.gz")
if (file.exists(package_path)) print(package_path)
----

----
## [1] "/tmp/mytools_0.1.0.tar.gz"
----


Paket fertig.

== Bibliographie
[bibliography]
- [[[cc]]] R.C. Martin. 2008. 'Clean Code: A Handbook of Agile Software Craftsmanship'. 
    Pearson Education.
- [[[cyc]]]  T. J. McCabe, 1976. 'A Complexity Measure'
   IEEE Transactions on Software Engineering archive.
   Volume 2, Issue 4, Pages 308-320 

