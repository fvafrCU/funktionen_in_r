= Regular Expressions in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

== Regular Expressions

- Ausdruck: etwas, das nicht buchst&auml;blich gemeint ist.

- https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines

-  R (?base::regex)

    *     The TRE documentation at 
          http://laurikari.net/tre/documentation/regex-syntax/
    
    *     The POSIX 1003.2 standard at 
          http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html
   
    *     The ‘pcrepattern’ ‘man’ page (found as part of 
          http://www.pcre.org/original/pcre.txt), and details of Perl’s own
          implementation at http://perldoc.perl.org/perlre.html.




== Email und Passwort

== Email

[source,r]
----
mails <- c("dominik.cullmann@forst.bwlde", 
           "@2.de", 
           "dominik.cullmann@forst.bwl.de")

print(cbind(mails, is_probably_valid_email(mails)))
----

----
##      mails                                  
## [1,] "dominik.cullmann@forst.bwlde"  "FALSE"
## [2,] "@2.de"                         "FALSE"
## [3,] "dominik.cullmann@forst.bwl.de" "TRUE"
----


==  Passwort

[source,r]
----
passwords <- c("Aa$4567",
               "aa$45678",
               "AA$45678",
               "Aa345678",
               "Aa$45678"
               )
print(cbind(passwords, is_valid_password(passwords)))
----

----
##      passwords         
## [1,] "Aa$4567"  "FALSE"
## [2,] "aa$45678" "FALSE"
## [3,] "AA$45678" "FALSE"
## [4,] "Aa345678" "FALSE"
## [5,] "Aa$45678" "TRUE"
----


== is_valid_password

[source,r]
----
# min. 8 Zeichen, Klein-, Grossbuchstabe, Zahl, Sonderzeichen
is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}
----


== is_probably_valid_email

[source,r]
----
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}
----

 
== Wiederholungen 

. {m,n}
. +
. *
. ?

== Wiederholungen I 

[source,r]
----
replacement  <- "##"
x <- "B BA BAA BAAA CA"
gsub(pattern = "BA", replacement, x)
----

----
## [1] "B ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA{2,3}", replacement, x)
----

----
## [1] "B BA ## ## CA"
----

== Wiederholungen II

[source,r]
----
gsub(pattern = "BA{0,1}", replacement, x)
----

----
## [1] "## ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA?", replacement, x)
----

----
## [1] "## ## ##A ##AA CA"
----

== Wiederholungen III

[source,r]
----
gsub(pattern = "BA{1,}", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA+", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

== Wiederholungen IV

[source,r]
----
gsub(pattern = "BA{0,}", replacement, x)
----

----
## [1] "## ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA*", replacement, x)
----

----
## [1] "## ## ## ## CA"
----


== Gruppen

[source,r]
----
replacement  <- "##"
x <- "ABA ABABA ABABABA ABABABABA"
gsub(pattern = "(BA)", replacement, x)
----

----
## [1] "A## A#### A###### A########"
----

[source,r]
----
gsub(pattern = "(BA){2,3}", replacement, x)
----

----
## [1] "ABA A## A## A##BA"
----

== Anker

[source,r]
----
replacement  <- "##"
x <- "Ha Ha HaHa Ha"
gsub(pattern = "^Ha", replacement, x)
----

----
## [1] "## Ha HaHa Ha"
----

[source,r]
----
gsub(pattern = "Ha$", replacement, x)
----

----
## [1] "Ha Ha HaHa ##"
----

[source,r]
----
gsub(pattern = "\\<Ha\\>", replacement, x)
----

----
## [1] "## ## HaHa ##"
----


== Character Sets

. Eigene Definitionen
. Vorgefertigte Definitionen
. Der Punkt


[source,r]
----
x <-  paste(c(letters, LETTERS," ", pi), collapse = "")
print(x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.14159265358979"
----

[source,r]
----
replacement  <- "#"
----

== Character Sets I

[source,r]
----
gsub(pattern = "[ .]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#3#14159265358979"
----

[source,r]
----
gsub(pattern = "[1-3]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ #.#4#59#65#58979"
----

[source,r]
----
gsub(pattern = "[^1-3]", replacement, x) ## Negative Set
----

----
## [1] "#####################################################3#1#1##2##3#####"
----


== Character Sets II

[source,r]
----
gsub(pattern = "[[:upper:]]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyz########################## 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:digit:]]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ #.##############"
----

[source,r]
----
gsub(pattern = "[[:digit:][:space:]]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ##.##############"
----


== Character Sets III

[source,r]
----
replacement  <- "##"
gsub(pattern = "1.", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.####9265358979"
----

[source,r]
----
sub(pattern = "1.*", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.##"
----

[source,r]
----
sub(pattern = ".*", replacement, x)
----

----
## [1] "##"
----


== OR

[source,r]
----
mail <- readLines(file.path(".", "src", "mail.txt"))
grep(pattern = "^From:", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
----

[source,r]
----
grep(pattern = "^Subject:", mail, value = TRUE)
----

----
## [1] "Subject: Next git2r release"
----

[source,r]
----
grep(pattern = "^[FS][[:alnum:]]*\\>:", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
## [2] "Subject: Next git2r release"                    
## [3] "Status: RO"
----

[source,r]
----
grep(pattern = "^(From|Subject):", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
## [2] "Subject: Next git2r release"
----




== A Simple String

[source,r]
----
string <- "This is a (character) string."
paste(is.vector(string), is.character(string), class(string), sep = " ## ")
----

----
## [1] "TRUE ## TRUE ## character"
----

[source,r]
----
paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "1 ## 29"
----

[source,r]
----
pattern <- "is"
----


== Regular Expressions for a Simple String

[source,r]
----
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # a list giving start and length of first match and groupings
----

----
## [[1]]
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 3 6
## attr(,"match.length")
## [1] 2 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (character) string."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1] TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "Th## is a (character) string."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "Th## ## a (character) string."
----


== A Character Vector

[source,r]
----
string <- c("This is a (not too) long sentence, stored in a (character) string.",
            "Well, it is (actually) a vector of class character.", 
            "And this is not a single sentence.")

paste(is.vector(string), is.character(string), class(string), sep = " ## ")
----

----
## [1] "TRUE ## TRUE ## character"
----

[source,r]
----
paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "3 ## 66" "3 ## 51" "3 ## 34"
----

[source,r]
----
pattern <- "[[:punct:]]?\\<[[:alnum:]]*\\>[[:punct:]]?\\s\\<(th|st)[[:alnum:]]*\\>" 
## \\s is the space class, see ?regex
----


== Regular Expressions for a Character Vector

[source,r]
----
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 26 -1  1
## attr(,"match.length")
## [1] 16 -1  8
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # a list giving start and length of first match and groupings
----

----
## [[1]]
## [1] 26 36
## attr(,"match.length")
## [1] 16  2
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 1 5
## attr(,"match.length")
## [1] 8 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 26 48
## attr(,"match.length")
## [1] 16 18
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 1
## attr(,"match.length")
## [1] 8
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1 3
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "And this is not a single sentence."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1]  TRUE FALSE  TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "This is a (not too) long ## in a (character) string."
## [2] "Well, it is (actually) a vector of class character." 
## [3] "## is not a single sentence."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "This is a (not too) long ## in a ##."               
## [2] "Well, it is (actually) a vector of class character."
## [3] "## is not a single sentence."
----




== Gefr&auml;&szlig;igkeit (greediness)

[source,r]
----
pattern <- " \\(.*\\)" 
substitution <- "" 
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a string."                       
## [2] "Well, it is a vector of class character."
## [3] "And this is not a single sentence."
----

[source,r]
----
pattern <- " \\([^\\)]*\\)" ## lazy quantifier using negation
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a long sentence, stored in a string."
## [2] "Well, it is a vector of class character."    
## [3] "And this is not a single sentence."
----

[source,r]
----
pattern <- " \\(.*?\\)" ## non-greedy quantifier -- wtf?
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a long sentence, stored in a string."
## [2] "Well, it is a vector of class character."    
## [3] "And this is not a single sentence."
----


== R&uuml;ckverweise


[source,r]
----
pattern <- "(\\<a\\>)"
substitution <- "\\1[INJECTED TEXT]"
gsub(pattern, substitution, string)
----

----
## [1] "This is a[INJECTED TEXT] (not too) long sentence, stored in a[INJECTED TEXT] (character) string."
## [2] "Well, it is (actually) a[INJECTED TEXT] vector of class character."                              
## [3] "And this is not a[INJECTED TEXT] single sentence."
----

[source,r]
----
pattern <- "^([[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?)\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)
----

----
## [1] "This [OVERWRITTEN] a (not too) long sentence, stored in a (character) string."
## [2] "Well, [OVERWRITTEN] is (actually) a vector of class character."               
## [3] "And [OVERWRITTEN] is not a single sentence."
----

[source,r]
----
# inner grouping without backreference -- nth word, substitution stays constant
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)
----

----
## [1] "This is a ([OVERWRITTEN] too) long sentence, stored in a (character) string."
## [2] "Well, it is ([OVERWRITTEN]) a vector of class character."                    
## [3] "And this is [OVERWRITTEN] a single sentence."
----

[source,r]
----
# matching the rest of the line into a second group
pattern <- paste0(pattern, "(.*)$")
substitution <- paste0(substitution, "\\2")
sub(pattern, substitution, string)
----

----
## [1] "This is a ([OVERWRITTEN] too) long sentence, stored in a (character) string."
## [2] "Well, it is ([OVERWRITTEN]) a vector of class character."                    
## [3] "And this is [OVERWRITTEN] a single sentence."
----


== Dateipfade I

[source,r]
----
# Anwendung mit Dateipfaden
## Dateien bereitstellen
rm(list= ls())
path <- file.path(tempdir(), "foo")
unlink(path, recursive = TRUE)
dir.create(path)
for (name in c("mtcars", "iris")) {
    write.csv(get(name), file = file.path(path,  paste0(name, ".csv")))
    write.table(get(name), file = file.path(path, paste0(name, ".txt")))
}
print(list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpIxnrFP/foo/iris.csv"   "/tmp/RtmpIxnrFP/foo/iris.txt"  
## [3] "/tmp/RtmpIxnrFP/foo/mtcars.csv" "/tmp/RtmpIxnrFP/foo/mtcars.txt"
----


== Dateipfade II

[source,r]
----
## Dateien lesen und wieder schreiben als deutsches CSV
csv_files <- list.files(path, pattern = "^.*\\.csv$", full.names = TRUE)
for (file in csv_files) {
    file_name <- basename(file)
    new_file <- sub("(.*)(\\.csv)", "\\1_german\\2", file)
    write.csv2(read.csv(file), file = new_file)
}
print(files <- list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpIxnrFP/foo/iris_german.csv"  
## [2] "/tmp/RtmpIxnrFP/foo/iris.csv"         
## [3] "/tmp/RtmpIxnrFP/foo/iris.txt"         
## [4] "/tmp/RtmpIxnrFP/foo/mtcars_german.csv"
## [5] "/tmp/RtmpIxnrFP/foo/mtcars.csv"       
## [6] "/tmp/RtmpIxnrFP/foo/mtcars.txt"
----


== Dateipfade III

[source,r]
----
## i-te Zeile testweise lesen
i <- 4
print(rbind(readLines(grep("iris.csv", files, value = TRUE))[i],
            readLines(grep("iris_german.csv", files, value = TRUE))[i]))
----

----
##      [,1]                                
## [1,] "\"3\",4.7,3.2,1.3,0.2,\"setosa\""  
## [2,] "\"3\";3;4,7;3,2;1,3;0,2;\"setosa\""
----


== camelCase I

[source,r]
----
code_file <- file.path(tempdir(), "code.R")
code <- "fileRename <- function(from, to) {
rootDirectory <- dirname(to)
if (! dir.exists(rootDirectory)) dir.create(rootDirectory, recursive = TRUE)
return(file.rename(from, to))
}
"

cat(code, file = code_file)
print(readLines(code_file))
----

----
## [1] "fileRename <- function(from, to) {"                                          
## [2] "rootDirectory <- dirname(to)"                                                
## [3] "if (! dir.exists(rootDirectory)) dir.create(rootDirectory, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                                               
## [5] "}"
----


== camelCase II

[source,r]
----
code <- readLines(code_file)
warning("This will blow calls to foreign camelCase such as utils::sessionInfo()!")
----

[source,r]
----
## Warning: This will blow calls to foreign camelCase such as
## utils::sessionInfo()!

----

[source,r]
----
code <- gsub("([A-Z][a-z])", "_\\L\\1", code, perl = TRUE)
writeLines(code, code_file)
print(readLines(code_file))
----

----
## [1] "file_rename <- function(from, to) {"                                           
## [2] "root_directory <- dirname(to)"                                                 
## [3] "if (! dir.exists(root_directory)) dir.create(root_directory, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                                                 
## [5] "}"
----


== camelCase III

[source,r]
----
eval(parse(text = code))
file_rename(from = files[1], to = file.path(tempdir(), "some_dir", basename(files[1])))
----

----
## [1] TRUE
----

[source,r]
----
list.files(file.path(tempdir(), "some_dir"))
----

----
## [1] "iris_german.csv"
----

== Regex in R

Meine Lieblinge

- base::regex
- base::grep # (grepl, sub, gsub, regexec, regexpr, gregexpr)
- base::list.files
- base::ls 

Sonst noch:

- install.packages(c("stringi")) ## (ICU regex engine)
- utils::apropos # (find)
- utils::browseEnv
- utils::glob2rx
- utils::help.search
- base::strsplit
- base::regmatches

== regmatches
Es gibt no base::regmatches(), aber das benutze ich nie, das ist mir zu kompliziert.
Beispiel aus der Hilfe:

[source,r]
----
 ## Consider
 x <- "John (fishing, hunting), Paul (hiking, biking)"
 ## Suppose we want to split at the comma (plus spaces) between the
 ## persons, but not at the commas in the parenthesized hobby lists.
 ## One idea is to "blank out" the parenthesized parts to match the
 ## parts to be used for splitting, and extract the persons as the
 ## non-matched parts.
 ## First, match the parenthesized hobby lists.
 m <- gregexpr("\\([^)]*\\)", x)
 ## Write a little utility for creating blank strings with given numbers
 ## of characters.
 blanks <- function(n) strrep(" ", n)
 ## Create a copy of x with the parenthesized parts blanked out.
 s <- x
 regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
 ## Compute the positions of the split matches (note that we cannot call
 ## strsplit() on x with match data from s).
 m <- gregexpr(", *", s)
 ## And finally extract the non-matched parts.
 regmatches(x, m, invert = TRUE)
----

----
## [[1]]
## [1] "John (fishing, hunting)" "Paul (hiking, biking)"
----


== Ende

- regex sind toll
- (vor allem f&auml;lschlicherweise gefr&auml;&szlig;ige) regex sind _sehr_ fehleranf&auml;llig.
- Teste daher alle Deine regex sorgf&auml;ltig.

