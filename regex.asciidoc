= Regular Expressions in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

== Regular Expressions

- Ausdruck: etwas, das nicht buchst&auml;blich gemeint ist.

- POSIX 1003.2 standard
  http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html

- https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines



== Email und Passwort

== Email

[source,r]
----
mails <- c("dominik.cullmann@forst.bwlde", 
           "@2.de", 
           "dominik.cullmann@forst.bwl.de")

print(cbind(mails, is_probably_valid_email(mails)))
----

----
##      mails                                  
## [1,] "dominik.cullmann@forst.bwlde"  "FALSE"
## [2,] "@2.de"                         "FALSE"
## [3,] "dominik.cullmann@forst.bwl.de" "TRUE"
----


==  Passwort

[source,r]
----
passwords <- c("Aa$4567",
               "aa$45678",
               "AA$45678",
               "Aa345678",
               "Aa$45678"
               )
print(cbind(passwords, is_valid_password(passwords)))
----

----
##      passwords         
## [1,] "Aa$4567"  "FALSE"
## [2,] "aa$45678" "FALSE"
## [3,] "AA$45678" "FALSE"
## [4,] "Aa345678" "FALSE"
## [5,] "Aa$45678" "TRUE"
----


== is_valid_password

[source,r]
----
# min. 8 Zeichen, Klein-, Grossbuchstabe, Zahl, Sonderzeichen
is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}
----


== is_probably_valid_email

[source,r]
----
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}
----


== Wiederholungen

[source,r]
----
replacement  <- "##"
x <- "B BA BAA BAAA CA"
gsub(pattern = "BA", replacement, x)
----

----
## [1] "B ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA{2,3}", replacement, x)
----

----
## [1] "B BA ## ## CA"
----

[source,r]
----
gsub(pattern = "BA{1,}", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA+", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA{0,}", replacement, x)
----

----
## [1] "## ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA*", replacement, x)
----

----
## [1] "## ## ## ## CA"
----


== Gruppen

[source,r]
----
replacement  <- "##"
x <- "BA BABA BABABA BABABABA"
gsub(pattern = "(BA)", replacement, x)
----

----
## [1] "## #### ###### ########"
----

[source,r]
----
gsub(pattern = "(BA){2,3}", replacement, x)
----

----
## [1] "BA ## ## ##BA"
----

== Anker

[source,r]
----
replacement  <- "##"
x <- "Ha Ha HaHa Ha"
gsub(pattern = "^Ha", replacement, x)
----

----
## [1] "## Ha HaHa Ha"
----

[source,r]
----
gsub(pattern = "Ha$", replacement, x)
----

----
## [1] "Ha Ha HaHa ##"
----

[source,r]
----
gsub(pattern = "\\<Ha\\>", replacement, x)
----

----
## [1] "## ## HaHa ##"
----


== Character Sets

[source,r]
----
replacement  <- ""
x <-  paste(c(letters, LETTERS," ", pi), collapse = "")
print(x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[ .]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ314159265358979"
----

[source,r]
----
gsub(pattern = "[1-3]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ .4596558979"
----

[source,r]
----
gsub(pattern = "[^1-3]", replacement, x) ## Negative Set
----

----
## [1] "31123"
----

[source,r]
----
gsub(pattern = "[[:upper:]]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyz 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:digit:]]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ."
----

[source,r]
----
gsub(pattern = "[[:digit:][:space:]]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ."
----


[source,r]
----

Der Punkt
----

[source,r]
----
## Error: <text>:2:5: unexpected symbol
## 1: 
## 2: Der Punkt
##        ^

----

replacement  <- "##"
gsub(pattern = "1.", replacement, x)
sub(pattern = "1.*", replacement, x)
sub(pattern = ".*", replacement, x)
//end.rcode


== A Simple String

[source,r]
----
string <- "This is a (character) string."
paste(is.vector(string), is.character(string), class(string), sep = " ## ")
----

----
## [1] "TRUE ## TRUE ## character"
----

[source,r]
----
paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "1 ## 29"
----


== Regular Expressions for a Simple String

[source,r]
----
pattern <- "is"
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # the same, as a list, better for groups.
----

----
## [[1]]
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (character) string."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 3 6
## attr(,"match.length")
## [1] 2 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "Th## is a (character) string."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "Th## ## a (character) string."
----


== A Character Vector

[source,r]
----
string <- c("This is a (not too) long sentence, stored in a (character) string.",
            "Well, it is (actually) stored in a vector of class character.", 
            "And this is not a single sentence.")

paste(is.vector(string), is.character(string), class(string), sep = " ## ")
----

----
## [1] "TRUE ## TRUE ## character"
----

[source,r]
----
paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "3 ## 66" "3 ## 61" "3 ## 34"
----


== Regular Expressions for a Character Vector

[source,r]
----
pattern <- "is"
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1]  3 10  7
## attr(,"match.length")
## [1] 2 2 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # the same, as a list, better for groups.
----

----
## [[1]]
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] 10
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 7
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1 2 3
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "Well, it is (actually) stored in a vector of class character."     
## [3] "And this is not a single sentence."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1] TRUE TRUE TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 3 6
## attr(,"match.length")
## [1] 2 2
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] 10
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1]  7 10
## attr(,"match.length")
## [1] 2 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "Th## is a (not too) long sentence, stored in a (character) string."
## [2] "Well, it ## (actually) stored in a vector of class character."     
## [3] "And th## is not a single sentence."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "Th## ## a (not too) long sentence, stored in a (character) string."
## [2] "Well, it ## (actually) stored in a vector of class character."     
## [3] "And th## ## not a single sentence."
----




== FIXME

[source,r]
----
pattern <- "\\(.*\\)"

regexpr(pattern, string) 
----

----
## [1] 11 13 -1
## attr(,"match.length")
## [1] 48 10 -1
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) 
----

----
## [[1]]
## [1] 11
## attr(,"match.length")
## [1] 48
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] 13
## attr(,"match.length")
## [1] 10
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
grep(pattern, string)
----

----
## [1] 1 2
----

[source,r]
----
grepl(pattern, string)
----

----
## [1]  TRUE  TRUE FALSE
----

[source,r]
----
grep(pattern, string, value = TRUE)
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "Well, it is (actually) stored in a vector of class character."
----

[source,r]
----
substition <- "[FOO]"
print(new_string <- sub(pattern, substition, string))
----

----
## [1] "This is a [FOO] string."                                 
## [2] "Well, it is [FOO] stored in a vector of class character."
## [3] "And this is not a single sentence."
----

[source,r]
----
nchar(string)
----

----
## [1] 66 61 34
----

[source,r]
----
nchar(new_string)
----

----
## [1] 23 56 34
----

[source,r]
----
pattern <- "\\(.*?\\)" ## non-greedy quantifier
print(new_string <- sub(pattern, substition, string))
----

----
## [1] "This is a [FOO] long sentence, stored in a (character) string."
## [2] "Well, it is [FOO] stored in a vector of class character."      
## [3] "And this is not a single sentence."
----

[source,r]
----
nchar(string)
----

----
## [1] 66 61 34
----

[source,r]
----
nchar(new_string)
----

----
## [1] 62 56 34
----

[source,r]
----
pattern <- "\\([^\\)]+\\)" ## lazy quantifier using negation
print(new_string <- sub(pattern, substition, string))
----

----
## [1] "This is a [FOO] long sentence, stored in a (character) string."
## [2] "Well, it is [FOO] stored in a vector of class character."      
## [3] "And this is not a single sentence."
----

[source,r]
----
nchar(string)
----

----
## [1] 66 61 34
----

[source,r]
----
nchar(new_string)
----

----
## [1] 62 56 34
----

[source,r]
----
pattern <- "\\<[[:alnum:]]*\\>"
substition <- "[HERE WAS THE FIRST WORD]"
regexpr(pattern, string) 
----

----
## [1] 1 1 1
## attr(,"match.length")
## [1] 4 4 3
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, substition, string)
----

----
## [1] "[HERE WAS THE FIRST WORD] is a (not too) long sentence, stored in a (character) string."
## [2] "[HERE WAS THE FIRST WORD], it is (actually) stored in a vector of class character."     
## [3] "[HERE WAS THE FIRST WORD] this is not a single sentence."
----

[source,r]
----
pattern <- "(\\<a\\>)"
substition <- "\\1[INJECTED TEXT]"
regexpr(pattern, string) 
----

----
## [1]  9 34 17
## attr(,"match.length")
## [1] 1 1 1
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, substition, string)
----

----
## [1] "This is a[INJECTED TEXT] (not too) long sentence, stored in a (character) string."
## [2] "Well, it is (actually) stored in a[INJECTED TEXT] vector of class character."     
## [3] "And this is not a[INJECTED TEXT] single sentence."
----

[source,r]
----
gregexpr(pattern, string) 
----

----
## [[1]]
## [1]  9 46
## attr(,"match.length")
## [1] 1 1
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] 34
## attr(,"match.length")
## [1] 1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 17
## attr(,"match.length")
## [1] 1
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gsub(pattern, substition, string)
----

----
## [1] "This is a[INJECTED TEXT] (not too) long sentence, stored in a[INJECTED TEXT] (character) string."
## [2] "Well, it is (actually) stored in a[INJECTED TEXT] vector of class character."                    
## [3] "And this is not a[INJECTED TEXT] single sentence."
----

[source,r]
----
pattern <- "^([[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?)\\<[[:alnum:]_]*\\>"
substition <- "\\1[HERE WAS THE SECOND WORD]"
regexpr(pattern, string) 
----

----
## [1] 1 1 1
## attr(,"match.length")
## [1] 7 8 8
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, substition, string)
----

----
## [1] "This [HERE WAS THE SECOND WORD] a (not too) long sentence, stored in a (character) string."
## [2] "Well, [HERE WAS THE SECOND WORD] is (actually) stored in a vector of class character."     
## [3] "And [HERE WAS THE SECOND WORD] is not a single sentence."
----

[source,r]
----
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>"
substition <- "\\1[HERE WAS THE FOURTH WORD]"
regexpr(pattern, string) 
----

----
## [1] 1 1 1
## attr(,"match.length")
## [1] 14 21 15
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, substition, string)
----

----
## [1] "This is a ([HERE WAS THE FOURTH WORD] too) long sentence, stored in a (character) string."
## [2] "Well, it is ([HERE WAS THE FOURTH WORD]) stored in a vector of class character."          
## [3] "And this is [HERE WAS THE FOURTH WORD] a single sentence."
----

[source,r]
----
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>(.*)$"
substition <- "\\1[HERE WAS THE FOURTH WORD]\\2"
regexpr(pattern, string) 
----

----
## [1] 1 1 1
## attr(,"match.length")
## [1] 66 61 34
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
sub(pattern, substition, string)
----

----
## [1] "This is a ([HERE WAS THE FOURTH WORD] too) long sentence, stored in a (character) string."
## [2] "Well, it is ([HERE WAS THE FOURTH WORD]) stored in a vector of class character."          
## [3] "And this is [HERE WAS THE FOURTH WORD] a single sentence."
----

[source,r]
----
gsub("(?:\\(.*?\\)|long)[[:space:]]", "", string)
----

----
## [1] "This is a sentence, stored in a string."           
## [2] "Well, it is stored in a vector of class character."
## [3] "And this is not a single sentence."
----

[source,r]
----
gsub("(?:\\(.*?\\)|long)\\  *", "", string)
----

----
## [1] "This is a sentence, stored in a string."           
## [2] "Well, it is stored in a vector of class character."
## [3] "And this is not a single sentence."
----

[source,r]
----
# Anwendung mit Dateipfaden

## Dateien bereitstellen
rm(list= ls())
path <- file.path(tempdir(), "foo")
unlink(path, recursive = TRUE)
dir.create(path)
for (name in c("mtcars", "iris")) {
    file_name <- paste0(name, ".csv")
    write.csv(get(name), file = file.path(path, file_name))
}



## Dateien lesen und wieder schreiben als deutsches CSV
print(files <- list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpJz7HRf/foo/iris.csv"   "/tmp/RtmpJz7HRf/foo/mtcars.csv"
----

[source,r]
----
for (file in files) {
    file_name <- basename(file)
    new_file <- sub("(.*)(\\.csv)", "\\1_german\\2", file)
    write.csv2(read.csv(file), file = new_file)
}
print(list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpJz7HRf/foo/iris_german.csv"  
## [2] "/tmp/RtmpJz7HRf/foo/iris.csv"         
## [3] "/tmp/RtmpJz7HRf/foo/mtcars_german.csv"
## [4] "/tmp/RtmpJz7HRf/foo/mtcars.csv"
----

[source,r]
----
## Dateien in noch nicht existente Verzeichnisse verschieben
# Das hat aber nichts mit regex zu tun.
path <- file.path(tempdir(), "bar", "foobar")
unlink(path, recursive = TRUE)
file_rename <- function(from, to) {
    root <- dirname(to)
    if (! dir.exists(root)) dir.create(root, recursive = TRUE)
    return(file.rename(from, to))
}
file_rename(file, file.path(path, basename(file)))
----

----
## [1] TRUE
----

[source,r]
----
# Anwendung camelCase -- mit Perl regex
code_file <- file.path(tempdir(), "code.R")
code <- "fileRename <- function(from, to) {
root <- dirname(to)
if (! dir.exists(root)) dir.create(root, recursive = TRUE)
return(file.rename(from, to))
}
"
cat(code, file = code_file)
print(readLines(code_file))
----

----
## [1] "fileRename <- function(from, to) {"                        
## [2] "root <- dirname(to)"                                       
## [3] "if (! dir.exists(root)) dir.create(root, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                             
## [5] "}"
----

[source,r]
----
code <- readLines(code_file)
code <- gsub("([A-Z])[a-z]", "_\\L\\1", code, perl = TRUE)
writeLines(code, code_file)
print(readLines(code_file))
----

----
## [1] "file_rname <- function(from, to) {"                        
## [2] "root <- dirname(to)"                                       
## [3] "if (! dir.exists(root)) dir.create(root, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                             
## [5] "}"
----

== Sonst noch

- ?base::regex
- ?base::grep ## (grepl, sub, gsub, regexec, regexpr, gregexpr)
- ?base::regmatches
- install.packages(c("stringi")) ## (ICU regex engine)

== regmatches
Es gibt no base::regmatches(), aber das benutze ich nie, das ist mir zu kompliziert.
Beispiel aus der Hilfe:

[source,r]
----
 ## Consider
 x <- "John (fishing, hunting), Paul (hiking, biking)"
 ## Suppose we want to split at the comma (plus spaces) between the
 ## persons, but not at the commas in the parenthesized hobby lists.
 ## One idea is to "blank out" the parenthesized parts to match the
 ## parts to be used for splitting, and extract the persons as the
 ## non-matched parts.
 ## First, match the parenthesized hobby lists.
 m <- gregexpr("\\([^)]*\\)", x)
 ## Write a little utility for creating blank strings with given numbers
 ## of characters.
 blanks <- function(n) strrep(" ", n)
 ## Create a copy of x with the parenthesized parts blanked out.
 s <- x
 regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
 ## Compute the positions of the split matches (note that we cannot call
 ## strsplit() on x with match data from s).
 m <- gregexpr(", *", s)
 ## And finally extract the non-matched parts.
 regmatches(x, m, invert = TRUE)
----

----
## [[1]]
## [1] "John (fishing, hunting)" "Paul (hiking, biking)"
----

