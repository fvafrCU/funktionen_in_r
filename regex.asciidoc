= Regular Expressions in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

== &Uuml;berblick
. Einleitung
. Werkzeuge
. R-Funktionen an Beispielen
. Fortgeschrittenes
. Anwendungen
. Ende

== Einleitung: Regul&auml;re Ausdr&uuml;cke

- Ausdruck (ugs.): etwas, das nicht buchst&auml;blich gemeint ist.

- https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines

-  R (?base::regex)

    *     The TRE documentation at 
          http://laurikari.net/tre/documentation/regex-syntax/
    
    *     The POSIX 1003.2 standard at 
          http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html
   
    *     The ‘pcrepattern’ ‘man’ page (found as part of 
          http://www.pcre.org/original/pcre.txt), and details of Perl’s own
          implementation at http://perldoc.perl.org/perlre.html.




== Email und Passwort

== Email

[source,r]
----
mails <- c("dominik.cullmann@forst.bwlde", 
           "@2.de", 
           "dominik.cullmann@forst.bwl.de")

print(cbind(mails, is_probably_valid_email(mails)))
----

----
##      mails                                  
## [1,] "dominik.cullmann@forst.bwlde"  "FALSE"
## [2,] "@2.de"                         "FALSE"
## [3,] "dominik.cullmann@forst.bwl.de" "TRUE"
----


==  Passwort

[source,r]
----
passwords <- c("Aa$4567",
               "aa$45678",
               "AA$45678",
               "Aa345678",
               "Aa$45678"
               )
print(cbind(passwords, is_valid_password(passwords)))
----

----
##      passwords         
## [1,] "Aa$4567"  "FALSE"
## [2,] "aa$45678" "FALSE"
## [3,] "AA$45678" "FALSE"
## [4,] "Aa345678" "FALSE"
## [5,] "Aa$45678" "TRUE"
----


== is_valid_password

[source,r]
----
# min. 8 characters, min. 1 uppercase, min. 1 lowercase, min. 1 special character
is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}
----


== is_probably_valid_email

[source,r]
----
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_+.-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}
----

 
== Werkzeuge
. Quantifier
. Groups
. Anchors
. Character Sets
. OR

== Quantifier 
. +{n,m}+
. +++
. +*+
. +?+

== Quantifier: +{n,m}+
Mindestens +n+ und h&ouml;chstens +m+ Wiederholungen.

[source,r]
----
replacement  <- "##"
x <- "B BA BAA BAAA CA"
gsub(pattern = "BA", replacement, x)
----

----
## [1] "B ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA{2,3}", replacement, x)
----

----
## [1] "B BA ## ## CA"
----

== Quantifier: +?+
Eine oder keine Wiederholung.

[source,r]
----
gsub(pattern = "BA{0,1}", replacement, x)
----

----
## [1] "## ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA?", replacement, x)
----

----
## [1] "## ## ##A ##AA CA"
----

== Quantifier: +++  
Mindestens eine Wiederholung.

[source,r]
----
gsub(pattern = "BA{1,}", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA+", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

== Quantifier: +*+
Mindestens keine Wiederholung.

[source,r]
----
gsub(pattern = "BA{0,}", replacement, x)
----

----
## [1] "## ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA*", replacement, x)
----

----
## [1] "## ## ## ## CA"
----


== Groups

[source,r]
----
replacement  <- "##"
x <- "ABA ABABA ABABABA ABABABABA"
gsub(pattern = "(BA)", replacement, x)
----

----
## [1] "A## A#### A###### A########"
----

[source,r]
----
gsub(pattern = "(BA){2,3}", replacement, x)
----

----
## [1] "ABA A## A## A##BA"
----

== Anchors

[source,r]
----
replacement  <- "##"
x <- "Ha Ha HaHa Ha"
gsub(pattern = "^Ha", replacement, x)
----

----
## [1] "## Ha HaHa Ha"
----

[source,r]
----
gsub(pattern = "Ha$", replacement, x)
----

----
## [1] "Ha Ha HaHa ##"
----

[source,r]
----
gsub(pattern = "\\<Ha\\>", replacement, x)
----

----
## [1] "## ## HaHa ##"
----


== Character Sets

. Eigene Definitionen
. Vorgefertigte Definitionen
. Der Punkt


[source,r]
----
x <-  paste(c(letters, LETTERS," ", pi), collapse = "")
print(x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.14159265358979"
----

[source,r]
----
replacement  <- "#"
----

== Character Sets: Eigene Definitionen

[source,r]
----
gsub(pattern = "[A-Z]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyz########################## 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[1-3]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ #.#4#59#65#58979"
----

[source,r]
----
gsub(pattern = "[^1-3]", replacement, x) # Negative Set
----

----
## [1] "#####################################################3#1#1##2##3#####"
----


== Character Sets: Vorgefertigte Definitionen

[source,r]
----
gsub(pattern = "[[:upper:]]", replacement, x) # Depends on current locale! [A-Z] does not!
----

----
## [1] "abcdefghijklmnopqrstuvwxyz########################## 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:lower:]]", replacement, x)
----

----
## [1] "##########################ABCDEFGHIJKLMNOPQRSTUVWXYZ 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:upper:][:lower:]]", replacement, x) # composite set
----

----
## [1] "#################################################### 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:alpha:]]", replacement, x) # pre-defined, same as above
----

----
## [1] "#################################################### 3.14159265358979"
----


== Character Sets: Der Punkt

[source,r]
----
replacement  <- "##"
gsub(pattern = "1.", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.####9265358979"
----

[source,r]
----
sub(pattern = "1.*", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.##"
----

[source,r]
----
sub(pattern = ".*", replacement, x)
----

----
## [1] "##"
----


== OR

[source,r]
----
mail <- readLines(file.path(".", "src", "mail.txt"))
grep(pattern = "^From:", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
----

[source,r]
----
grep(pattern = "^Subject:", mail, value = TRUE)
----

----
## [1] "Subject: Next git2r release"
----

[source,r]
----
grep(pattern = "^[FS][[:alnum:]]*\\>:", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
## [2] "Subject: Next git2r release"                    
## [3] "Status: RO"
----

[source,r]
----
grep(pattern = "^(From|Subject):", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
## [2] "Subject: Next git2r release"
----




== R-Funktionen an Beispielen
Zwei Beispielstrings, die Funktionen

- Kernfunktionen
. base::regexpr
. base::regexec
. base::gregexpr
- Anwendungsfunktionen
. base::grep
. base::grepl
. base::sub
. base::gsub


== A Simple String

[source,r]
----
string <- "This is a (character) string."
paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "1 ## 29"
----

[source,r]
----
pattern <- "is"
----


== A Simple String: Kernfunktionen

[source,r]
----
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # a list giving start and length of first match and groupings
----

----
## [[1]]
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 3 6
## attr(,"match.length")
## [1] 2 2
## attr(,"useBytes")
## [1] TRUE
----

== A Simple String: Anwendungsfunktionen

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (character) string."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1] TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "Th## is a (character) string."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "Th## ## a (character) string."
----


== A Character Vector

[source,r]
----
string <- c("This is a (not too) long sentence, stored in a (character) string.",
            "Well, it is (actually) a vector of class character.", 
            "And this is not a single sentence.")

paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "3 ## 66" "3 ## 51" "3 ## 34"
----

[source,r]
----
# match a word, possibly surrouned by punctuation, followed by some sort of
# space and a word starting with either th or st.
pattern <- "[[:punct:]]?\\<[[:alnum:]]*\\>[[:punct:]]?\\s\\<(th|st)[[:alnum:]]*\\>" 
# \\s is the space class, see ?regex
----


== A Character Vector: Kernfunktionen

[source,r]
----
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 26 -1  1
## attr(,"match.length")
## [1] 16 -1  8
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # a list giving start and length of first match and groupings
----

----
## [[1]]
## [1] 26 36
## attr(,"match.length")
## [1] 16  2
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 1 5
## attr(,"match.length")
## [1] 8 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 26 48
## attr(,"match.length")
## [1] 16 18
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 1
## attr(,"match.length")
## [1] 8
## attr(,"useBytes")
## [1] TRUE
----


== A Character Vector: Anwendungsfunktionen

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1 3
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "And this is not a single sentence."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1]  TRUE FALSE  TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "This is a (not too) long ## in a (character) string."
## [2] "Well, it is (actually) a vector of class character." 
## [3] "## is not a single sentence."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "This is a (not too) long ## in a ##."               
## [2] "Well, it is (actually) a vector of class character."
## [3] "## is not a single sentence."
----



== Fortgeschrittenes
. Gefr&auml;&szlig;igkeit
. R&uuml;ckverweise


== Gefr&auml;&szlig;igkeit (greediness)

[source,r]
----
print(string)
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "Well, it is (actually) a vector of class character."               
## [3] "And this is not a single sentence."
----

[source,r]
----
substitution <- "" 
pattern <- " \\(.*\\)" # greedy quantifier
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a string."                       
## [2] "Well, it is a vector of class character."
## [3] "And this is not a single sentence."
----

[source,r]
----
pattern <- " \\([^\\)]*\\)" # non-greedy quantifier using negation
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a long sentence, stored in a string."
## [2] "Well, it is a vector of class character."    
## [3] "And this is not a single sentence."
----

[source,r]
----
pattern <- " \\(.*?\\)" # non-greedy quantifier -- wtf?
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a long sentence, stored in a string."
## [2] "Well, it is a vector of class character."    
## [3] "And this is not a single sentence."
----


== R&uuml;ckverweise


[source,r]
----
pattern <- "(\\<a\\>)"
substitution <- "\\1[INJECTED TEXT]"
gsub(pattern, substitution, string)
----

----
## [1] "This is a[INJECTED TEXT] (not too) long sentence, stored in a[INJECTED TEXT] (character) string."
## [2] "Well, it is (actually) a[INJECTED TEXT] vector of class character."                              
## [3] "And this is not a[INJECTED TEXT] single sentence."
----

[source,r]
----
pattern <- "^([[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?)\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)
----

----
## [1] "This [OVERWRITTEN] a (not too) long sentence, stored in a (character) string."
## [2] "Well, [OVERWRITTEN] is (actually) a vector of class character."               
## [3] "And [OVERWRITTEN] is not a single sentence."
----

[source,r]
----
# inner grouping without backreference -- n+1th word, substitution stays constant
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)
----

----
## [1] "This is a ([OVERWRITTEN] too) long sentence, stored in a (character) string."
## [2] "Well, it is ([OVERWRITTEN]) a vector of class character."                    
## [3] "And this is [OVERWRITTEN] a single sentence."
----

[source,r]
----
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){7})\\<[[:alnum:]_]*\\>"
sub(pattern, substitution, string)
----

----
## [1] "This is a (not too) long sentence, [OVERWRITTEN] in a (character) string."
## [2] "Well, it is (actually) a vector of [OVERWRITTEN] character."              
## [3] "And this is not a single sentence."
----

[source,r]
----
# matching the rest of the line into a second group
pattern <- paste0(pattern, "(.*)$")
substitution <- paste0(substitution, "\\2")
sub(pattern, substitution, string)
----

----
## [1] "This is a (not too) long sentence, [OVERWRITTEN] in a (character) string."
## [2] "Well, it is (actually) a vector of [OVERWRITTEN] character."              
## [3] "And this is not a single sentence."
----


== Anwendungen
. Dateipfade
. camelCase

== Dateipfade I

[source,r]
----
#% Anwendung mit Dateipfaden
##% Dateien bereitstellen
rm(list= ls())
path <- file.path(tempdir(), "foo")
unlink(path, recursive = TRUE)
dir.create(path)
for (name in c("mtcars", "iris")) {
    write.csv(get(name), file = file.path(path,  paste0(name, ".csv")))
    write.table(get(name), file = file.path(path, paste0(name, ".txt")))
}
print(list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpK8ZyQA/foo/iris.csv"   "/tmp/RtmpK8ZyQA/foo/iris.txt"  
## [3] "/tmp/RtmpK8ZyQA/foo/mtcars.csv" "/tmp/RtmpK8ZyQA/foo/mtcars.txt"
----


== Dateipfade II

[source,r]
----
##%  _Nur_ CSV-Dateien lesen und wieder schreiben als deutsches CSV
# FIXME: Ich will eine Funktion sein!
csv_files <- list.files(path, pattern = "^.*\\.csv$", full.names = TRUE)
for (file in csv_files) {
    file_name <- basename(file)
    new_file <- sub("(.*)(\\.csv)", "\\1_german\\2", file)
    write.csv2(read.csv(file), file = new_file)
} 
print(files <- list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpK8ZyQA/foo/iris_german.csv"  
## [2] "/tmp/RtmpK8ZyQA/foo/iris.csv"         
## [3] "/tmp/RtmpK8ZyQA/foo/iris.txt"         
## [4] "/tmp/RtmpK8ZyQA/foo/mtcars_german.csv"
## [5] "/tmp/RtmpK8ZyQA/foo/mtcars.csv"       
## [6] "/tmp/RtmpK8ZyQA/foo/mtcars.txt"
----


== Dateipfade III

[source,r]
----
# i-te Zeile testweise lesen
i <- 4
print(rbind(readLines(grep("iris.csv", files, value = TRUE))[i],
            readLines(grep("iris_german.csv", files, value = TRUE))[i]))
----

----
##      [,1]                                
## [1,] "\"3\",4.7,3.2,1.3,0.2,\"setosa\""  
## [2,] "\"3\";3;4,7;3,2;1,3;0,2;\"setosa\""
----


== camelCase I

[source,r]
----
code_file <- file.path(tempdir(), "code.R")
code <- "fileRename <- function(from, to) {
rootDirectory <- dirname(to)
if (! dir.exists(rootDirectory)) dir.create(rootDirectory, recursive = TRUE)
return(file.rename(from, to))
}
"

cat(code, file = code_file)
print(readLines(code_file))
----

----
## [1] "fileRename <- function(from, to) {"                                          
## [2] "rootDirectory <- dirname(to)"                                                
## [3] "if (! dir.exists(rootDirectory)) dir.create(rootDirectory, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                                               
## [5] "}"
----


== camelCase II

[source,r]
----
code <- readLines(code_file)
warning("This will blow calls to foreign camelCase such as utils::sessionInfo()!")
----

[source,r]
----
## Warning: This will blow calls to foreign camelCase such as
## utils::sessionInfo()!

----

[source,r]
----
code <- gsub("([A-Z][a-z])", "_\\L\\1", code, perl = TRUE)
writeLines(code, code_file)
print(readLines(code_file))
----

----
## [1] "file_rename <- function(from, to) {"                                           
## [2] "root_directory <- dirname(to)"                                                 
## [3] "if (! dir.exists(root_directory)) dir.create(root_directory, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                                                 
## [5] "}"
----


== camelCase III

[source,r]
----
eval(parse(text = code))
from <- list.files(file.path(tempdir(), "foo"), pattern = "^.*iris.txt$", 
                   full.names = TRUE)
to <- file.path(tempdir(), "some_dir", basename(from))
file_rename(from = from, to = to)
----

----
## [1] TRUE
----

[source,r]
----
list.files(file.path(tempdir(), "some_dir"), full.names = TRUE)
----

----
## [1] "/tmp/RtmpK8ZyQA/some_dir/iris.txt"
----

[source,r]
----
head(read.table(to))
----

----
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
----


== Ende 
. Regex in R
. regmatches
. Tsch&uuml;ss

== Regex in R

Meine Lieblinge

- base::regex
- base::grep # (grepl, sub, gsub, regexec, regexpr, gregexpr)
- base::list.files
- base::ls 

Sonst noch:

- install.packages(c("stringi")) # (ICU regex engine)
- utils::apropos # (find)
- utils::browseEnv
- utils::glob2rx
- utils::help.search
- base::strsplit
- base::regmatches

== regmatches
Es gibt noch base::regmatches(), aber das benutze ich nie, das ist mir zu kompliziert.
Beispiel aus der Hilfe:

[source,r]
----
 ## Consider
 x <- "John (fishing, hunting), Paul (hiking, biking)"
 ## Suppose we want to split at the comma (plus spaces) between the
 ## persons, but not at the commas in the parenthesized hobby lists.
 ## One idea is to "blank out" the parenthesized parts to match the
 ## parts to be used for splitting, and extract the persons as the
 ## non-matched parts.
 ## First, match the parenthesized hobby lists.
 m <- gregexpr("\\([^)]*\\)", x)
 ## Write a little utility for creating blank strings with given numbers
 ## of characters.
 blanks <- function(n) strrep(" ", n)
 ## Create a copy of x with the parenthesized parts blanked out.
 s <- x
 regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
 ## Compute the positions of the split matches (note that we cannot call
 ## strsplit() on x with match data from s).
 m <- gregexpr(", *", s)
 ## And finally extract the non-matched parts.
 regmatches(x, m, invert = TRUE)
----

----
## [[1]]
## [1] "John (fishing, hunting)" "Paul (hiking, biking)"
----


== Tsch&uuml;ss

- Regex sind m&auml;chtig: _is_probably_valid_email_ wird mit anderen Zeichenkettenfunktionen eine sehr lange Funktion, die miserabel zu warten ist, falls sich die Definition dessen, was als Email akzeptiert werden soll, &auml;ndert. Mit regex:

[source,r]
----
pattern <- "^[a-zA-Z0-9_+.-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
----

- (vor allem f&auml;lschlicherweise gefr&auml;&szlig;ige) regex sind _sehr_ fehleranf&auml;llig. + 
  _Teste daher alle Deine regex sorgf&auml;ltig, besonders, wenn sie ".", "*" oder "+" beinhalten._

