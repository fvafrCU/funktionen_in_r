= Regular Expressions in **R**
Dominik Cullmann 
:toc2:
:toclevels: 5
:data-uri:
:duration: 60

== &Uuml;berblick
. Einleitung
. Werkzeuge
. R-Funktionen an Beispielen
. Fortgeschrittenes
. Anwendungen
. Ende

== Einleitung: Regul&auml;re Ausdr&uuml;cke

- Ausdruck (ugs.): etwas, das nicht buchst&auml;blich gemeint ist.

- https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines

-  R (?base::regex)

    *     The TRE documentation at 
          http://laurikari.net/tre/documentation/regex-syntax/
    
    *     The POSIX 1003.2 standard at 
          http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html
   
    *     The ‘pcrepattern’ ‘man’ page (found as part of 
          http://www.pcre.org/original/pcre.txt), and details of Perl’s own
          implementation at http://perldoc.perl.org/perlre.html.




== Email und Passwort

== Email

[source,r]
----
mails <- c("dominik.cullmann@forst.bwlde", 
           "@2.de", 
           "dominik.cullmann@forst.bwl.de")

print(cbind(mails, is_probably_valid_email(mails)))
----

----
##      mails                                  
## [1,] "dominik.cullmann@forst.bwlde"  "FALSE"
## [2,] "@2.de"                         "FALSE"
## [3,] "dominik.cullmann@forst.bwl.de" "TRUE"
----


==  Passwort

[source,r]
----
passwords <- c("Aa$4567",
               "aa$45678",
               "AA$45678",
               "Aa345678",
               "Aa$45678"
               )
print(cbind(passwords, is_valid_password(passwords)))
----

----
##      passwords         
## [1,] "Aa$4567"  "FALSE"
## [2,] "aa$45678" "FALSE"
## [3,] "AA$45678" "FALSE"
## [4,] "Aa345678" "FALSE"
## [5,] "Aa$45678" "TRUE"
----


== is_valid_password

[source,r]
----
# min. 8 characters, min. 1 uppercase, min. 1 lowercase, min. 1 special character
is_valid_password <- function(string) {
    minimum_length <- 8
    is_long_enough <- nchar(string) >= minimum_length
    has_uppercase <- grepl("[[:upper:]]", string)
    has_lowercase <- grepl("[[:lower:]]", string)
    has_punctation <- grepl("[[:punct:]]", string)
    is_valid <- is_long_enough & has_uppercase & has_lowercase & 
        has_punctation
    return(is_valid)
}
----


== is_probably_valid_email

[source,r]
----
is_probably_valid_email <- function(string) {
    pattern <- "^[a-zA-Z0-9_+.-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
    is_valid <- grepl(pattern, string)
    return(is_valid)
}
----

 
== Werkzeuge
. Quantifier
. Groups
. Anchors
. Character Sets
. OR

== Quantifier 
. +{n,m}+
. +++
. +*+
. +?+

== Quantifier: +{n,m}+
Mindestens +n+ und h&ouml;chstens +m+ Wiederholungen.

[source,r]
----
replacement  <- "##"
x <- "B BA BAA BAAA CA"
gsub(pattern = "BA", replacement, x)
----

----
## [1] "B ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA{2,3}", replacement, x)
----

----
## [1] "B BA ## ## CA"
----

== Quantifier: +?+
Eine oder keine Wiederholung.

[source,r]
----
gsub(pattern = "BA{0,1}", replacement, x)
----

----
## [1] "## ## ##A ##AA CA"
----

[source,r]
----
gsub(pattern = "BA?", replacement, x)
----

----
## [1] "## ## ##A ##AA CA"
----

== Quantifier: +++  
Mindestens eine Wiederholung.

[source,r]
----
gsub(pattern = "BA{1,}", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA+", replacement, x)
----

----
## [1] "B ## ## ## CA"
----

== Quantifier: +*+
Mindestens keine Wiederholung.

[source,r]
----
gsub(pattern = "BA{0,}", replacement, x)
----

----
## [1] "## ## ## ## CA"
----

[source,r]
----
gsub(pattern = "BA*", replacement, x)
----

----
## [1] "## ## ## ## CA"
----


== Groups

[source,r]
----
replacement  <- "##"
x <- "ABA ABABA ABABABA ABABABABA"
gsub(pattern = "(BA)", replacement, x)
----

----
## [1] "A## A#### A###### A########"
----

[source,r]
----
gsub(pattern = "(BA){2,3}", replacement, x)
----

----
## [1] "ABA A## A## A##BA"
----

== Anchors

[source,r]
----
replacement  <- "##"
x <- "Ha Ha HaHa Ha"
gsub(pattern = "^Ha", replacement, x)
----

----
## [1] "## Ha HaHa Ha"
----

[source,r]
----
gsub(pattern = "Ha$", replacement, x)
----

----
## [1] "Ha Ha HaHa ##"
----

[source,r]
----
gsub(pattern = "\\<Ha\\>", replacement, x)
----

----
## [1] "## ## HaHa ##"
----


== Character Sets

. Eigene Definitionen
. Vorgefertigte Definitionen
. Der Punkt


[source,r]
----
x <-  paste(c(letters, LETTERS," ", pi), collapse = "")
print(x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.14159265358979"
----

[source,r]
----
replacement  <- "#"
----

== Character Sets: Eigene Definitionen

[source,r]
----
gsub(pattern = "[A-Z]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyz########################## 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[1-3]", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ #.#4#59#65#58979"
----

[source,r]
----
gsub(pattern = "[^1-3]", replacement, x) # Negative Set
----

----
## [1] "#####################################################3#1#1##2##3#####"
----


== Character Sets: Vorgefertigte Definitionen

[source,r]
----
gsub(pattern = "[[:upper:]]", replacement, x) # Depends on current locale! [A-Z] does not!
----

----
## [1] "abcdefghijklmnopqrstuvwxyz########################## 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:lower:]]", replacement, x)
----

----
## [1] "##########################ABCDEFGHIJKLMNOPQRSTUVWXYZ 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:upper:][:lower:]]", replacement, x) # composite set
----

----
## [1] "#################################################### 3.14159265358979"
----

[source,r]
----
gsub(pattern = "[[:alpha:]]", replacement, x) # pre-defined, same as above
----

----
## [1] "#################################################### 3.14159265358979"
----


== Character Sets: Der Punkt

[source,r]
----
replacement  <- "##"
gsub(pattern = "1.", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.####9265358979"
----

[source,r]
----
sub(pattern = "1.*", replacement, x)
----

----
## [1] "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3.##"
----

[source,r]
----
sub(pattern = ".*", replacement, x)
----

----
## [1] "##"
----


== OR

[source,r]
----
mail <- readLines(file.path(".", "src", "mail.txt"))
grep(pattern = "^From:", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
----

[source,r]
----
grep(pattern = "^Subject:", mail, value = TRUE)
----

----
## [1] "Subject: Next git2r release"
----

[source,r]
----
grep(pattern = "^[FS][[:alnum:]]*\\>:", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
## [2] "Subject: Next git2r release"                    
## [3] "Status: RO"
----

[source,r]
----
grep(pattern = "^(From|Subject):", mail, value = TRUE)
----

----
## [1] "From: Stefan Widgren <stefan.widgren@gmail.com>"
## [2] "Subject: Next git2r release"
----




== R-Funktionen an Beispielen
Zwei Beispielstrings, die Funktionen

- Kernfunktionen
. base::regexpr
. base::regexec
. base::gregexpr
- Anwendungsfunktionen
. base::grep
. base::grepl
. base::sub
. base::gsub


== A Simple String

[source,r]
----
string <- "This is a (character) string."
paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "1 ## 29"
----

[source,r]
----
pattern <- "is"
----


== A Simple String: Kernfunktionen

[source,r]
----
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # a list giving start and length of first match and groupings
----

----
## [[1]]
## [1] 3
## attr(,"match.length")
## [1] 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 3 6
## attr(,"match.length")
## [1] 2 2
## attr(,"useBytes")
## [1] TRUE
----

== A Simple String: Anwendungsfunktionen

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (character) string."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1] TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "Th## is a (character) string."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "Th## ## a (character) string."
----


== A Character Vector

[source,r]
----
string <- c("This is a (not too) long sentence, stored in a (character) string.",
            "Well, it is (actually) a vector of class character.", 
            "And this is not a single sentence.")

paste(length(string), nchar(string), sep = " ## ")
----

----
## [1] "3 ## 66" "3 ## 51" "3 ## 34"
----

[source,r]
----
# match a word, possibly surrouned by punctuation, followed by some sort of
# space and a word starting with either th or st.
pattern <- "[[:punct:]]?\\<[[:alnum:]]*\\>[[:punct:]]?\\s\\<(th|st)[[:alnum:]]*\\>" 
# \\s is the space class, see ?regex
----


== A Character Vector: Kernfunktionen

[source,r]
----
regexpr(pattern, string) # a vector giving start and length of the first match
----

----
## [1] 26 -1  1
## attr(,"match.length")
## [1] 16 -1  8
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
regexec(pattern, string) # a list giving start and length of first match and groupings
----

----
## [[1]]
## [1] 26 36
## attr(,"match.length")
## [1] 16  2
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 1 5
## attr(,"match.length")
## [1] 8 2
## attr(,"useBytes")
## [1] TRUE
----

[source,r]
----
gregexpr(pattern, string) # a vector giving start and length of matches
----

----
## [[1]]
## [1] 26 48
## attr(,"match.length")
## [1] 16 18
## attr(,"useBytes")
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,"match.length")
## [1] -1
## attr(,"useBytes")
## [1] TRUE
## 
## [[3]]
## [1] 1
## attr(,"match.length")
## [1] 8
## attr(,"useBytes")
## [1] TRUE
----


== A Character Vector: Anwendungsfunktionen

[source,r]
----
grep(pattern, string) # indices of elements of "string" matching "pattern"
----

----
## [1] 1 3
----

[source,r]
----
grep(pattern, string, value = TRUE) # the elements of "string" matching "pattern"
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "And this is not a single sentence."
----

[source,r]
----
grepl(pattern, string) # Do elements of "string" contain "pattern"?
----

----
## [1]  TRUE FALSE  TRUE
----

[source,r]
----
sub(pattern, "##", string) # replace first match of pattern in string
----

----
## [1] "This is a (not too) long ## in a (character) string."
## [2] "Well, it is (actually) a vector of class character." 
## [3] "## is not a single sentence."
----

[source,r]
----
gsub(pattern, "##", string) # replace all matches of pattern in string
----

----
## [1] "This is a (not too) long ## in a ##."               
## [2] "Well, it is (actually) a vector of class character."
## [3] "## is not a single sentence."
----



== Fortgeschrittenes
. Gefr&auml;&szlig;igkeit
. R&uuml;ckverweise


== Gefr&auml;&szlig;igkeit (greediness)

[source,r]
----
print(string)
----

----
## [1] "This is a (not too) long sentence, stored in a (character) string."
## [2] "Well, it is (actually) a vector of class character."               
## [3] "And this is not a single sentence."
----

[source,r]
----
substitution <- "" 
pattern <- " \\(.*\\)" # greedy quantifier
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a string."                       
## [2] "Well, it is a vector of class character."
## [3] "And this is not a single sentence."
----

[source,r]
----
pattern <- " \\([^\\)]*\\)" # non-greedy quantifier using negation
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a long sentence, stored in a string."
## [2] "Well, it is a vector of class character."    
## [3] "And this is not a single sentence."
----

[source,r]
----
pattern <- " \\(.*?\\)" # non-greedy quantifier -- wtf?
print(new_string <- gsub(pattern, substitution, string))
----

----
## [1] "This is a long sentence, stored in a string."
## [2] "Well, it is a vector of class character."    
## [3] "And this is not a single sentence."
----


== R&uuml;ckverweise


[source,r]
----
pattern <- "(\\<a\\>)"
substitution <- "\\1[INJECTED TEXT]"
gsub(pattern, substitution, string)
----

----
## [1] "This is a[INJECTED TEXT] (not too) long sentence, stored in a[INJECTED TEXT] (character) string."
## [2] "Well, it is (actually) a[INJECTED TEXT] vector of class character."                              
## [3] "And this is not a[INJECTED TEXT] single sentence."
----

[source,r]
----
pattern <- "^([[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?)\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)
----

----
## [1] "This [OVERWRITTEN] a (not too) long sentence, stored in a (character) string."
## [2] "Well, [OVERWRITTEN] is (actually) a vector of class character."               
## [3] "And [OVERWRITTEN] is not a single sentence."
----

[source,r]
----
# inner grouping without backreference -- n+1th word, substitution stays constant
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){3})\\<[[:alnum:]_]*\\>"
substitution <- "\\1[OVERWRITTEN]"
sub(pattern, substitution, string)
----

----
## [1] "This is a ([OVERWRITTEN] too) long sentence, stored in a (character) string."
## [2] "Well, it is ([OVERWRITTEN]) a vector of class character."                    
## [3] "And this is [OVERWRITTEN] a single sentence."
----

[source,r]
----
pattern <- "^((?:[[:punct:]]?\\<[[:alnum:]_]*\\>[[:punct:]]?[[:space:]]?[[:punct:]]?){7})\\<[[:alnum:]_]*\\>"
sub(pattern, substitution, string)
----

----
## [1] "This is a (not too) long sentence, [OVERWRITTEN] in a (character) string."
## [2] "Well, it is (actually) a vector of [OVERWRITTEN] character."              
## [3] "And this is not a single sentence."
----

[source,r]
----
# matching the rest of the line into a second group
pattern <- paste0(pattern, "(.*)$")
substitution <- paste0(substitution, "\\2")
sub(pattern, substitution, string)
----

----
## [1] "This is a (not too) long sentence, [OVERWRITTEN] in a (character) string."
## [2] "Well, it is (actually) a vector of [OVERWRITTEN] character."              
## [3] "And this is not a single sentence."
----


== Anwendungen
. Dateipfade
. camelCase

== Dateipfade I

[source,r]
----
#% Anwendung mit Dateipfaden
##% Dateien bereitstellen
rm(list= ls())
path <- file.path(tempdir(), "foo")
unlink(path, recursive = TRUE)
dir.create(path)
for (name in c("mtcars", "iris")) {
    write.csv(get(name), file = file.path(path,  paste0(name, ".csv")))
    write.table(get(name), file = file.path(path, paste0(name, ".txt")))
}
print(list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpclcYcb/foo/iris.csv"   "/tmp/RtmpclcYcb/foo/iris.txt"  
## [3] "/tmp/RtmpclcYcb/foo/mtcars.csv" "/tmp/RtmpclcYcb/foo/mtcars.txt"
----


== Dateipfade II

[source,r]
----
##%  _Nur_ CSV-Dateien lesen und wieder schreiben als deutsches CSV
# FIXME: Ich will eine Funktion sein!
csv_files <- list.files(path, pattern = "^.*\\.csv$", full.names = TRUE)
for (file in csv_files) {
    file_name <- basename(file)
    new_file <- sub("(.*)(\\.csv)", "\\1_german\\2", file)
    write.csv2(read.csv(file), file = new_file)
} 
print(files <- list.files(path, full.names = TRUE))
----

----
## [1] "/tmp/RtmpclcYcb/foo/iris_german.csv"  
## [2] "/tmp/RtmpclcYcb/foo/iris.csv"         
## [3] "/tmp/RtmpclcYcb/foo/iris.txt"         
## [4] "/tmp/RtmpclcYcb/foo/mtcars_german.csv"
## [5] "/tmp/RtmpclcYcb/foo/mtcars.csv"       
## [6] "/tmp/RtmpclcYcb/foo/mtcars.txt"
----


== Dateipfade III

[source,r]
----
# i-te Zeile testweise lesen
i <- 4
print(rbind(readLines(grep("iris.csv", files, value = TRUE))[i],
            readLines(grep("iris_german.csv", files, value = TRUE))[i]))
----

----
##      [,1]                                
## [1,] "\"3\",4.7,3.2,1.3,0.2,\"setosa\""  
## [2,] "\"3\";3;4,7;3,2;1,3;0,2;\"setosa\""
----


== camelCase I

[source,r]
----
code_file <- file.path(tempdir(), "code.R")
code <- "fileRename <- function(from, to) {
rootDirectory <- dirname(to)
if (! dir.exists(rootDirectory)) dir.create(rootDirectory, recursive = TRUE)
return(file.rename(from, to))
}
"

cat(code, file = code_file)
print(readLines(code_file))
----

----
## [1] "fileRename <- function(from, to) {"                                          
## [2] "rootDirectory <- dirname(to)"                                                
## [3] "if (! dir.exists(rootDirectory)) dir.create(rootDirectory, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                                               
## [5] "}"
----


== camelCase II

[source,r]
----
code <- readLines(code_file)
warning("This will blow calls to foreign camelCase such as utils::sessionInfo()!")
----

[source,r]
----
## Warning: This will blow calls to foreign camelCase such as
## utils::sessionInfo()!

----

[source,r]
----
code <- gsub("([A-Z][a-z])", "_\\L\\1", code, perl = TRUE)
writeLines(code, code_file)
print(readLines(code_file))
----

----
## [1] "file_rename <- function(from, to) {"                                           
## [2] "root_directory <- dirname(to)"                                                 
## [3] "if (! dir.exists(root_directory)) dir.create(root_directory, recursive = TRUE)"
## [4] "return(file.rename(from, to))"                                                 
## [5] "}"
----


== camelCase III

[source,r]
----
eval(parse(text = code))
from <- list.files(file.path(tempdir(), "foo"), pattern = "^.*iris.txt$", 
                   full.names = TRUE)
to <- file.path(tempdir(), "some_dir", basename(from))
file_rename(from = from, to = to)
----

----
## [1] TRUE
----

[source,r]
----
list.files(file.path(tempdir(), "some_dir"), full.names = TRUE)
----

----
## [1] "/tmp/RtmpclcYcb/some_dir/iris.txt"
----

[source,r]
----
head(read.table(to))
----

----
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa
----


== Ende 
. Regex in R
. regmatches
. Tsch&uuml;ss

== Regex in R

Meine Lieblinge

- base::regex
- base::grep # (grepl, sub, gsub, regexec, regexpr, gregexpr)
- base::list.files
- base::ls 

Sonst noch:

- install.packages(c("stringi")) # (ICU regex engine)
- utils::apropos # (find)
- utils::browseEnv
- utils::glob2rx
- utils::help.search
- base::strsplit
- base::regmatches

== Meine Stats

[source,r]
----
count_function_calls <- function(path) {
    files <- grep("\\.Rcheck/", invert = TRUE, value = TRUE, 
                  list.files(path, recursive = TRUE, pattern = ".*[rR]$", 
                             full.names = TRUE)
                  )

    content <- NULL
    for (input in files) {
        if (!exists("input")) input <- files[192]
        content <- c(content, try(readLines(input)))

    }
    loc <- grep("^\\s*#", content, invert = TRUE, value = TRUE)
    loc <- gsub("(\\<(if|while|until|switch|ifelse|function)\\s?\\()", "#(", loc)
    code <-  paste(loc, collapse = "")
    split_char <- "@"
    code <- gsub("@", "former_split_char", code)
    calls <- gsub("((?:[[:alpha:]]+\\:{2,3})?[$A-Za-z._]+\\()", "@\\1", code)
    calls <- unlist(strsplit(calls, split = "@", fixed = TRUE))
    calls <- calls[-1]
    calls <- sub("\\(.*$", "", calls)
    total <- length(calls)
    counts <- summary(as.factor(calls), maxsum = total)
    ranked <- data.frame(count = counts, relative = counts / total, 
                         rank = as.integer(length(counts) - rank(counts) + 1))
    ranked[["relative_rank"]] <- ranked[["rank"]] / nrow(ranked)
    ordered <- ranked[order(ranked[, "relative"], decreasing = TRUE), TRUE]
    return(ordered)
}

counts <- count_function_calls("~/git/cs/fvafrcu")
head(counts, n = 10)
----

----
##           count   relative rank relative_rank
## c          4035 0.16606989    1  0.0009199632
## list       1513 0.06227106    2  0.0018399264
## return      719 0.02959213    3  0.0027598896
## names       677 0.02786352    4  0.0036798528
## structure   630 0.02592913    5  0.0045998160
## length      544 0.02238960    6  0.0055197792
## file.path   517 0.02127835    7  0.0064397424
## paste       514 0.02115488    8  0.0073597056
## get_data    388 0.01596905    9  0.0082796688
## print       270 0.01111248   10  0.0091996320
----

[source,r]
----
counts[grep("^(g?sub|grepl?|g?regexpr|regexec)$", row.names(counts)), TRUE]
----

----
##         count     relative rank relative_rank
## gsub      269 1.107133e-02   11    0.01011960
## grep      133 5.473927e-03   29    0.02667893
## sub       116 4.774252e-03   37    0.03403864
## grepl     110 4.527308e-03   39    0.03587856
## regexpr    17 6.996749e-04  191    0.17571297
## regexec     1 4.115734e-05  924    0.85004600
----




== regmatches
Es gibt noch base::regmatches(), aber das benutze ich nie, das ist mir zu kompliziert.
Beispiel aus der Hilfe:

[source,r]
----
 ## Consider
 x <- "John (fishing, hunting), Paul (hiking, biking)"
 ## Suppose we want to split at the comma (plus spaces) between the
 ## persons, but not at the commas in the parenthesized hobby lists.
 ## One idea is to "blank out" the parenthesized parts to match the
 ## parts to be used for splitting, and extract the persons as the
 ## non-matched parts.
 ## First, match the parenthesized hobby lists.
 m <- gregexpr("\\([^)]*\\)", x)
 ## Write a little utility for creating blank strings with given numbers
 ## of characters.
 blanks <- function(n) strrep(" ", n)
 ## Create a copy of x with the parenthesized parts blanked out.
 s <- x
 regmatches(s, m) <- Map(blanks, lapply(regmatches(s, m), nchar))
 ## Compute the positions of the split matches (note that we cannot call
 ## strsplit() on x with match data from s).
 m <- gregexpr(", *", s)
 ## And finally extract the non-matched parts.
 regmatches(x, m, invert = TRUE)
----

----
## [[1]]
## [1] "John (fishing, hunting)" "Paul (hiking, biking)"
----


== Tsch&uuml;ss

- Regex sind m&auml;chtig: _is_probably_valid_email_ wird mit anderen Zeichenkettenfunktionen eine sehr lange Funktion, die miserabel zu warten ist, falls sich die Definition dessen, was als Email akzeptiert werden soll, &auml;ndert. Mit regex:

[source,r]
----
pattern <- "^[a-zA-Z0-9_+.-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,3}$"
----

- (vor allem f&auml;lschlicherweise gefr&auml;&szlig;ige) regex sind _sehr_ fehleranf&auml;llig. + 
  _Teste daher alle Deine regex sorgf&auml;ltig, besonders, wenn sie ".", "*" oder "+" beinhalten._

